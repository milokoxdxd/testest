--[[ Original Anti-Idle & Services ]]--

local VirtualUser = game:GetService('VirtualUser')

if game:GetService('Players').LocalPlayer then
    game:GetService('Players').LocalPlayer.Idled:Connect(function()
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new())
    end)
end


--[[ Services ]]--

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService") -- Potrzebny do animacji UI
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")


--[[ Destroy Existing UI ]]--

-- Usuwamy stare wersje GUI, aby uniknąć konfliktów
local oldGui = PlayerGui:FindFirstChild("VenomHubScreenGui")
if oldGui then
    oldGui:Destroy()
end

local oldCategorizedGui = PlayerGui:FindFirstChild("VenomHubScreenGui_Categorized")
if oldCategorizedGui then
    oldCategorizedGui:Destroy()
end

local oldKeyGui = PlayerGui:FindFirstChild("KeyVerificationUI")
if oldKeyGui then
    oldKeyGui:Destroy()
end


-------------------------------------------------------------------------------
--  1. Tworzenie Głównego UI (Czytelne, Wieloliniowe)
-------------------------------------------------------------------------------

-- Główny kontener GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "VenomHubScreenGui_Categorized"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = PlayerGui

-- Ramka główna
local mainFrame = Instance.new("Frame")
mainFrame.Name = "VenomHubMainFrame"
mainFrame.Size = UDim2.new(0, 450, 0, 350) -- Dostosowany rozmiar
mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 20) -- Ciemne tło jak w drugim skrypcie
mainFrame.BorderSizePixel = 0
mainFrame.ClipsDescendants = true
mainFrame.Visible = true
mainFrame.Active = true
mainFrame.Draggable = false -- Wyłączymy standardowe przeciąganie, bo mamy własne
mainFrame.Parent = screenGui

-- Zaokrąglenie rogów ramki głównej
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 12)
corner.Parent = mainFrame

-- Obramowanie ramki głównej
local stroke = Instance.new("UIStroke")
stroke.Color = Color3.fromRGB(60, 60, 75) -- Obramowanie jak w drugim skrypcie
stroke.Thickness = 1
stroke.Transparency = 0.5
stroke.Parent = mainFrame

-- Tytuł
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, -40, 0, 40) -- Dostosowany rozmiar tytułu
titleLabel.Position = UDim2.new(0, 20, 0, 5) -- Trochę niżej
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "EQR Hub"
titleLabel.Font = Enum.Font.GothamSemibold -- Font jak w drugim skrypcie
titleLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
titleLabel.TextSize = 20 -- Rozmiar fontu
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = mainFrame

-- Linia pod tytułem
local line = Instance.new("Frame")
line.Name = "Divider"
line.Size = UDim2.new(1, -40, 0, 1)
line.Position = UDim2.new(0, 20, 0, 40) -- Pod tytułem
line.BackgroundColor3 = Color3.fromRGB(60, 60, 75)
line.BorderSizePixel = 0
line.Parent = mainFrame

-- Podpis (Footer)
local footerLabel = Instance.new("TextLabel")
footerLabel.Name = "Footer"
footerLabel.Size = UDim2.new(1, -20, 0, 20) -- Rozmiar i pozycja stopki
footerLabel.Position = UDim2.new(0, 10, 1, -25)
footerLabel.BackgroundTransparency = 1
footerLabel.Text = "By helloitsme#4243 | Press K to Toggle" -- Dodano info o K
footerLabel.Font = Enum.Font.Gotham -- Font jak w drugim skrypcie
footerLabel.TextSize = 10
footerLabel.TextColor3 = Color3.fromRGB(100, 100, 120)
footerLabel.TextXAlignment = Enum.TextXAlignment.Right
footerLabel.Parent = mainFrame

-- Sidebar na kategorie
local sidebarFrame = Instance.new("Frame")
sidebarFrame.Name = "SidebarFrame"
sidebarFrame.Size = UDim2.new(0, 120, 1, -70) -- Szerokość paska bocznego, wysokość dopasowana
sidebarFrame.Position = UDim2.new(0, 10, 0, 50) -- Pozycja pod linią, z lewej
sidebarFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25) -- Nieco inny odcień tła
sidebarFrame.BorderSizePixel = 0
sidebarFrame.Parent = mainFrame

local sidebarCorner = Instance.new("UICorner")
sidebarCorner.CornerRadius = UDim.new(0, 8)
sidebarCorner.Parent = sidebarFrame

local sidebarLayout = Instance.new("UIListLayout")
sidebarLayout.Padding = UDim.new(0, 5)
sidebarLayout.SortOrder = Enum.SortOrder.LayoutOrder
sidebarLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
sidebarLayout.Parent = sidebarFrame

-- Główny kontener na przyciski (z prawej strony)
local contentFrame = Instance.new("ScrollingFrame")
contentFrame.Name = "ContentFrame"
contentFrame.Size = UDim2.new(1, -150, 1, -70) -- Szerokość (całość - sidebar - marginesy), wysokość
contentFrame.Position = UDim2.new(0, 140, 0, 50) -- Pozycja obok sidebara
contentFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25) -- Taki sam jak sidebar dla spójności
contentFrame.BorderSizePixel = 0
contentFrame.ScrollingDirection = Enum.ScrollingDirection.Y
contentFrame.ScrollBarThickness = 6
contentFrame.ScrollBarImageColor3 = Color3.fromRGB(60, 60, 75)
contentFrame.CanvasSize = UDim2.new(0, 0, 0, 0) -- Początkowo zero, dynamicznie zmieniane
contentFrame.Parent = mainFrame

local contentCorner = Instance.new("UICorner")
contentCorner.CornerRadius = UDim.new(0, 8)
contentCorner.Parent = contentFrame

local contentLayout = Instance.new("UIListLayout")
contentLayout.Padding = UDim.new(0, 8)
contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
contentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
contentLayout.Parent = contentFrame


-------------------------------------------------------------------------------
--  2. Перетаскивание окна (mainFrame) при удержании ЛКМ (Oryginalny komentarz)
--     (Przeciąganie okna - Wersja z ograniczeniem do górnej belki)
-------------------------------------------------------------------------------
do
    local dragging = false
    local dragInput = nil
    local dragStart = nil
    local startPos = nil

    local function update(input)
        local delta = input.Position - dragStart
        local newX = startPos.X.Offset + delta.X
        local newY = startPos.Y.Offset + delta.Y
        mainFrame.Position = UDim2.new(startPos.X.Scale, newX, startPos.Y.Scale, newY)
    end

    mainFrame.InputBegan:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
            local absPos = mainFrame.AbsolutePosition
            local absSize = mainFrame.AbsoluteSize
            local headerHeight = 45 -- Wysokość obszaru przeciągania (belka tytułowa)

            -- Sprawdź, czy kliknięcie jest w obszarze nagłówka
            if input.Position.Y < absPos.Y + headerHeight and input.Position.Y > absPos.Y and input.Position.X > absPos.X and input.Position.X < absPos.X + absSize.X then
                dragging = true
                dragStart = input.Position
                startPos = mainFrame.Position

                -- Śledź zmianę stanu inputu (puszczenie przycisku)
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end
    end)

    mainFrame.InputChanged:Connect(function(input)
        -- Aktualizuj referencję do inputu, jeśli to ruch myszki lub dotyk
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        -- Jeśli przeciągamy i zarejestrowany input się zmienił, zaktualizuj pozycję
        if input == dragInput and dragging then
            update(input)
        end
    end)
end


-------------------------------------------------------------------------------
--  3. Клавиша [K] для показа/скрытия (Oryginalny komentarz)
--     (Klawisz [K] do Pokazania/Ukrycia)
-------------------------------------------------------------------------------
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    -- Jeśli gra nie przechwyciła inputu (np. pisanie na czacie)
    if not gameProcessedEvent then
        -- I jeśli wciśnięto klawisz K
        if input.KeyCode == Enum.KeyCode.K then
            -- Przełącz widoczność głównego okna
            mainFrame.Visible = not mainFrame.Visible
        end
    end
end)


-------------------------------------------------------------------------------
--  4. Объявляем все переменные и функции скриптов (Oryginalny komentarz)
--     ORYGINALNA LOGIKA FUNKCJI SKRYPTÓW (Formatowanie Wieloliniowe)
-------------------------------------------------------------------------------

--======================= NO FAIL LOCKPICK (Added) =========================--
local NoFailLockpick_Enabled = false

-- Function to apply lockpick modification (used by Enable/Disable and Listener)
local function ApplyLockpickModification()
    local lockpickGui = PlayerGui:FindFirstChild("LockpickGUI")
    if lockpickGui then
        task.wait(0.1) -- Short delay for safety, GUI elements might need time to load
        local scaleValue = NoFailLockpick_Enabled and 10 or 1 -- Set scale based on the enabled flag
        pcall(function() -- Use pcall for safety in case GUI structure changes
            local lpFrame = lockpickGui:FindFirstChild("MF", true) and lockpickGui.MF:FindFirstChild("LP_Frame", true)
            if lpFrame and lpFrame:FindFirstChild("Frames", true) then
                 local frames = lpFrame.Frames
                 -- Find each bar's UIScale and set its scale
                 if frames:FindFirstChild("B1", true) and frames.B1:FindFirstChild("Bar", true) and frames.B1.Bar:FindFirstChild("UIScale", true) then frames.B1.Bar.UIScale.Scale = scaleValue end
                 if frames:FindFirstChild("B2", true) and frames.B2:FindFirstChild("Bar", true) and frames.B2.Bar:FindFirstChild("UIScale", true) then frames.B2.Bar.UIScale.Scale = scaleValue end
                 if frames:FindFirstChild("B3", true) and frames.B3:FindFirstChild("Bar", true) and frames.B3.Bar:FindFirstChild("UIScale", true) then frames.B3.Bar.UIScale.Scale = scaleValue end
            else
                 -- Optional: warn("NoFailLockpick: Could not find expected structure inside existing LockpickGUI.")
            end
        end)
    end
end

local function NoFailLockpick_Enable()
    if NoFailLockpick_Enabled then return end -- Already enabled
    NoFailLockpick_Enabled = true
    ApplyLockpickModification() -- Apply modification immediately if the GUI is already open
end

local function NoFailLockpick_Disable()
    if not NoFailLockpick_Enabled then return end -- Already disabled
    NoFailLockpick_Enabled = false
    ApplyLockpickModification() -- Revert modification immediately if the GUI is already open
end
-------------------------------------------------------------------------------

--======================= OPEN NEARBY DOORS (Added) =========================--
local OpenNearbyDoors_Enabled = false
local OpenNearbyDoors_Coroutine = nil -- To manage the loop

-- The main loop logic for opening doors
local function OpenNearbyDoors_Loop()
    while OpenNearbyDoors_Enabled and task.wait(0.25) do -- Check every 0.25 seconds
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local hum = char and char:FindFirstChildOfClass("Humanoid")

        -- Stop checking if player is dead or character doesn't exist
        if not hrp or not hum or hum.Health <= 0 then
            continue -- Skip this iteration
        end

        local doorsFolder = Workspace.Map:FindFirstChild("Doors")
        if not doorsFolder then
            warn("OpenNearbyDoors: Cannot find Workspace.Map.Doors folder.")
            OpenNearbyDoors_Disable() -- Disable the feature if the folder is missing
            break -- Exit the loop
        end

        local playerPos = hrp.Position
        for _, doorInstance in ipairs(doorsFolder:GetChildren()) do
             -- Check if the instance looks like a valid door model based on children
            local doorBase = doorInstance:FindFirstChild("DoorBase")
            local valuesFolder = doorInstance:FindFirstChild("Values")
            local eventsFolder = doorInstance:FindFirstChild("Events")

            if doorBase and valuesFolder and eventsFolder then
                local openValue = valuesFolder:FindFirstChild("Open")
                local toggleEvent = eventsFolder:FindFirstChild("Toggle")
                -- Find a part likely used as the second argument, e.g., Knob2 or similar name
                local knobArgument = doorInstance:FindFirstChild("Knob2") or doorInstance:FindFirstChild("Knob") -- Adjust if needed

                -- Proceed only if all required parts/values/events are found
                if openValue and toggleEvent and knobArgument and typeof(openValue.Value) == "boolean" then
                    -- Check distance and if the door is currently closed
                    if (playerPos - doorBase.Position).Magnitude <= 6 then -- Slightly increased range
                        if openValue.Value == false then
                            -- Fire the event safely using pcall
                            local success, err = pcall(function()
                                toggleEvent:FireServer("Open", knobArgument)
                            end)
                            if not success then
                                warn("OpenNearbyDoors: Error firing Toggle event for door", doorInstance.Name, ":", err)
                            end
                            -- No wait here, check all nearby doors in one cycle
                        end
                    end
                end
            end
        end
    end
    OpenNearbyDoors_Coroutine = nil -- Clear coroutine reference when loop finishes
end

-- Enable function starts the loop
local function OpenNearbyDoors_Enable()
    if OpenNearbyDoors_Enabled then return end -- Already enabled
    OpenNearbyDoors_Enabled = true
    -- Start the loop in a new coroutine if it's not already running
    if not OpenNearbyDoors_Coroutine then
        OpenNearbyDoors_Coroutine = task.spawn(OpenNearbyDoors_Loop)
    end
end

-- Disable function sets the flag, the loop will stop itself
local function OpenNearbyDoors_Disable()
    if not OpenNearbyDoors_Enabled then return end -- Already disabled
    OpenNearbyDoors_Enabled = false
    -- The loop checks the 'OpenNearbyDoors_Enabled' flag and will exit automatically.
    -- Coroutine reference is cleared inside the loop itself.
end
-------------------------------------------------------------------------------

--================== NEARBY DOOR INTERACTIONS (Open & Unlock - Combined) ==================--
local OpenNearbyDoors_Enabled = false
local UnlockNearbyDoors_Enabled = false
local NearbyDoorInteraction_Coroutine = nil -- Single coroutine for both features

-- Combined loop function for handling nearby door opening and unlocking
local function NearbyDoorInteraction_Loop()
    while (OpenNearbyDoors_Enabled or UnlockNearbyDoors_Enabled) do -- Run as long as at least one feature is active
        local waitTime = 0.25 -- How often to check nearby doors
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local hum = char and char:FindFirstChildOfClass("Humanoid")

        -- If player is dead or character doesn't exist, wait longer before next check
        if not hrp or not hum or hum.Health <= 0 then
            task.wait(waitTime * 2) -- Wait longer if dead/no char
            continue
        end

        local doorsFolder = Workspace.Map:FindFirstChild("Doors")
        if not doorsFolder then
            warn("NearbyDoorInteraction: Cannot find Workspace.Map.Doors folder. Disabling features.")
            -- Disable both features if the folder is missing
            if OpenNearbyDoors_Enabled then OpenNearbyDoors_Disable() end
            if UnlockNearbyDoors_Enabled then UnlockNearbyDoors_Disable() end
            break -- Exit the loop permanently if structure is wrong
        end

        local playerPos = hrp.Position
        local checkRadius = 6 -- How close the player needs to be

        for _, doorInstance in ipairs(doorsFolder:GetChildren()) do
            -- Basic checks for a valid door structure
            local doorBase = doorInstance:FindFirstChild("DoorBase")
            local valuesFolder = doorInstance:FindFirstChild("Values")
            local eventsFolder = doorInstance:FindFirstChild("Events")

            if doorBase and valuesFolder and eventsFolder then
                -- Check distance first for performance
                if (playerPos - doorBase.Position).Magnitude <= checkRadius then
                    local toggleEvent = eventsFolder:FindFirstChild("Toggle")
                    if not toggleEvent then continue end -- Skip if no Toggle event

                    -- --- Unlock Logic ---
                    if UnlockNearbyDoors_Enabled then
                        local lockedValue = valuesFolder:FindFirstChild("Locked")
                        local lockArgument = doorInstance:FindFirstChild("Lock") -- Instance needed for Unlock event

                        -- Check if door is locked and we have the needed parts/values
                        if lockedValue and lockArgument and typeof(lockedValue.Value) == "boolean" and lockedValue.Value == true then
                            -- Fire the "Unlock" event safely
                            local success, err = pcall(function() toggleEvent:FireServer("Unlock", lockArgument) end)
                            if not success then warn("UnlockNearbyDoors: Error firing event for", doorInstance.Name, ":", err) end
                            -- If unlock succeeds, the door might become openable immediately,
                            -- so we let the Open logic below handle it in the same cycle if needed.
                        end
                    end

                    -- --- Open Logic ---
                    if OpenNearbyDoors_Enabled then
                        local openValue = valuesFolder:FindFirstChild("Open")
                         -- Argument for Open event (usually Knob2 or similar)
                        local knobArgument = doorInstance:FindFirstChild("Knob2") or doorInstance:FindFirstChild("Knob")

                         -- Check if door is closed and we have the needed parts/values
                        if openValue and knobArgument and typeof(openValue.Value) == "boolean" and openValue.Value == false then
                            -- Check if it's *not* locked (or if unlock is off and we don't care)
                            local isLocked = valuesFolder:FindFirstChild("Locked")
                            if not isLocked or isLocked.Value == false or not UnlockNearbyDoors_Enabled then
                                 -- Fire the "Open" event safely
                                local success, err = pcall(function() toggleEvent:FireServer("Open", knobArgument) end)
                                if not success then warn("OpenNearbyDoors: Error firing event for", doorInstance.Name, ":", err) end
                            end
                        end
                    end
                end -- End distance check
            end -- End valid door structure check
        end -- End door loop

        task.wait(waitTime) -- Wait before the next full check cycle
    end -- End while loop
    NearbyDoorInteraction_Coroutine = nil -- Clear reference when loop naturally exits
end

-- Helper function to start/stop the single interaction loop
local function StartStopDoorInteractionLoop()
    -- Check if the loop should be running
    local shouldRun = OpenNearbyDoors_Enabled or UnlockNearbyDoors_Enabled

    if shouldRun and not NearbyDoorInteraction_Coroutine then
        -- Start the loop if it should run but isn't currently
        NearbyDoorInteraction_Coroutine = task.spawn(NearbyDoorInteraction_Loop)
    elseif not shouldRun and NearbyDoorInteraction_Coroutine then
         -- The loop will stop itself because the while condition will be false.
         -- The coroutine reference is cleared inside the loop function.
    end
end

-- --- Enable/Disable Functions ---

-- Open Doors
function OpenNearbyDoors_Enable()
    if OpenNearbyDoors_Enabled then return end
    OpenNearbyDoors_Enabled = true
    StartStopDoorInteractionLoop()
end

function OpenNearbyDoors_Disable()
    if not OpenNearbyDoors_Enabled then return end
    OpenNearbyDoors_Enabled = false
    StartStopDoorInteractionLoop()
end

-- Unlock Doors
function UnlockNearbyDoors_Enable()
    if UnlockNearbyDoors_Enabled then return end
    UnlockNearbyDoors_Enabled = true
    StartStopDoorInteractionLoop()
end

function UnlockNearbyDoors_Disable()
    if not UnlockNearbyDoors_Enabled then return end
    UnlockNearbyDoors_Enabled = false
    StartStopDoorInteractionLoop()
end
-------------------------------------------------------------------------------

--======================= Fling (z nowego skryptu) =========================--
local FlingTP_TargetName = "Enter target nick..." -- Zmienna do przechowywania nazwy celu dla teleportacji przy Flingu
local FlingTP_Enabled = false -- Nowa flaga stanu dla ciągłego Fling TP
local FlingTP_Coroutine = nil -- Do przechowywania korutyny pętli Fling TP
local FlingTP_Loop_Logic -- Deklaracja wstępna dla funkcji pętli
local Fling_Enabled = false
local Fling_Coroutine = nil
local Fling_Function_Logic -- Deklaracja wstępna dla funkcji logiki

-- Funkcja zawierająca główną logikę Fling
Fling_Function_Logic = function()
    -- Użyj globalnych serwisów zdefiniowanych na górze głównego skryptu
	local lp = Players.LocalPlayer
	local c, hrp, vel, movel = nil, nil, nil, 0.1

	while Fling_Enabled do -- Używamy nowej zmiennej Fling_Enabled
		RunService.Heartbeat:Wait() -- Użyj globalnego RunService
		c = lp.Character
		hrp = c and c:FindFirstChild("HumanoidRootPart")

		if hrp then
			vel = hrp.Velocity
			hrp.Velocity = vel * 100000000 + Vector3.new(0, 100000000, 0)
			RunService.RenderStepped:Wait()
			hrp.Velocity = vel
			RunService.Stepped:Wait()
			hrp.Velocity = vel + Vector3.new(0, movel, 0)
			movel = -movel
		end
	end
end

-- Funkcja włączająca Fling
local function Fling_Enable()
    if Fling_Enabled then return end
    Fling_Enabled = true

    -- Sprawdzenie i ewentualne utworzenie Decal (z oryginalnego skryptu Fling)
    local ReplicatedStorage = game:GetService("ReplicatedStorage") -- Upewnij się, że RS jest dostępne
    if not ReplicatedStorage:FindFirstChild("juisdfj0i32i0eidsuf0iok") then
        local detection = Instance.new("Decal")
        detection.Name = "juisdfj0i32i0eidsuf0iok"
        detection.Parent = ReplicatedStorage
    end

    -- Uruchomienie logiki w nowej korutynie
    if Fling_Coroutine then -- Upewnij się, że stara korutyna jest zakończona, jeśli istnieje
         coroutine.close(Fling_Coroutine) -- Chociaż powinna sama się zakończyć przez flagę
         Fling_Coroutine = nil
    end
    Fling_Coroutine = coroutine.create(Fling_Function_Logic)
    coroutine.resume(Fling_Coroutine)
end

-- Funkcja wyłączająca Fling
local function Fling_Disable()
	-- Warunek zapobiegający wielokrotnemu wywołaniu
	if not Fling_Enabled then return end

	-- Wyłącz główny Fling
	Fling_Enabled = false
	-- Główna korutyna Flinga (jeśli istnieje) sama się zatrzyma przez zmianę flagi Fling_Enabled

	-- === DODANA LOGIKA: Sprawdź i wyłącz Fling TP ===
	if FlingTP_Enabled then -- Sprawdź, czy Fling TP jest aktualnie włączony
		FlingTP_Disable() -- Wywołaj funkcję wyłączającą Fling TP
		-- FlingTP_Disable() samo zajmie się ustawieniem FlingTP_Enabled = false
		-- i próbą aktualizacji przycisku Fling TP do stanu OFF / czerwony.
	end
	-- === KONIEC DODANEJ LOGIKI ===

	-- Aktualizacja przycisku GŁÓWNEGO Flinga (jeśli istnieje i jest potrzebna)
    -- Ta część zależy od tego, jak zarządzasz aktualizacją przycisku Fling
    -- Możliwe, że już jest obsługiwana przez globalny system bindów/przycisków
	local flingFrame = nil
	for k, v in pairs(activeBinds) do if v.onEnable == Fling_Enable then flingFrame = v.frame; break; end end
	if not flingFrame and categoryFrames and categoryFrames.Fling then -- Fallback search
		 for _, f in ipairs(categoryFrames.Fling) do
              -- Znajdź ramkę dla przycisku 'Fling', może wymagać dostosowania nazwy
              if f:FindFirstChild("TextLabel") and f.TextLabel.Text == " Fling" then
                   flingFrame = f
                   break
              end
         end
	end
	if flingFrame and rowFunctionData[flingFrame] and rowFunctionData[flingFrame].updateFn then
		local success, err = pcall(rowFunctionData[flingFrame].updateFn)
        if not success then warn("Fling Disable: Failed to update main Fling button visuals:", err) end
    end

end
-- Funkcja teleportująca do celu, jeśli Fling jest aktywny
local function TeleportToFlingTarget()
	if not Fling_Enabled then
		pcall(function()
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title = "Fling Teleport",
				Text = "You have to toggle ON Fling!",
				Duration = 4
			})
		end)
		return
	end

	if not FlingTP_TargetName or FlingTP_TargetName == "Enter target name..." or FlingTP_TargetName == "" then
		pcall(function()
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title = "Fling Teleport",
				Text = "Enter target name'.",
				Duration = 4
			})
		end)
		return
	end

	local targetPlayer = Players:FindFirstChild(FlingTP_TargetName) -- Użyj globalnego serwisu Players
	if not targetPlayer then
		pcall(function()
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title = "Fling Teleport",
				Text = "Target player not found: " .. FlingTP_TargetName,
				Duration = 4
			})
		end)
		return
	end

	if targetPlayer == LocalPlayer then -- Użyj globalnego LocalPlayer
         pcall(function()
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title = "Fling Teleport",
				Text = "You can't fling yourself.",
				Duration = 4
			})
		end)
		return
	end

	local localChar = LocalPlayer.Character
	local targetChar = targetPlayer.Character
	local localHRP = localChar and localChar:FindFirstChild("HumanoidRootPart")
	local targetHRP = targetChar and targetChar:FindFirstChild("HumanoidRootPart")

	if localHRP and targetHRP then
		localHRP.CFrame = targetHRP.CFrame -- Teleportacja DOKŁADNIE do pozycji celu
	else
		if not localHRP then end
		if not targetHRP then end
        pcall(function()
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title = "Fling Teleport",
				Text = "Error: Can't find target player.",
				Duration = 4
			})
		end)
	end
end
-- Główna pętla logiki dla ciągłego Fling TP (WERSJA Z OFFSETEM 1 STUD)
-- Main logic loop for continuous Fling TP (2 Stud Offset version + English)
FlingTP_Loop_Logic = function()
	local flingTpMoveVel = 0.1 -- Local variable for the target's small fling up/down movement
	local targetPlayer = nil -- Variable for the target player within this loop

	-- Thresholds for movement detection (ADJUST runningThresholdMultiplier IF NEEDED)
	local standingThreshold = 1.0 -- Velocity magnitude below this is considered standing still
	local runningThresholdMultiplier = 2.5 -- Increased multiplier. Adjust if needed.

	-- Loop runs as long as this mode is enabled AND the main Fling is enabled
	while FlingTP_Enabled and Fling_Enabled do
		RunService.Heartbeat:Wait() -- Wait a frame

		-- Check if we have a valid target at the start of each iteration
		if not targetPlayer or not targetPlayer:IsDescendantOf(Players) then -- If target disappeared or first iteration
            if not FlingTP_TargetName or FlingTP_TargetName == "Enter target nick..." or FlingTP_TargetName == "Enter nickname..." or FlingTP_TargetName == "" then -- Check Polish and English placeholders
				FlingTP_Disable() -- Disable if no target
				break -- Exit loop
			end
			targetPlayer = Players:FindFirstChild(FlingTP_TargetName)
			if not targetPlayer then
				FlingTP_Disable() -- Disable if target not found
				break -- Exit loop
			end
			-- print("Fling TP Loop: Target acquired: " .. targetPlayer.Name) -- Keep commented unless debugging
		end

		-- Get characters and HRPs (must be checked each iteration)
		local localChar = LocalPlayer.Character
		local targetChar = targetPlayer.Character
		local localHRP = localChar and localChar:FindFirstChild("HumanoidRootPart")
		local targetHRP = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
		local targetHum = targetChar and targetChar:FindFirstChildOfClass("Humanoid")

		-- Check continuation conditions
		if not localHRP then
			continue -- Wait for respawn
		end

		if not targetHRP or not targetHum or targetHum.Health <= 0 then
			warn("Fling TP Loop: Target (" .. (targetPlayer and targetPlayer.Name or "Unknown") .. ") is dead or lacks HRP/Humanoid.")
			--FlingTP_Disable() -- <<< Wywołanie Disable, gdy cel umiera/jest nieprawidłowy
			break -- Exit loop
		end

		-- === DYNAMIC OFFSET CALCULATION (CORRECTED LOGIC ORDER) ===
		local currentTargetVelocityMag = targetHRP.Velocity.Magnitude
		local targetBaseWalkSpeed = targetHum.WalkSpeed
		local dynamicOffsetDistance -- Declare variable

		-- Check for RUNNING first (highest speed condition)
		if currentTargetVelocityMag > targetBaseWalkSpeed * runningThresholdMultiplier then
			dynamicOffsetDistance = 13 -- Assign RUNNING distance

		-- Check for WALKING next (intermediate speed condition)
		elseif currentTargetVelocityMag >= standingThreshold then
			dynamicOffsetDistance = 8 -- Assign WALKING distance

		-- Must be STANDING otherwise (lowest speed condition)
		else
			dynamicOffsetDistance = 1 -- Assign STANDING distance
		end
		-- === END OF DYNAMIC OFFSET CALCULATION ===


		-- === TELEPORTATION LOGIC USING DYNAMIC OFFSET ===
		-- 1. Teleport local player DYNAMICALLY IN FRONT of the target
		local targetLookVector = targetHRP.CFrame.LookVector -- Direction the target is facing
		local desiredPosition = targetHRP.Position + (targetLookVector * dynamicOffsetDistance) -- Calculate position using dynamic offset
		-- Set CFrame to be at the new position, looking TOWARDS the target's position
		local newCFrame = CFrame.new(desiredPosition, targetHRP.Position)
		localHRP.CFrame = newCFrame
		-- === END OF TELEPORTATION LOGIC ===

		-- 2. Apply fling effect TO THE TARGET (no change, includes safety check)
		local targetVel = targetHRP.Velocity
		if targetVel.Magnitude < 500 then -- Avoid multiplying already huge velocities
			targetHRP.Velocity = targetVel * 1000000000 + Vector3.new(0, 1000000000, 0)
			RunService.RenderStepped:Wait() -- Wait for render for the change to be effective
			targetHRP.Velocity = targetVel -- Reset to original velocity
			RunService.Stepped:Wait() -- Wait for physics step
			targetHRP.Velocity = targetVel + Vector3.new(0, flingTpMoveVel, 0) -- Small up/down movement
			flingTpMoveVel = -flingTpMoveVel -- Reverse direction for the next iteration
		else
			RunService.Stepped:Wait() -- Still wait even if not applying force
		end


	end -- Koniec pętli while

	-- === USUNIĘTY BLOK KODU ===
	-- Poniższy blok został usunięty, ponieważ FlingTP_Disable() jest już wywoływane
	-- w odpowiednich momentach (wewnątrz pętli lub przez użytkownika) i zawiera
	-- warunek zapobiegający wielokrotnemu wykonaniu.
	--[[
	if FlingTP_Enabled then
		FlingTP_Enabled = false
		-- Might need to update the UI button here if createToggleRowFrame doesn't catch it
		local frame = nil
		-- Attempt to find the associated frame/button to update its visual state
        for k, v in pairs(activeBinds) do if v.onEnable == FlingTP_Enable then frame = v.frame; break; end end
        if not frame and categoryFrames and categoryFrames.Fling then -- Fallback search
             for _, f in ipairs(categoryFrames.Fling) do if f.Name == "FlingTPToTarget" then frame = f; break; end end
        end
		if frame and rowFunctionData[frame] and rowFunctionData[frame].updateFn then
			local success, err = pcall(rowFunctionData[frame].updateFn) -- Try to update the button visuals
            if not success then warn("Fling TP Loop: Failed to update button visuals on loop end:", err) end
        else
             warn("Fling TP Loop: Could not find button frame or update function on loop end.")
        end
	end
	]]--
	-- === KONIEC USUNIĘTEGO BLOKU ===

	FlingTP_Coroutine = nil -- Ustaw korutynę na nil po zakończeniu pętli
end

-- Function to enable continuous Fling TP (English version)
local function FlingTP_Enable()
	if FlingTP_Enabled then return end -- Already enabled

	if not Fling_Enabled then
		pcall(function()
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title = "Fling TP",
				Text = "You need to enable the main Fling first!",
				Duration = 4
			})
		end)
		return -- Don't enable because main Fling is off
	end

    -- Check both Polish and English placeholders, just in case
	if not FlingTP_TargetName or FlingTP_TargetName == "Enter target nick..." or FlingTP_TargetName == "Enter nickname..." or FlingTP_TargetName == "" then
		pcall(function()
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title = "Fling TP",
				Text = "Enter a target player name first.",
				Duration = 4
			})
		end)
		return -- Don't enable without a target
	end

	local targetPlayer = Players:FindFirstChild(FlingTP_TargetName)
	if not targetPlayer then
		pcall(function()
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title = "Fling TP",
				Text = "Target player not found: " .. FlingTP_TargetName,
				Duration = 4
			})
		end)
		return -- Don't enable if target doesn't exist
	end

    if targetPlayer == LocalPlayer then
        pcall(function()
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title = "Fling TP",
				Text = "You cannot target yourself.",
				Duration = 4
			})
		end)
        return -- Don't enable if targeting self
    end


	-- All conditions met, enable the feature
	FlingTP_Enabled = true

	-- Start the loop logic in a coroutine
	if FlingTP_Coroutine then coroutine.close(FlingTP_Coroutine); FlingTP_Coroutine = nil; end -- Close old one if exists
	FlingTP_Coroutine = coroutine.create(FlingTP_Loop_Logic)
	coroutine.resume(FlingTP_Coroutine)
    -- Explicitly update button visuals after enabling state
    -- (This helps ensure the button shows "ON" immediately)
     local frame = nil
     for k, v in pairs(activeBinds) do if v.onEnable == FlingTP_Enable then frame = v.frame; break; end end
      if not frame and categoryFrames and categoryFrames.Fling then -- Fallback search
          for _, f in ipairs(categoryFrames.Fling) do if f.Name == "FlingTPToTarget" then frame = f; break; end end
     end
     if frame and rowFunctionData[frame] and rowFunctionData[frame].updateFn then
          pcall(rowFunctionData[frame].updateFn)
     end
end

-- Function to disable continuous Fling TP (English version)
local function FlingTP_Disable()
	-- !!! WAŻNY WARUNEK: Jeśli już jest wyłączone, nic nie rób !!! --
	if not FlingTP_Enabled then return end -- Already disabled

	-- Jeśli doszło tutaj, oznacza to, że było włączone i teraz jest wyłączane
	FlingTP_Enabled = false
	-- Pętla w FlingTP_Loop_Logic sama się zakończy, bo warunek `while FlingTP_Enabled...` będzie fałszywy
	-- FlingTP_Coroutine jest ustawiane na nil w pętli po jej zakończeniu

	-- Explicitly update button visuals after disabling state
	local frame = nil
	-- Attempt to find the associated frame/button to update its visual state
	for k, v in pairs(activeBinds) do if v.onEnable == FlingTP_Enable then frame = v.frame; break; end end
	if not frame and categoryFrames and categoryFrames.Fling then -- Fallback search
		 for _, f in ipairs(categoryFrames.Fling) do if f.Name == "FlingTPToTarget" then frame = f; break; end end
	end
	if frame and rowFunctionData[frame] and rowFunctionData[frame].updateFn then
		local success, err = pcall(rowFunctionData[frame].updateFn) -- Try to update the button visuals
		if not success then end
	end
end
-------------------------------------------------------------------------------
-- Block for: Auto Pickup Money (Add this with other function definitions)
-------------------------------------------------------------------------------

--[[ NOTE: This feature assumes global 'Settings' and 'CoolDowns' tables exist
     with the required structure (Settings.IsDead, CoolDowns.AutoPickUps.MoneyCooldown)
     Ensure these are defined elsewhere in your main script. ]]

local AutoPickupMoney_Enabled = false
local AutoPickupMoney_Connection = nil
local AutoPickupMoney_Coroutine = nil -- To manage the coroutine itself

-- Placeholder for CoolDowns if not defined globally yet (REMOVE if defined globally)
-- local CoolDowns = { AutoPickUps = { MoneyCooldown = false } }
-- Placeholder for Settings if not defined globally yet (REMOVE if defined globally)
-- local Settings = { IsDead = false } -- Example: Assume the player starts alive

local function AutoPickupMoney_Logic()
    -- Use global services assumed to be defined at the top
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")

    local cashFolder = Workspace.Filter:FindFirstChild("SpawnedBread")
    local remoteEvent = ReplicatedStorage.Events:FindFirstChild("CZDPZUS")

    if not cashFolder then
        warn("AutoPickupMoney: Could not find Workspace.Filter.SpawnedBread folder.")
        AutoPickupMoney_Disable() -- Disable if the folder doesn't exist
        return
    end
    if not remoteEvent then
        warn("AutoPickupMoney: Could not find ReplicatedStorage.Events.CZDPZUS RemoteEvent.")
        AutoPickupMoney_Disable() -- Disable if the remote doesn't exist
        return
    end

    -- Ensure CoolDowns structure exists (or create it safely)
    if not CoolDowns then CoolDowns = {} end
    if not CoolDowns.AutoPickUps then CoolDowns.AutoPickUps = {} end
    if CoolDowns.AutoPickUps.MoneyCooldown == nil then CoolDowns.AutoPickUps.MoneyCooldown = false end
     -- Ensure Settings structure exists (or create it safely)
    if not Settings then Settings = {} end
    if Settings.IsDead == nil then Settings.IsDead = false end -- Default to alive


    AutoPickupMoney_Connection = RunService.RenderStepped:Connect(function()
        -- Primary check: Is the feature enabled?
        if not AutoPickupMoney_Enabled then return end

        -- Check if player is dead (using the assumed Settings table)
        if Settings.IsDead then return end

        local player = Players.LocalPlayer
        local character = player and player.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")

        -- Check if player character and HRP exist
        if not hrp then return end

        -- Check cooldown *before* iterating (minor optimization)
        if CoolDowns.AutoPickUps.MoneyCooldown then return end

        local rootPosition = hrp.Position
        for i, v in ipairs(cashFolder:GetChildren()) do
            -- Check distance
            if (rootPosition - v.Position).Magnitude < 5 then
                -- Check cooldown again (might have changed between iterations, though unlikely here)
                if not CoolDowns.AutoPickUps.MoneyCooldown then
                    CoolDowns.AutoPickUps.MoneyCooldown = true
                    pcall(function() -- Use pcall for safety when firing remote
                        remoteEvent:FireServer(v)
                    end)

                    task.wait(1) -- Use task.wait instead of wait

                    CoolDowns.AutoPickUps.MoneyCooldown = false
                    break -- Exit loop after picking one up to prevent potential spam
                end
            end
        end
    end)
end

local function AutoPickupMoney_Enable()
    if AutoPickupMoney_Enabled then return end
    AutoPickupMoney_Enabled = true

    -- Disconnect old connection if somehow exists
    if AutoPickupMoney_Connection then
        AutoPickupMoney_Connection:Disconnect()
        AutoPickupMoney_Connection = nil
    end
     -- Stop existing coroutine if it exists
    if AutoPickupMoney_Coroutine then
        coroutine.close(AutoPickupMoney_Coroutine)
        AutoPickupMoney_Coroutine = nil
    end

    -- Start the logic in a coroutine
    AutoPickupMoney_Coroutine = coroutine.create(AutoPickupMoney_Logic)
    coroutine.resume(AutoPickupMoney_Coroutine)

    -- Optional: Update button visuals immediately if needed (the framework might handle this already)
    -- findButtonAndUpdateVisuals("Auto pickup money")
end

local function AutoPickupMoney_Disable()
    if not AutoPickupMoney_Enabled then return end
    AutoPickupMoney_Enabled = false

    -- Disconnect the RenderStepped event
    if AutoPickupMoney_Connection then
        AutoPickupMoney_Connection:Disconnect()
        AutoPickupMoney_Connection = nil
    end
    -- Stop the coroutine
    if AutoPickupMoney_Coroutine then
        coroutine.close(AutoPickupMoney_Coroutine)
        AutoPickupMoney_Coroutine = nil
    end

    -- Reset cooldown just in case it was stuck on true
    if CoolDowns and CoolDowns.AutoPickUps then
        CoolDowns.AutoPickUps.MoneyCooldown = false
    end

     -- Optional: Update button visuals immediately if needed
    -- findButtonAndUpdateVisuals("Auto pickup money")
end
--============================ Fly ============================--
local Fly_Enabled = false
local Fly_Bind = nil
local Fly_Connection
local Fly_Speed = 50

local function Fly_Enable()
    if Fly_Enabled then
        return
    end
    Fly_Enabled = true

    Fly_Connection = RunService.RenderStepped:Connect(function(dt)
        if not Fly_Enabled then
            return
        end
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
            local cam = workspace.CurrentCamera
            local moveDir = Vector3.new()
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                moveDir = moveDir + cam.CFrame.LookVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                moveDir = moveDir - cam.CFrame.LookVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                moveDir = moveDir - cam.CFrame.RightVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                moveDir = moveDir + cam.CFrame.RightVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                moveDir = moveDir + Vector3.new(0,1,0)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                moveDir = moveDir - Vector3.new(0,1,0)
            end

            if moveDir.Magnitude > 0 then
                hrp.CFrame = hrp.CFrame + (moveDir.Unit * Fly_Speed * dt)
            end
        end
    end)
end

local function Fly_Disable()
    if not Fly_Enabled then
        return
    end
    Fly_Enabled = false
    if Fly_Connection then
        Fly_Connection:Disconnect()
        Fly_Connection = nil
    end
end


--========================== Admin Check (Nowy - z Twojego kodu) ========================--
local AdminCheck_Enabled = false -- Domyślnie wyłączony
local AdminCheck_Connection = nil

-- Usługi (zakładamy, że Players, ReplicatedStorage, LocalPlayer są już zdefiniowane globalnie)
-- Jeśli nie, odkomentuj poniższe lub dostosuj:
-- local Players = game:GetService("Players")
-- local ReplicatedStorage = game:GetService("ReplicatedStorage")
-- local Player = Players.LocalPlayer -- Użyj globalnego LocalPlayer jeśli istnieje

-- --- Konfiguracja Staff ---
local staffPlayers = {
    groups = {
        [4165692] = { -- crimcorp
            ["Tester"] = true, ["Contributor"] = true, ["Tester+"] = true, ["Developer"] = true,
            ["Developer+"] = true, ["Community Manager"] = true, ["Manager"] = true, ["Owner"] = true
        },
        [32406137] = { -- staff thing
            ["Junior"] = true, ["Moderator"] = true, ["Senior"] = true, ["Administrator"] = true,
            ["Manager"] = true, ["Holder"] = true
        },
        [8024440] = { -- r3shape fanclub
            ["zzzz"] = true, ["reshape enjoyer"] = true, ["i heart reshape"] = true, ["reshape superfan"] = true
        },
        [14927228] = { -- War Room
            ["♞"] = true
        }
        -- Pamiętaj, aby poprawnie zamknąć tabelę groups, jeśli dodajesz więcej
    }, -- Zamknięcie groups
    users = { -- Lista UserID
         3294804378, 93676120, 54087314, 81275825, 140837601, 1229486091, 46567801, 418086275, 29706395,
         3717066084, 1424338327, 5046662686, 5046661126, 5046659439, 418199326, 1024216621, 1810535041,
         63238912, 111250044, 63315426, 730176906, 141193516, 194512073, 193945439, 412741116, 195538733,
         102045519, 955294, 957835150, 25689921, 366613818, 281593651, 455275714, 208929505, 96783330,
         156152502, 93281166, 959606619, 142821118, 632886139, 175931803, 122209625, 278097946, 142989311,
         1517131734, 446849296, 87189764, 67180844, 9212846, 47352513, 48058122, 155413858, 10497435,
         513615792, 55893752, 55476024, 151691292, 136584758, 16983447, 3111449, 94693025, 271400893,
         5005262660, 295331237, 64489098, 244844600, 114332275, 25048901, 69262878, 50801509, 92504899,
         42066711, 50585425, 31365111, 166406495, 2457253857, 29761878, 21831137, 948293345, 439942262,
         38578487, 1163048, 7713309208, 3659305297, 15598614, 34616594, 626833004, 198610386, 153835477,
         3923114296, 3937697838, 102146039, 119861460, 371665775, 1206543842, 93428604, 1863173316, 90814576,
         374665997, 423005063, 140172831, 42662179, 9066859, 438805620, 14855669, 727189337, 1871290386,
         608073286
         -- Pamiętaj, aby poprawnie zamknąć tabelę users, jeśli dodajesz więcej
    } -- Zamknięcie users
} -- Zamknięcie staffPlayers
-- --- Koniec Konfiguracji Staff ---

-- Funkcje pomocnicze z Twojego kodu
local function hasTracker(player)
    if not player or not player:IsA("Player") then return false, nil end
    -- Bezpieczniejsze iterowanie po dzieciach
    local children = player:GetChildren()
    for i = 1, #children do
        local child = children[i]
        -- Sprawdź, czy nazwa jest stringiem i czy zawiera "Tracker" na końcu
        if typeof(child.Name) == "string" and string.sub(child.Name, -8) == "Tracker$" then
            local trackedPlayerName = string.sub(child.Name, 1, -9) -- Usuń "Tracker$"
             if Players:FindFirstChild(trackedPlayerName) then
                return true, trackedPlayerName
            end
        end
    end
    return false, nil
end

local function isStaff(player)
    if not player or not player:IsA("Player") then return false end

    -- Sprawdzanie grup
    if staffPlayers.groups then
        for groupID, roles in pairs(staffPlayers.groups) do
            -- Bezpieczne wywołanie GetRankInGroup
            local successRank, rank = pcall(function() return player:GetRankInGroup(groupID) end)
            if successRank and rank and rank > 0 then
                -- Bezpieczne wywołanie GetRoleInGroup
                local successRole, roleName = pcall(function() return player:GetRoleInGroup(groupID) end)
                if successRole and roleName and roles[roleName] then
                    return true, roleName, groupID
                end
            end
        end
    end

    -- Sprawdzanie UserID
    if staffPlayers.users then
        for i = 1, #staffPlayers.users do
            if player.UserId == staffPlayers.users[i] then
                return true, "UserID", player.UserId -- Zwróć UserID jako groupID dla spójności
            end
        end
    end

    return false
end

local function kickformat(staffInfo)
    if not staffInfo or not staffInfo.Staff then return "Staff detected." end -- Domyślna wiadomość
    local message = "Staff detected:\n"
    for i, staff in ipairs(staffInfo.Staff) do
        local idType = "Role"
        local idValue = staff.Role or "Unknown"
        if staff.Role == "UserID" then
            idType = "UserID"
            idValue = staff.GroupId or "Unknown" -- W funkcji isStaff, UserID jest teraz w GroupId
        elseif staff.Role == "Tracker User" then
             idType = "Tracker"
             idValue = "Active"
        end

        message = message .. string.format(
            "- %s (%s: %s)%s",
            staff.Name or "Unknown",
            idType,
            idValue,
            staff.TrackedPlayer and " - Tracking: " .. staff.TrackedPlayer or ""
        )
        if i < #staffInfo.Staff then
            message = message .. "\n"
        end
    end
    return message
end

local function kickWithStaffInfo(staffInfo)
    local kickMsg = kickformat(staffInfo)
    -- Użyj globalnego LocalPlayer zamiast lokalnego 'Player' z Twojego kodu
    if LocalPlayer then
        LocalPlayer:Kick("Staff joined\n\n" .. kickMsg)
    end
end

local function checkCurrentStaff()
    local staffFound = {}
    local currentPlayers = Players:GetPlayers()
    for i = 1, #currentPlayers do
        local player = currentPlayers[i]
        if player ~= LocalPlayer then -- Nie sprawdzaj siebie
            local isPlayerStaff, role, groupID = isStaff(player)
            local hasTrackers, trackedPlayer = hasTracker(player)

            if isPlayerStaff or hasTrackers then
                table.insert(staffFound, {
                    Name = player.Name,
                    Role = hasTrackers and "Tracker User" or role,
                    GroupId = groupID,
                    TrackedPlayer = trackedPlayer
                })
            end
        end
    end

    if #staffFound > 0 then
        kickWithStaffInfo({Staff = staffFound})
        return true -- Znaleziono staff
    end
    return false -- Nie znaleziono staffu
end

-- Zmieniona nazwa funkcji i dodane sprawdzenie flagi
local function onPlayerJoining(player)
     if not AdminCheck_Enabled then return end -- Sprawdź czy funkcja jest włączona

     local isPlayerStaff, role, groupID = isStaff(player)
     local hasTrackers, trackedPlayer = hasTracker(player)

     if isPlayerStaff or hasTrackers then
         local staffInfo = {
             Staff = {{
                 Name = player.Name,
                 Role = hasTrackers and "Tracker User" or role,
                 GroupId = groupID,
                 TrackedPlayer = trackedPlayer
             }}
         }
         kickWithStaffInfo(staffInfo)
     end
end

-- --- Funkcje Enable/Disable dla UI ---
local function AdminCheck_Enable()
    if AdminCheck_Enabled then return end
    AdminCheck_Enabled = true -- Natychmiast ustaw flagę na true

    -- === Aktualizacja UI powinna nastąpić tutaj ===
    -- Zakładając, że Twoja funkcja createToggleRowFrame aktualizuje przycisk
    -- po zmianie flagi AdminCheck_Enabled (np. przez kliknięcie),
    -- przycisk powinien od razu pokazać stan "ON".
    -- Jeśli nie, musiałbyś dodać tutaj kod ręcznie aktualizujący przycisk.

    print("Admin Check v2.1 Enabling...")

    -- Rozłącz stare połączenie jeśli istnieje
    if AdminCheck_Connection then AdminCheck_Connection:Disconnect() end

    -- Podłącz listener PlayerAdded (to jest szybkie)
    AdminCheck_Connection = Players.PlayerAdded:Connect(onPlayerJoining)
    print("Admin Check 2.1 Monitoring started.")

    -- Wyślij powiadomienie (to też jest szybkie)
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Staff Detection", Text = "Monitoring active", Duration = 5,
            Icon = "rbxassetid://121588751997553" -- << ID Obrazka
        })
    end)

    -- === Uruchom sprawdzanie obecnych graczy W TLE ===
    task.spawn(function()
        print("Admin Check: Running initial check on current players in background...")
        local foundStaff = checkCurrentStaff() -- Ta funkcja może zająć chwilę

        if foundStaff then
            -- Jeśli znaleziono staff, gracz został już wyrzucony przez checkCurrentStaff().
            -- Funkcja checkCurrentStaff sama w sobie wywołuje kick.
            -- Możemy opcjonalnie zaktualizować stan z powrotem, chociaż gracz jest już wyrzucany.
            AdminCheck_Enabled = false
            warn("Admin Check: Staff found by background check. Kicked.")
            -- Można by tu dodać aktualizację przycisku UI z powrotem na OFF, ale to bezcelowe przy kicku.
            if AdminCheck_Connection then -- Rozłącz listener, bo nie jest już potrzebny
                 AdminCheck_Connection:Disconnect()
                 AdminCheck_Connection = nil
            end
        else
             print("Admin Check: Initial background check complete, no staff found.")
        end
    end)
    -- Funkcja AdminCheck_Enable kończy się tutaj natychmiast, nie czekając na checkCurrentStaff.
end

local function AdminCheck_Disable()
    if not AdminCheck_Enabled then return end
    AdminCheck_Enabled = false

    if AdminCheck_Connection then
        AdminCheck_Connection:Disconnect()
        AdminCheck_Connection = nil
    end
    print("Admin Check 2.1 Disabled.")
end

-- Opcjonalne uruchomienie domyślne (jeśli chcesz, aby startował włączony)
-- if true then -- Zmień na true, jeśli ma być domyślnie włączony
--    AdminCheck_Enable()
-- end


-- AntiAFK - teraz z możliwością bindowania stanu przycisku
local AntiAFK_Enabled_Dummy = true
local AntiAFK_Bind = nil -- Dodajemy zmienną na bind
local function AntiAFK_Enable()
    AntiAFK_Enabled_Dummy = true
end
local function AntiAFK_Disable()
    AntiAFK_Enabled_Dummy = false
end


--=================== Melee Aura 4 Alt MAX! (Poprawiona Logika Zgodnie z Błędem) =====================--
local MeleeAura_Enabled = false
local MeleeAura_Connection

local runAttackLoop do
    local plrs = game:GetService("Players")
    local me = plrs.LocalPlayer
    local run = game:GetService("RunService")
    local replicatedStorage = game:GetService("ReplicatedStorage")
    local eventsFolder = replicatedStorage:WaitForChild("Events")

    -- === POPRAWKA ===
    -- Zakładamy, że remote1 odnosi się do RemoteFunction (np. "XMHH.2" jak w komentarzu)
    -- a remote2 odnosi się do RemoteEvent ("XMHH2.2").
    -- Jeśli nazwy są inne w Twojej grze, zaktualizuj je poniżej.
    local remoteFunctionPath = "XMHH.2" -- Nazwa RemoteFunction (do InvokeServer)
    local remoteEventPath = "XMHH2.2" -- Nazwa RemoteEvent (do FireServer)

    local remote1 = eventsFolder:WaitForChild(remoteFunctionPath) -- Powinien być RemoteFunction
    local remote2 = eventsFolder:WaitForChild(remoteEventPath)    -- Powinien być RemoteEvent
    -- === KONIEC POPRAWKI ===

    local maxdist = 20

    local function Attack(target)
        -- Sprawdzenie celu jak w oryginale
        if not (target and target:FindFirstChild("Head")) then return end

        local char = me.Character
        local tool = char and char:FindFirstChildOfClass("Tool")
        local hrp = char and char:FindFirstChild("HumanoidRootPart")

        -- Sprawdzenie, czy oba remotes istnieją i są poprawnego typu
        if not remote1 or not remote1:IsA("RemoteFunction") then
            warn("MeleeAura Error: Cannot find required RemoteFunction at: ReplicatedStorage.Events." .. remoteFunctionPath .. " or it's not a RemoteFunction.")
            MeleeAura_Disable() -- Wyłącz, bo nie zadziała
            return
        end
        if not remote2 or not remote2:IsA("RemoteEvent") then
            warn("MeleeAura Error: Cannot find required RemoteEvent at: ReplicatedStorage.Events." .. remoteEventPath .. " or it's not a RemoteEvent.")
            MeleeAura_Disable() -- Wyłącz, bo nie zadziała
            return
        end

        -- === POPRAWKA: Użycie pcall dla bezpieczeństwa wywołań zdalnych ===
        -- Wywołanie InvokeServer na RemoteFunction (remote1)
        local arg1 = {
            [1] = "🍞",
            [2] = tick(),
            [3] = tool,
            [4] = "43TRFWX",
            [5] = "Normal",
            [6] = tick(),
            [7] = true
        }
        local success1, result = pcall(function()
            return remote1:InvokeServer(unpack(arg1))
        end)

        if not success1 then
            warn("MeleeAura Error: InvokeServer on " .. remoteFunctionPath .. " failed:", result)
            -- Można rozważyć MeleeAura_Disable() tutaj, jeśli błąd jest krytyczny
            return -- Przerwij atak, jeśli pierwsze wywołanie się nie powiodło
        end
        -- Jeśli sukces, 'result' zawiera zwróconą wartość

        task.wait(0.1) -- Opóźnienie z oryginału

        -- Sprawdzenie Handle i Head jak w oryginale
        local Handle = tool and (tool:FindFirstChild("WeaponHandle") or tool:FindFirstChild("Handle")) or (char and char:FindFirstChild("Right Arm"))
        local head = target:FindFirstChild("Head")

        if Handle and head and hrp then -- Dodano sprawdzenie hrp dla pozycji
            -- Wywołanie FireServer na RemoteEvent (remote2), używając 'result' z InvokeServer
            local arg2 = {
                [1] = "🍞",
                [2] = tick(),
                [3] = tool,
                [4] = "2389ZFX34",
                [5] = result, -- Użycie wyniku z InvokeServer
                [6] = false,
                [7] = Handle,
                [8] = head,
                [9] = target,
                [10] = hrp.Position, -- Użyj pozycji hrp
                [11] = head.Position
            }
            local success2, errorMsg2 = pcall(function()
                remote2:FireServer(unpack(arg2))
            end)
            if not success2 then
                warn("MeleeAura Error: FireServer on " .. remoteEventPath .. " failed:", errorMsg2)
            end
            -- === KONIEC POPRAWKI pcall ===
        end
    end

    runAttackLoop = function()
        return run.RenderStepped:Connect(function()
            if not MeleeAura_Enabled then return end -- Sprawdź flagę
            local char = me.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if hrp then -- Upewnij się, że gracz ma HRP
                for _, plr in ipairs(plrs:GetPlayers()) do
                    if plr ~= me then
                        local c = plr.Character
                        local hrp2 = c and c:FindFirstChild("HumanoidRootPart")
                        local hum = c and c:FindFirstChildOfClass("Humanoid")
                        -- Nie potrzebujemy sprawdzać głowy tutaj, bo Attack() to robi
                        if hrp2 and hum then
                            local dist = (hrp.Position - hrp2.Position).Magnitude
                            -- Sprawdzenia z oryginału
                            if dist < maxdist and hum.Health > 15 and not c:FindFirstChildOfClass("ForceField") then
                                Attack(c)
                            end
                        end
                    end
                end
            end
        end)
    end
end

local function MeleeAura_Enable()
    if MeleeAura_Enabled then return end
    MeleeAura_Enabled = true
    -- Rozłącz stare połączenie, jeśli istnieje, aby uniknąć wycieków
    if MeleeAura_Connection and MeleeAura_Connection.Connected then
        MeleeAura_Connection:Disconnect()
    end
    MeleeAura_Connection = runAttackLoop()
end

local function MeleeAura_Disable()
    if not MeleeAura_Enabled then return end
    MeleeAura_Enabled = false
    if MeleeAura_Connection and MeleeAura_Connection.Connected then -- Rozłącz, jeśli istnieje i jest połączone
        MeleeAura_Connection:Disconnect()
        MeleeAura_Connection = nil
    end
    -- Dodatkowo, zaktualizuj przycisk UI, jeśli jest powiązany
    -- (zakładając, że masz mechanizm aktualizacji przycisków)
    for key, bindData in pairs(activeBinds) do
        if bindData.onEnable == MeleeAura_Enable then
             if bindData.updateFn then
                 pcall(bindData.updateFn) -- Wywołaj funkcję aktualizacji przycisku
             end
             break -- Znaleziono, można przerwać
        end
    end
end
--======================= Teleport Farm =========================--
local TPFarm_Enabled = false
local TPFarm_TargetName = "Type ALT account name.."
local TPFarm_SteppedConnection = nil
local TPFarm_RenderConnection = nil
local TPFarm_CharConnection = nil
local DeathRespawn_Event = game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("DeathRespawn")

-- Локальная функция, вызываемая при спавне персонажа (CharacterAdded) (Oryginalny komentarz)
local function TPFarm_OnCharacterAdded(char)
    if TPFarm_SteppedConnection then
        TPFarm_SteppedConnection:Disconnect()
        TPFarm_SteppedConnection=nil
    end
    task.wait(0.4)
    local hrp=char:FindFirstChild("HumanoidRootPart")
    local hum=char:FindFirstChildOfClass("Humanoid")
    if not (hrp and hum) then
        return
    end
    TPFarm_SteppedConnection=RunService.Stepped:Connect(function()
        if not TPFarm_Enabled then
            return
        end
        local mainPlayer=Players:FindFirstChild(TPFarm_TargetName)
        local mainChar=mainPlayer and mainPlayer.Character
        local mainHRP=mainChar and mainChar:FindFirstChild("HumanoidRootPart")
        if mainHRP then
            hrp.CFrame=mainHRP.CFrame+(mainHRP.CFrame.LookVector*3)
            -- Oryginalna logika resetu HP (potencjalny memory leak)
            hum:GetPropertyChangedSignal("Health"):Connect(function()
                hum.Health=0
            end)
        end
    end)
end

local function TPFarm_Enable()
    if TPFarm_Enabled then
        return
    end
    TPFarm_Enabled=true
    local killpart=workspace.Filter.Parts:FindFirstChild("Kill_Brick")
    if killpart then
        killpart:Destroy()
    end
    local me=LocalPlayer
    if me.Character then
        TPFarm_OnCharacterAdded(me.Character)
    end
    TPFarm_CharConnection=me.CharacterAdded:Connect(function(newChar)
        if not TPFarm_Enabled then
            return
        end
        TPFarm_OnCharacterAdded(newChar)
        local tool=me.Backpack:FindFirstChildOfClass("Tool")
        if tool and newChar then
            tool.Parent=newChar
        end
    end)
    TPFarm_RenderConnection=RunService.RenderStepped:Connect(function()
        if not TPFarm_Enabled then
            return
        end
        local char=me.Character
        if char then
            local humanoid=char:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health<=0 then
                DeathRespawn_Event:InvokeServer("KMG4R904")
            end
        end
    end)
end

local function TPFarm_Disable()
    if not TPFarm_Enabled then
        return
    end
    TPFarm_Enabled=false
    if TPFarm_SteppedConnection then
        TPFarm_SteppedConnection:Disconnect()
        TPFarm_SteppedConnection=nil
    end
    if TPFarm_RenderConnection then
        TPFarm_RenderConnection:Disconnect()
        TPFarm_RenderConnection=nil
    end
    if TPFarm_CharConnection then
        TPFarm_CharConnection:Disconnect()
        TPFarm_CharConnection=nil
    end
end


--======================= ANTI-FLING =========================--
local run_af = RunService
local plrs_af = Players
local me_af = LocalPlayer
local work = true
wait(1)

-- Główna pętla Anti-Fling z oryginału (działa zawsze)
run_af.RenderStepped:Connect(function()
    local char=me_af.Character
    if not char then return end
    local hrp=char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local oldVelocity=hrp.Velocity
    for _, part in pairs(char:GetChildren()) do
        if part:IsA("BasePart") then
            part.CanTouch=false
            if part.Velocity.Magnitude>oldVelocity.Magnitude*3 then
                part.Velocity=Vector3.zero
            end
        end
    end
    for _, player in pairs(plrs_af:GetPlayers()) do
        if player~=me_af then
            local plrChar=player.Character
            if plrChar then
                for _, part in pairs(plrChar:GetChildren()) do
                    if part:IsA("BasePart") then
                        if part.Velocity.Magnitude>oldVelocity.Magnitude*3 then
                            part.Velocity=Vector3.zero
                            part.CanTouch=false
                        end
                    end
                end
            end
        end
    end
end)

-- Funkcje dla przycisku UI (kontrolują drugą, nadmiarową pętlę z oryginału)
local AntiFling_Enabled=false
local AntiFling_Connection=nil

local function AntiFling_Enable()
    if AntiFling_Enabled then return end
    AntiFling_Enabled=true
    if not AntiFling_Connection then
        -- Ta pętla była duplikatem w oryginale
        AntiFling_Connection=run_af.RenderStepped:Connect(function()
            local char=me_af.Character
            if not char then return end
            local hrp=char and char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            local oldVelocity_inner=hrp.Velocity
            for _, part in pairs(char:GetChildren()) do
                if part:IsA("BasePart") then
                    part.CanTouch=false
                    if part.Velocity.Magnitude>oldVelocity_inner.Magnitude*3 then
                        part.Velocity=Vector3.zero
                    end
                end
            end
            for _, player in pairs(plrs_af:GetPlayers()) do
                if player~=me_af then
                    local plrChar=player.Character
                    if plrChar then
                        for _, part in pairs(plrChar:GetChildren()) do
                            if part:IsA("BasePart") then
                                if part.Velocity.Magnitude>oldVelocity_inner.Magnitude*3 then
                                    part.Velocity=Vector3.zero
                                    part.CanTouch=false
                                end
                            end
                        end
                    end
                end
            end
        end)
    end
end

local function AntiFling_Disable()
    if not AntiFling_Enabled then return end
    AntiFling_Enabled=false
    if AntiFling_Connection then
        AntiFling_Connection:Disconnect()
        AntiFling_Connection=nil
    end
end

--======================= RAGEBOT (Oryginalna struktura z poprawionymi argumentami) =======================--
-- UWAGA: Działanie zależy od istnienia RemoteEvents:
-- ReplicatedStorage.Events.GNX_S
-- ReplicatedStorage.Events.ZFKLF__H <-- Zmieniono na podwójne podkreślenie

local ReplicatedStorage = game:GetService("ReplicatedStorage") -- Użyj globalnego ReplicatedStorage jeśli istnieje
local EventsFolder = ReplicatedStorage:WaitForChild("Events", 10) -- Dłuższy timeout dla pewności

local GNX_S_Remote = EventsFolder and EventsFolder:WaitForChild("GNX_S", 5)
-- ZMIANA 1: Nazwa drugiego RemoteEvent zaktualizowana do tej z nowego skryptu
local ZFKLF_H_Remote = EventsFolder and EventsFolder:WaitForChild("ZFKLF__H", 5)

-- Funkcja pomocnicza z oryginalnego bloku
local function RandomString(length)
    local res = ""
    for i = 1, length do
        res = res .. string.char(math.random(97, 122))
    end
    return res
end

-- Funkcja GetClosestEnemy z oryginalnego bloku (bez zmian)
local function GetClosestEnemy_Rage()
    local closestEnemy = nil
    local shortestDistance = 200 -- Oryginalny zasięg z tego bloku

    local myChar = LocalPlayer.Character -- Użyj globalnego LocalPlayer
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end

    for _, player in ipairs(Players:GetPlayers()) do -- Użyj globalnego Players
        if player ~= LocalPlayer then
            local enemyChar = player.Character
            local enemyHRP = enemyChar and enemyChar:FindFirstChild("HumanoidRootPart")
            local enemyHum = enemyChar and enemyChar:FindFirstChildOfClass("Humanoid")

            if enemyHRP and enemyHum and enemyHum.Health > 15 and not enemyChar:FindFirstChildOfClass("ForceField") then
                local distance = (myHRP.Position - enemyHRP.Position).Magnitude
                if distance < shortestDistance then
                    -- WallCheck był opcjonalny w tym bloku, pozostawiamy go bez zmian (domyślnie wyłączony/brak)
                    shortestDistance = distance
                    closestEnemy = player
                end
            end
        end
    end
    return closestEnemy
end

-- Funkcja Shoot z oryginalnego bloku (ZE ZMIENIONYM ARGUMENTEM)
local function Shoot_Rage(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return end

    local targetPart = targetPlayer.Character:FindFirstChild("Head") or targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetPart then return end

    local myChar = LocalPlayer.Character
    local tool = myChar and myChar:FindFirstChildOfClass("Tool")
    -- Usunięto sprawdzanie 'IsGun' z oryginalnego bloku, bo było zakomentowane
    if not tool then
        return
    end

    local currentCam = workspace.CurrentCamera
    local hitPosition = targetPart.Position
    local hitDirection = (hitPosition - currentCam.CFrame.Position).Unit
    local randomKey = RandomString(30) .. "0"

    if not GNX_S_Remote or not ZFKLF_H_Remote then
        warn("Ragebot Error: Required remote events not found.")
        -- W oryginalnym bloku była tu funkcja Ragebot_Disable(), zachowujemy ją
        if typeof(Ragebot_Disable) == "function" then
            Ragebot_Disable()
        end
        return
    end

    -- Wywołanie GNX_S (bez zmian w argumentach względem oryginału tego bloku)
    local success1, err1 = pcall(function()
        GNX_S_Remote:FireServer( -- Usunięto self jako pierwszy argument, bo pcall go nie wymaga
            tick(),
            randomKey,
            tool,
            "FDS9I83", -- Statyczny string z tego bloku
            currentCam.CFrame.Position,
            {hitDirection},
            false
        )
    end)
    if not success1 then warn("Ragebot: FireServer GNX_S failed:", err1) end

    -- Wywołanie ZFKLF__H (ZE ZMIENIONYM ARGUMENTEM)
    local success2, err2 = pcall(function()
        ZFKLF_H_Remote:FireServer( -- Usunięto self
            -- ZMIANA 2: Pierwszy argument zmieniony na ten z nowego skryptu
            "🧈",
            -- Reszta argumentów jak w oryginalnym bloku (które pasują do nowego)
            tool,
            randomKey,
            1, -- Liczba trafień
            targetPart,
            hitPosition,
            hitDirection,
            nil, -- Material (był nil w oryginale)
            nil  -- Normal (był nil w oryginale)
        )
    end)
    if not success2 then warn("Ragebot: FireServer ZFKLF__H failed:", err2) end
end

-- Pętla i funkcje Enable/Disable z oryginalnego bloku (bez zmian)
local Ragebot_Enabled = false -- Zmienna stanu z oryginalnego bloku
local Ragebot_Coroutine = nil -- Zmienna coroutine z oryginalnego bloku
local Ragebot_Target = nil -- Zmienna celu z oryginalnego bloku

local function RagebotLoop()
    while Ragebot_Enabled do
        local target = GetClosestEnemy_Rage()
        Ragebot_Target = target
        if target then
            Shoot_Rage(target)
            task.wait(0.05) -- Oryginalne opóźnienie z tego bloku
        else
            task.wait(0.1) -- Oryginalne opóźnienie z tego bloku
        end
    end
    Ragebot_Target = nil
    Ragebot_Coroutine = nil
end

local function Ragebot_Enable()
    -- Sprawdzenie remote'ów z oryginalnego bloku
    if not GNX_S_Remote or not ZFKLF_H_Remote then
         warn("Ragebot cannot enable: Required remote events not found.")
         pcall(function() game:GetService("StarterGui"):SetCore("SendNotification", { Title = "Ragebot Error", Text = "Required remotes missing.", Duration = 5}) end)
         -- Aktualizacja UI z oryginalnego bloku
         for k, v in pairs(activeBinds or {}) do if v.onEnable == Ragebot_Enable then if v.updateFn then task.wait(); pcall(v.updateFn) end; break; end end
         return
    end
    -- Reszta logiki Enable z oryginalnego bloku
    if Ragebot_Enabled then return end
    Ragebot_Enabled = true
    if not Ragebot_Coroutine then
        Ragebot_Coroutine = coroutine.create(RagebotLoop)
        coroutine.resume(Ragebot_Coroutine)
    end
end

local function Ragebot_Disable()
    -- Logika Disable z oryginalnego bloku
    if not Ragebot_Enabled then return end
    Ragebot_Enabled = false
end

-------------------------------------------------------------------------------
--======================= AIMBOT (Logika Oryginalna + Poprawka Błędu Nil) =========================--
local players_aim = Players
local localPlayer_aim = LocalPlayer
local CurrentCamera_aim = workspace.CurrentCamera
local TweenService_aim = TweenService
local UserInputService_aim = UserInputService
local mouseLocation_aim = UserInputService_aim.GetMouseLocation
local RunService_aim = RunService

-- WAŻNE: Definicja AimBotSettings MUSI być PRZED funkcjami, które jej używają.
local AimBotSettings = {
    Enabled = false; TeamCheck = false; WallCheck = true; StickyAim = false;
    UseMouse = true; MouseBind = "MouseButton2"; Keybind = nil; -- Usunięto domyślny bind 'E'
    ShowFov = false; Fov = 100;
    Smoothing = 0.02; AimPart = "HumanoidRootPart";
    IsAimKeyDown = false; Target = nil; CameraTween = nil;
}

-- Definicje funkcji pomocniczych (zgodne z logiką oryginału i poprawkami)
local function IsAlive_aim(Player)
    -- Dodano sprawdzenie czy Player.Character istnieje przed dostępem do Humanoid
    return Player and Player.Character and Player.Character:FindFirstChildOfClass("Humanoid") and Player.Character.Humanoid.Health > 0
end

local function GetTeam_aim(Player)
    -- Dodano sprawdzenie Player.Team przed dostępem do Name
    if not localPlayer_aim.Neutral and Player and Player.Team and game:GetService("Teams"):FindFirstChild(Player.Team.Name) then
        return game:GetService("Teams")[Player.Team.Name];
    end
    return nil;
end

-- Poprawiona funkcja isVisible_aim (przyjmuje pozycję, nie instancję)
local function isVisible_aim(targetPosition, character)
    -- Sprawdzenie czy WallCheck jest włączony musi odwoływać się do tabeli AimBotSettings
    if not AimBotSettings.WallCheck then
        return true;
    end

    -- Upewnij się, że localPlayer_aim.Character istnieje
    local ignoreList = {CurrentCamera_aim}
    if localPlayer_aim.Character then
         table.insert(ignoreList, localPlayer_aim.Character)
    end
    -- Upewnij się, że character i jego Head istnieją
    if character and character:FindFirstChild("Head") and character.Head.Parent then
        table.insert(ignoreList, character.Head.Parent)
    end

    -- Użyj pcall dla bezpieczeństwa przy GetPartsObscuringTarget
    local success, obscured = pcall(function()
        return CurrentCamera_aim:GetPartsObscuringTarget({targetPosition}, ignoreList)
    end)

    -- Jeśli pcall się nie powiódł lub zwrócił nil, załóż, że jest zasłonięty (bezpieczniej)
    if not success or obscured == nil then
        return false
    end
    return #obscured == 0;
end

-- Poprawiona funkcja CameraGetClosestToMouse_aim (przekazuje pozycję do isVisible_aim)
local function CameraGetClosestToMouse_aim()
    -- Odwołanie do Fov musi używać tabeli AimBotSettings
    local AimFov = AimBotSettings.Fov;
    local targetPlayer = nil;

    for i, v in pairs(players_aim:GetPlayers()) do
        if v ~= localPlayer_aim then
            -- Odwołanie do TeamCheck musi używać tabeli AimBotSettings
            if AimBotSettings.TeamCheck ~= true or GetTeam_aim(v) ~= GetTeam_aim(localPlayer_aim) then
                if IsAlive_aim(v) then
                    local char = v.Character
                    -- Odwołanie do AimPart musi używać tabeli AimBotSettings
                    local aimPartInstance = char and char:FindFirstChild(AimBotSettings.AimPart)
                    if aimPartInstance then
                        local aimPartPosition = aimPartInstance.Position
                        -- Bezpieczne wywołanie WorldToViewportPoint
                        local successWTV, screen_pos, on_screen = pcall(function() return CurrentCamera_aim:WorldToViewportPoint(aimPartPosition) end)
                        if successWTV and on_screen then
                             local screen_pos_2D = Vector2.new(screen_pos.X, screen_pos.Y)
                             local successMouseLoc, mousePos = pcall(mouseLocation_aim, UserInputService_aim)
                             if not successMouseLoc then mousePos = Vector2.new() end -- Domyślna pozycja myszy w razie błędu
                             local new_magnitude = (screen_pos_2D - mousePos).Magnitude
                             -- Przekaż pozycję i postać do isVisible_aim
                             if new_magnitude < AimFov and isVisible_aim(aimPartPosition, char) then
                                AimFov = new_magnitude;
                                targetPlayer = v;
                             end
                        end
                    end
                end
            end
        end
    end
    return targetPlayer;
end

-- Listener InputBegan (zgodny z logiką oryginału + sprawdzenie AimBotSettings)
UserInputService_aim.InputBegan:Connect(function(input, gameProcessedEvent)
    -- Sprawdź czy AimBotSettings istnieje PRZED próbą dostępu do Enabled
    if not AimBotSettings then return end
    if gameProcessedEvent or not AimBotSettings.Enabled then return end

    if not AimBotSettings.UseMouse and AimBotSettings.Keybind and input.KeyCode == AimBotSettings.Keybind then
        AimBotSettings.Target = CameraGetClosestToMouse_aim();
        AimBotSettings.IsAimKeyDown = true;
    elseif AimBotSettings.UseMouse then
        local bind = ""
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            bind = "MouseButton1"
        elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
            bind = "MouseButton2"
        end

        if bind == AimBotSettings.MouseBind then
            AimBotSettings.Target = CameraGetClosestToMouse_aim();
            AimBotSettings.IsAimKeyDown = true;
        end
    end
end)

-- Listener InputEnded (zgodny z logiką oryginału + sprawdzenie AimBotSettings)
UserInputService_aim.InputEnded:Connect(function(input, gameProcessedEvent)
     -- Sprawdź czy AimBotSettings istnieje PRZED próbą dostępu do Enabled
    if not AimBotSettings then return end
    if gameProcessedEvent or not AimBotSettings.Enabled then return end

    if not AimBotSettings.UseMouse and AimBotSettings.Keybind and input.KeyCode == AimBotSettings.Keybind then
        AimBotSettings.IsAimKeyDown = false;
        AimBotSettings.Target = nil;
        if AimBotSettings.CameraTween then
            AimBotSettings.CameraTween:Cancel();
            AimBotSettings.CameraTween = nil;
        end
    elseif AimBotSettings.UseMouse then
        local bind = ""
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            bind = "MouseButton1"
        elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
            bind = "MouseButton2"
        end

        if bind == AimBotSettings.MouseBind then
            AimBotSettings.IsAimKeyDown = false;
            AimBotSettings.Target = nil;
            if AimBotSettings.CameraTween then
                AimBotSettings.CameraTween:Cancel();
                AimBotSettings.CameraTween = nil;
            end
        end
    end
end)

-- Listener Heartbeat (zgodny z logiką oryginału + sprawdzenie AimBotSettings)
RunService_aim.Heartbeat:Connect(function(deltaTime)
    -- === TUTAJ JEST LINIA POWODUJĄCA BŁĄD ===
    -- Sprawdź czy AimBotSettings istnieje PRZED próbą dostępu do Enabled
    if AimBotSettings and AimBotSettings.Enabled then
        if AimBotSettings.IsAimKeyDown then
            local currentTarget = AimBotSettings.Target

            if AimBotSettings.StickyAim then
                 if currentTarget ~= nil and IsAlive_aim(currentTarget) then
                    local targetChar = currentTarget.Character
                    local aimPart = targetChar and targetChar:FindFirstChild(AimBotSettings.AimPart)
                    if aimPart then
                        if AimBotSettings.CameraTween then AimBotSettings.CameraTween:Cancel(); AimBotSettings.CameraTween = nil; end
                        -- Bezpieczniejsza predykcja pinga
                        local networkPing = 0
                        local successPing, resultPing = pcall(function() return localPlayer_aim:GetNetworkPing() end)
                        if successPing then networkPing = resultPing end
                        local predictionOffset = aimPart.Velocity and aimPart.Velocity * (networkPing * 0.1) or Vector3.new() -- Użyj 0.1 jako mnożnik zamiast Vector3.zero
                        local targetCFrame = CFrame.new(CurrentCamera_aim.CFrame.Position, aimPart.Position + predictionOffset)

                        -- Użyj pcall dla bezpieczeństwa tworzenia tweena
                        local successTween, tweenResult = pcall(function()
                            AimBotSettings.CameraTween = TweenService_aim:Create(CurrentCamera_aim, TweenInfo.new(AimBotSettings.Smoothing, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = targetCFrame});
                            AimBotSettings.CameraTween:Play();
                        end)
                        if not successTween then warn("Aimbot Tween creation failed:", tweenResult) end

                    else
                        AimBotSettings.Target = nil
                        if AimBotSettings.CameraTween then AimBotSettings.CameraTween:Cancel(); AimBotSettings.CameraTween = nil; end
                    end
                 else
                    local newTarget = CameraGetClosestToMouse_aim()
                    AimBotSettings.Target = newTarget
                    currentTarget = newTarget

                    if currentTarget and IsAlive_aim(currentTarget) then
                        local targetChar = currentTarget.Character
                        local aimPart = targetChar and targetChar:FindFirstChild(AimBotSettings.AimPart)
                        if aimPart then
                            if AimBotSettings.CameraTween then AimBotSettings.CameraTween:Cancel(); AimBotSettings.CameraTween = nil; end
                             local networkPing = 0; local sP, rP=pcall(function() return localPlayer_aim:GetNetworkPing() end); if sP then networkPing=rP end
                             local predictionOffset = aimPart.Velocity and aimPart.Velocity * (networkPing * 0.1) or Vector3.new()
                             local targetCFrame = CFrame.new(CurrentCamera_aim.CFrame.Position, aimPart.Position + predictionOffset)

                             local sT, tR = pcall(function()
                                AimBotSettings.CameraTween = TweenService_aim:Create(CurrentCamera_aim, TweenInfo.new(AimBotSettings.Smoothing, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = targetCFrame});
                                AimBotSettings.CameraTween:Play();
                             end)
                             if not sT then warn("Aimbot Tween creation failed (new target):", tR) end
                        end
                    elseif AimBotSettings.CameraTween then
                         AimBotSettings.CameraTween:Cancel(); AimBotSettings.CameraTween = nil;
                    end
                 end

            else -- Nie StickyAim
                local target = CameraGetClosestToMouse_aim();
                if target ~= nil and IsAlive_aim(target) then
                    local targetChar = target.Character
                    local aimPart = targetChar and targetChar:FindFirstChild(AimBotSettings.AimPart)
                    if aimPart then
                        if AimBotSettings.CameraTween then AimBotSettings.CameraTween:Cancel(); AimBotSettings.CameraTween = nil; end
                        local networkPing = 0; local sP, rP=pcall(function() return localPlayer_aim:GetNetworkPing() end); if sP then networkPing=rP end
                        local predictionOffset = aimPart.Velocity and aimPart.Velocity * (networkPing * 0.1) or Vector3.new()
                        local targetCFrame = CFrame.new(CurrentCamera_aim.CFrame.Position, aimPart.Position + predictionOffset)

                        local sT, tR = pcall(function()
                            AimBotSettings.CameraTween = TweenService_aim:Create(CurrentCamera_aim, TweenInfo.new(AimBotSettings.Smoothing, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = targetCFrame});
                            AimBotSettings.CameraTween:Play();
                        end)
                         if not sT then warn("Aimbot Tween creation failed (non-sticky):", tR) end

                    else
                         if AimBotSettings.CameraTween then AimBotSettings.CameraTween:Cancel(); AimBotSettings.CameraTween = nil; end
                    end
                elseif AimBotSettings.CameraTween ~= nil then
                    AimBotSettings.CameraTween:Cancel();
                    AimBotSettings.CameraTween = nil;
                end
            end
        end
    -- Dodano 'else' na wypadek gdyby AimBotSettings było nil - nic nie rób
    -- elseif not AimBotSettings then
       -- Można dodać warn("AimBotSettings jest nil w Heartbeat!") dla debugowania
    end
end)

-- Funkcje Enable/Disable (pozostają takie same jak w nowym skrypcie)
local function Aimbot_Enable()
    if AimBotSettings then AimBotSettings.Enabled=true else warn("Cannot enable Aimbot: AimBotSettings is nil") end
end
local function Aimbot_Disable()
    if AimBotSettings then
        AimBotSettings.Enabled=false; AimBotSettings.IsAimKeyDown=false; AimBotSettings.Target=nil;
        if AimBotSettings.CameraTween then AimBotSettings.CameraTween:Cancel(); AimBotSettings.CameraTween=nil end
    else
         warn("Cannot disable Aimbot: AimBotSettings is nil")
    end
end

--======================= INF STAMINA (Logika Oryginalna) =========================--
-- WAŻNE: Poniższy blok kodu (od `local UserInputService_stam...` do `end)`)
--        musi zostać umieszczony w GŁÓWNYM zakresie skryptu (nie wewnątrz innej funkcji),
--        aby hook został wykonany raz podczas ładowania skryptu.

local UserInputService_stam = UserInputService -- Użyj UserInputService zdefiniowanego na górze skryptu
local isInfiniteStaminaEnabled = false -- Zmienna stanu
local oldStaminaFunction = nil -- Przechowuje oryginalną funkcję
local targetFunction = nil -- Funkcja docelowa z upvalue

do -- Używamy 'do...end' aby ograniczyć zasięg zmiennych lokalnych dla hooka
    local success_hook, result_hook = pcall(function()
        -- Spróbuj znaleźć funkcję docelową (zakładając, że ścieżka jest poprawna)
        local env = nil
        local success_env1, env1 = pcall(getrenv)
        if success_env1 then env = env1 else local success_env2, env2 = pcall(getfenv); if success_env2 then env = env2 end end

        if env and env._G and env._G.S_Take then
             local success_upval, upval = pcall(getupvalue, env._G.S_Take, 2)
             if success_upval and type(upval) == 'function' then
                 targetFunction = upval
             else
                 warn("Inf Stamina: Nie można pobrać upvalue 2 lub nie jest to funkcja.")
             end
        else
             warn("Inf Stamina: Nie znaleziono _G.S_Take.")
        end

        -- Zahacz funkcję, jeśli została znaleziona
        if targetFunction then
             local hookSuccess, hookResult = pcall(function()
                 oldStaminaFunction = hookfunction(
                     targetFunction,
                     function(v1, ...) -- Nowa funkcja zastępująca oryginalną
                         local args = {...} -- Zbieranie pozostałych argumentów
                         if isInfiniteStaminaEnabled then
                             -- Jeśli nieskończona stamina jest WŁĄCZONA, zmień ilość zabieranej staminy na 0
                             -- Wywołaj oryginalną funkcję z v1 = 0 i resztą argumentów
                             return oldStaminaFunction(0, unpack(args))
                         else
                             -- Jeśli nieskończona stamina jest WYŁĄCZONA, wywołaj oryginalną funkcję bez zmian
                             return oldStaminaFunction(v1, unpack(args))
                         end
                     end
                 )
             end)
             if not hookSuccess then
                  warn("Inf Stamina: hookfunction nie powiódł się: ", hookResult)
                  oldStaminaFunction = nil -- Upewnij się, że nie próbujemy użyć nieudanej funkcji hooka
             end
        end
    end)
    if not success_hook then
        warn("Inf Stamina: Wystąpił błąd podczas próby hookowania: ", result_hook)
    end
end -- Koniec bloku 'do' dla hooka

-- Funkcje Enable/Disable (tylko przełączają flagę, jak w oryginale)
local function InfiniteStamina_Enable()
    if not oldStaminaFunction then
        warn("Inf Stamina: Funkcja staminy nie została zahaczona. Infinite Stamina nie działa.")
        -- Można dodać próbę ponownego hookowania tutaj, jeśli chcesz zachować część logiki z nowego skryptu
        return
    end
    isInfiniteStaminaEnabled = true
end

local function InfiniteStamina_Disable()
    -- Nie trzeba sprawdzać oldStaminaFunction, bo wyłączenie jest bezpieczne nawet bez hooka
    isInfiniteStaminaEnabled = false
end

--======================= INVISIBILITY (Corrected for Reset Errors) =========================--
local Invis_Fixed = true -- Flag to indicate the corrected version is used

do -- Use a 'do' block to scope variables specific to invisibility
    repeat task.wait() until game:IsLoaded();

    local cloneref = cloneref or function(...) return ... end;

    local Service = setmetatable({}, {
        __index = function(_, k)
            return cloneref(game:GetService(k));
        end
    });

    local Player: Player = Service.Players.LocalPlayer; -- Use Service table
    local Character: Model = Player.Character or Player.CharacterAdded:Wait();
    local Humanoid: Humanoid
    local HumanoidRootPart: BasePart

    local function UpdateCharacterReferences()
        Character = Player.Character
        if Character then
            HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
            Humanoid = Character:FindFirstChildOfClass("Humanoid")
        else
            HumanoidRootPart = nil
            Humanoid = nil
        end
    end

    UpdateCharacterReferences() -- Initial call

    local InvisEnabled = false; -- Invisibility is disabled by default
    local Track = nil -- Variable to hold the AnimationTrack
    local Animation = Instance.new("Animation"); -- Create Animation instance once
    Animation.AnimationId = "rbxassetid://215384594"; -- Set AnimationId once

    local RunService: RunService = Service.RunService;
    local Heartbeat = RunService.Heartbeat;
    local RenderStepped = RunService.RenderStepped;

    local UserInputService: UserInputService = Service.UserInputService;
    local CoreGui: CoreGui = Service.CoreGui; -- Use Service table
    local StarterGui: StarterGui = Service.StarterGui; -- Use Service table

    -- Check for R6 (do this once after initial character load)
    if Character and not Character:FindFirstChild("Torso") then
        pcall(function() -- Use pcall for safety
            StarterGui:SetCore("SendNotification", {
                Title = "Invisibility FAILED",
                Text = "Feature requires R6 Avatar.",
                Duration = 5,
            });
        end)
        -- We don't 'return' here in the global scope, just prevent the feature from enabling later if needed.
        -- Or, set a flag to prevent enable/disable functions from working.
        Invis_Fixed = false -- Mark as incompatible
    end

    -- GUI for warning message
    local GUI = Instance.new("ScreenGui");
    GUI.Name = "InvisWarningGUI";
    GUI.Parent = CoreGui; -- Parent to CoreGui
    GUI.ResetOnSpawn = false;
    GUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling;

    local WarnLabel = Instance.new("TextLabel", GUI);
    WarnLabel.Text = "⚠️You are visible⚠️";
    WarnLabel.Visible = false;
    WarnLabel.Size = UDim2.new(0, 200, 0, 30); -- Fixed size
    WarnLabel.Position = UDim2.new(0.5, -100, 0.85, 0); -- Centered, slightly higher
    WarnLabel.BackgroundTransparency = 1;
    WarnLabel.Font = Enum.Font.GothamSemibold;
    WarnLabel.TextSize = 24; -- Adjusted size
    WarnLabel.TextColor3 = Color3.fromRGB(255, 255, 0); -- Yellow warning color
    WarnLabel.TextStrokeTransparency = 0.5;
    WarnLabel.ZIndex = 10; -- Ensure it's visible


    local function Grounded()
        -- Check if Humanoid exists and is part of the workspace before checking FloorMaterial
        return Humanoid and Humanoid:IsDescendantOf(workspace) and Humanoid.FloorMaterial ~= Enum.Material.Air;
    end

    local function LoadAndPrepareTrack()
        if Track then -- Stop existing track if it exists
             pcall(function() Track:Stop() end)
             Track = nil
        end
        if Humanoid then -- Ensure Humanoid is valid
            local success, result = pcall(function()
                return Humanoid:LoadAnimation(Animation)
            end)
            if success then
                Track = result
                Track.Priority = Enum.AnimationPriority.Action4;
            else
                Track = nil -- Ensure track is nil if loading failed
            end
        else
             Track = nil
        end
    end

    local function Invis_Disable()
        if not InvisEnabled then return end -- Already disabled
        InvisEnabled = false;

        if Track then -- Stop the animation if it exists and is playing
             pcall(function() Track:Stop() end)
             -- Track = nil -- Keep track loaded unless character changes
        end

        -- Restore camera subject only if Humanoid is valid
        if Humanoid then
            workspace.CurrentCamera.CameraSubject = Humanoid;
        end

        -- Reset transparency (check if Character is valid)
        if Character then
            for _, v in pairs(Character:GetDescendants()) do
                if v:IsA("BasePart") and v.Transparency == 0.5 then
                    v.Transparency = 0;
                end
            end
        end

        WarnLabel.Visible = false; -- Hide warning label
    end

    local function Invis_Enable()
        if InvisEnabled or not Invis_Fixed then return end -- Already enabled or incompatible (R15)

        -- Ensure character references are up-to-date and valid
        UpdateCharacterReferences()
        if not Character or not Humanoid or not HumanoidRootPart then
             return
        end
        if not Character:FindFirstChild("Torso") then -- Double check for R6
            pcall(function() StarterGui:SetCore("SendNotification", {Title = "Invisibility FAILED", Text = "Feature requires R6 Avatar.", Duration = 5}) end)
            return
        end


        InvisEnabled = true;
        workspace.CurrentCamera.CameraSubject = HumanoidRootPart; -- Change camera subject

        LoadAndPrepareTrack() -- Load/Reload the animation track

    end

    -- Handle character changes
    Player.CharacterAdded:Connect(function(NewCharacter)
        -- Stop old track if necessary
        if Track then
            pcall(function() Track:Stop() end)
            Track = nil
        end

        -- Poczekaj bardzo krótko, aby dać czas na załadowanie podstawowych elementów
        task.wait() -- Daje silnikowi jeden cykl na aktualizację

        UpdateCharacterReferences() -- Update refs to the new character

        -- SPRAWDZENIE R6/R15 - Najpierw upewnij się, że Humanoid istnieje
        if not Humanoid then
             -- Można dodać dłuższe oczekiwanie, jeśli Humanoid pojawia się z opóźnieniem
             task.wait(0.5) -- Dodatkowe oczekiwanie
             UpdateCharacterReferences() -- Spróbuj ponownie
             if not Humanoid then
                  -- Zdecyduj co robić - na razie zablokujemy, aby uniknąć błędów
                  Invis_Fixed = false
                  if InvisEnabled then Invis_Disable() end
                  pcall(function() StarterGui:SetCore("SendNotification", {Title = "Invisibility Error", Text = "Could not verify character type.", Duration = 5}) end)
                  return
             end
        end

        -- Teraz sprawdź RigType
        if Humanoid.RigType ~= Enum.HumanoidRigType.R6 then
            Invis_Fixed = false
            if InvisEnabled then Invis_Disable() end -- Disable if it was active
            pcall(function() StarterGui:SetCore("SendNotification", {Title = "Invisibility Warning", Text = "Non-R6 Avatar detected (".. tostring(Humanoid.RigType) .."). Invisibility disabled.", Duration = 5}) end)
            return
        else
            -- Wygląda na to, że jest R6
            Invis_Fixed = true -- Mark as compatible again
        end

        -- Jeśli niewidzialność ma przetrwać respawn, włącz ją ponownie
        if InvisEnabled then
            if HumanoidRootPart then -- Upewnij się, że HRP istnieje przed zmianą kamery
                 workspace.CurrentCamera.CameraSubject = HumanoidRootPart -- Ensure camera subject is correct
            else
                 -- Można spróbować poczekać na HRP lub zrezygnować z ustawiania kamery
            end
            LoadAndPrepareTrack() -- Załaduj animację na nowy humanoid
            -- Pętla Heartbeat zajmie się resztą
        end
    end)

    Player.CharacterRemoving:Connect(function(OldCharacter)
         if Track then
             pcall(function() Track:Stop() end)
             Track = nil
         end
         -- Don't disable InvisEnabled here, let CharacterAdded handle re-enabling if needed
         WarnLabel.Visible = false -- Hide warning as character is gone
    end)


    -- Main loop
    Heartbeat:Connect(function(_)
        -- Early exit conditions
        if not InvisEnabled or not Invis_Fixed then
            -- Ensure transparency is reset if script disabled unexpectedly while parts were transparent
            if not InvisEnabled and Character then
                 for _, v in pairs(Character:GetDescendants()) do
                      if v:IsA("BasePart") and v.Transparency == 0.5 then v.Transparency = 0 end
                 end
            end
            WarnLabel.Visible = false -- Keep label hidden if not active
            return;
        end

        -- Check character validity *inside* the loop - CRITICAL for reset safety
        if not Character or not Humanoid or not HumanoidRootPart or not Humanoid:IsDescendantOf(workspace) or Humanoid.Health <= 0 then
            WarnLabel.Visible = false; -- Hide warning if character is invalid/dead
            -- Don't disable InvisEnabled here, CharacterAdded/Removing handles state persistence
            return
        end

        -- Grounded check and warning label
        WarnLabel.Visible = not Grounded();

        -- Store originals
        local OldCFrame = HumanoidRootPart.CFrame;
        local OldCameraOffset = Humanoid.CameraOffset;

        -- Apply transformations
        local _, y = workspace.CurrentCamera.CFrame:ToOrientation();
        HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.CFrame.Position) * CFrame.fromOrientation(0, y, 0);
        HumanoidRootPart.CFrame = HumanoidRootPart.CFrame * CFrame.Angles(math.rad(90), 0, 0);
        Humanoid.CameraOffset = Vector3.new(0, 1.44, 0);

        -- Play/Adjust Animation Track (Check if Track is valid!)
        if Track then
            local successPlay, errPlay = pcall(function()
                if not Track.IsPlaying then
                     Track:Play();
                end
                 Track:AdjustSpeed(0);
                 Track.TimePosition = 0.3;
            end)
             if not successPlay then
                 -- Attempt to reload track if it seems broken
                 LoadAndPrepareTrack()
             end
        elseif Humanoid and Humanoid.Health > 0 then -- Attempt to load if missing and alive
             LoadAndPrepareTrack()
        end

        -- Wait for render
        RenderStepped:Wait();

        -- Revert transformations (check validity again just in case)
        if Humanoid and Humanoid:IsDescendantOf(workspace) then
             Humanoid.CameraOffset = OldCameraOffset;
        end
        if HumanoidRootPart and HumanoidRootPart:IsDescendantOf(workspace) then
             HumanoidRootPart.CFrame = OldCFrame;
        end

        -- Stop animation track (Check if Track is valid!)
        if Track then
            local successStop, errStop = pcall(function() Track:Stop() end)
             if not successStop then
             end
        end

        -- Re-orient character to camera
        if HumanoidRootPart and HumanoidRootPart:IsDescendantOf(workspace) then
             local LookVector = workspace.CurrentCamera.CFrame.LookVector;
             local Horizontal = Vector3.new(LookVector.X, 0, LookVector.Z).Unit;
             if Horizontal.Magnitude > 0.1 then -- Avoid setting to NaN if looking straight up/down
                 local TargetCFrame = CFrame.new(HumanoidRootPart.Position, HumanoidRootPart.Position + Horizontal);
                 HumanoidRootPart.CFrame = TargetCFrame;
             end
        end

        -- Apply transparency (Check Character validity)
        if Character then
             for _, v in pairs(Character:GetDescendants()) do
                 if (v:IsA("BasePart") and v.Transparency ~= 1) then
                     v.Transparency = 0.5;
                 end
             end
        end
    end)

    -- Expose Enable/Disable functions globally if needed by the UI
    -- These need to be defined *after* the internal functions they call
    _G.Invis_Enable = Invis_Enable -- Or use the method your UI framework expects
    _G.Invis_Disable = Invis_Disable
    _G.IsInvisEnabled = function() return InvisEnabled end -- Function for UI state checking

end -- End of invisibility 'do' block
-------------------------------------------------------------------------------

--[[
Remember to replace the Invisibility entry in your UI creation section (categoryFrames.Visuals)
to use these corrected functions, for example:

table.insert(categoryFrames.Visuals,
    createToggleRowFrame(" Invisibility", true, _G.IsInvisEnabled, _G.Invis_Enable, _G.Invis_Disable, function() return invisBind_local end, function(k) invisBind_local=k end)
)
]]


--================= 3 Save-Places =================--
local event_save=DeathRespawn_Event
local SaveCube_Enabled=false; local SaveCube_Connection; local SaveCube_Position=Vector3.new(-4597,-152,-1326);
local function SaveCube_Enable()
    if SaveCube_Enabled then return end; SaveCube_Enabled=true
    local killpart=workspace.Filter.Parts:FindFirstChild("Kill_Brick"); if killpart then killpart:Destroy() end
    SaveCube_Connection=RunService.RenderStepped:Connect(function()
        if not SaveCube_Enabled then return end; local char=LocalPlayer.Character; if not char then return end
        local hrp=char:FindFirstChild("HumanoidRootPart"); local hum=char:FindFirstChildOfClass("Humanoid")
        if hrp then hrp.CFrame=CFrame.new(SaveCube_Position) end
        local tool=LocalPlayer.Backpack:FindFirstChildOfClass("Tool"); if tool and tool.Parent~=char then wait(1); tool.Parent=char end
        if hum and hum.Health<=0 then event_save:InvokeServer("KMG4R904") end
    end)
end
local function SaveCube_Disable()
    if not SaveCube_Enabled then return end; SaveCube_Enabled=false
    if SaveCube_Connection then SaveCube_Connection:Disconnect(); SaveCube_Connection=nil end
end

local SaveSewers_Enabled=false; local SaveSewers_Connection; local SaveSewers_Position=Vector3.new(-4162,-84,-498);
local function SaveSewers_Enable()
    if SaveSewers_Enabled then return end; SaveSewers_Enabled=true
    local killpart=workspace.Filter.Parts:FindFirstChild("Kill_Brick"); if killpart then killpart:Destroy() end
    SaveSewers_Connection=RunService.RenderStepped:Connect(function()
        if not SaveSewers_Enabled then return end; local char=LocalPlayer.Character; if not char then return end
        local hrp=char:FindFirstChild("HumanoidRootPart"); local hum=char:FindFirstChildOfClass("Humanoid")
        if hrp then hrp.CFrame=CFrame.new(SaveSewers_Position) end
        local tool=LocalPlayer.Backpack:FindFirstChildOfClass("Tool"); if tool and tool.Parent~=char then wait(1); tool.Parent=char end
        if hum and hum.Health<=0 then event_save:InvokeServer("KMG4R904") end
    end)
end
local function SaveSewers_Disable()
    if not SaveSewers_Enabled then return end; SaveSewers_Enabled=false
    if SaveSewers_Connection then SaveSewers_Connection:Disconnect(); SaveSewers_Connection=nil end
end

local SaveVibe_Enabled=false; local SaveVibe_Connection; local SaveVibe_Position=Vector3.new(-4805,-201,-855);
local function SaveVibe_Enable()
    if SaveVibe_Enabled then return end; SaveVibe_Enabled=true
    local killpart=workspace.Filter.Parts:FindFirstChild("Kill_Brick"); if killpart then killpart:Destroy() end
    SaveVibe_Connection=RunService.RenderStepped:Connect(function()
        if not SaveVibe_Enabled then return end; local char=LocalPlayer.Character; if not char then return end
        local hrp=char:FindFirstChild("HumanoidRootPart"); local hum=char:FindFirstChildOfClass("Humanoid")
        if hrp then hrp.CFrame=CFrame.new(SaveVibe_Position) end
        local tool=LocalPlayer.Backpack:FindFirstChildOfClass("Tool"); if tool and tool.Parent~=char then wait(1); tool.Parent=char end
        if hum and hum.Health<=0 then event_save:InvokeServer("KMG4R904") end
    end)
end
local function SaveVibe_Disable()
    if not SaveVibe_Enabled then return end; SaveVibe_Enabled=false
    if SaveVibe_Connection then SaveVibe_Connection:Disconnect(); SaveVibe_Connection=nil end
end


--======================= NO RECOIL =========================--
local NoRecoil_Enabled=false
local NoRecoil_Connections={}
local GlobalOriginalValues={}
local WeaponCache={}
local Settings={GunMods={NoRecoil=true,Spread=true,SpreadAmount=0}}
local Player_nr=LocalPlayer

local function cacheWeapons()
    WeaponCache={};
    for _, v in pairs(getgc(true)) do
        if type(v)=='table' and rawget(v,'EquipTime') then
            table.insert(WeaponCache, v);
            if not GlobalOriginalValues[v] then
                GlobalOriginalValues[v]={
                    Recoil=v.Recoil,CameraRecoilingEnabled=v.CameraRecoilingEnabled,
                    AngleX_Min=v.AngleX_Min,AngleX_Max=v.AngleX_Max,
                    AngleY_Min=v.AngleY_Min,AngleY_Max=v.AngleY_Max,
                    AngleZ_Min=v.AngleZ_Min,AngleZ_Max=v.AngleZ_Max,
                    Spread=v.Spread
                }
            end
        end
    end
end

local function applyGunMods()
    for _, weapon in ipairs(WeaponCache) do
        if Settings.GunMods.NoRecoil then
            weapon.Recoil=0; weapon.CameraRecoilingEnabled=false;
            weapon.AngleX_Min=0; weapon.AngleX_Max=0;
            weapon.AngleY_Min=0; weapon.AngleY_Max=0;
            weapon.AngleZ_Min=0; weapon.AngleZ_Max=0;
        end;
        if Settings.GunMods.Spread then
            weapon.Spread=Settings.GunMods.SpreadAmount
        end
    end
end

local function resetGunMods()
    for weapon, values in pairs(GlobalOriginalValues) do
        weapon.Recoil=values.Recoil; weapon.CameraRecoilingEnabled=values.CameraRecoilingEnabled;
        weapon.AngleX_Min=values.AngleX_Min; weapon.AngleX_Max=values.AngleX_Max;
        weapon.AngleY_Min=values.AngleY_Min; weapon.AngleY_Max=values.AngleY_Max;
        weapon.AngleZ_Min=values.AngleZ_Min; weapon.AngleZ_Max=values.AngleZ_Max;
        weapon.Spread=values.Spread;
    end
end

local function handleWeapon(weapon)
    if NoRecoil_Enabled then
        task.wait(0.1);
        cacheWeapons();
        applyGunMods()
    end
end

local function onCharacterAdded_nr(character)
    for _, child in ipairs(character:GetChildren()) do if child:IsA("Tool") then handleWeapon(child) end end;
    table.insert(NoRecoil_Connections, character.ChildAdded:Connect(function(child) if child:IsA("Tool") then handleWeapon(child) end end));
    local humanoid=character:WaitForChild("Humanoid",2);
    if humanoid then
        table.insert(NoRecoil_Connections, humanoid.Died:Connect(function() if NoRecoil_Enabled then task.wait(1.5); cacheWeapons(); applyGunMods() end end))
    end
end

function NoRecoil_Enable()
    if NoRecoil_Enabled then return end;
    NoRecoil_Enabled=true;
    cacheWeapons();
    applyGunMods();
    table.insert(NoRecoil_Connections, Player_nr.CharacterAdded:Connect(onCharacterAdded_nr));
    if Player_nr.Character then onCharacterAdded_nr(Player_nr.Character) end
end

function NoRecoil_Disable()
    if not NoRecoil_Enabled then return end;
    NoRecoil_Enabled=false;
    resetGunMods();
    for _, conn in ipairs(NoRecoil_Connections) do conn:Disconnect() end;
    NoRecoil_Connections={};
end


--======================= WALLHACK (ESP) =========================--
local ESP_Enabled=false
local ESP_Loading=false
local LastToggleTime=0
local DEBOUNCE_TIME=0.5

function ESP_Enable()
    if os.clock()-LastToggleTime<DEBOUNCE_TIME then return end; LastToggleTime=os.clock();
    if ESP_Loading or ESP_Enabled then return end;
    ESP_Loading=true;
    local success, err=pcall(function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/milokoxdxd/testest/refs/heads/main/widocznośćprzezściany", true))();
        ESP_Enabled=true;
        ESP_Loading=false
    end);
    if not success then
        warn("Błąd ładowania ESP: "..tostring(err));
        ESP_Loading=false;
        ESP_Enabled=false;
    end
end

function ESP_Disable()
    if os.clock()-LastToggleTime<DEBOUNCE_TIME then return end; LastToggleTime=os.clock();
    if not ESP_Enabled then return end;
    ESP_Enabled=false;
    local coreGui=game:GetService("CoreGui");
    for _, name in pairs({"Folder","ESP_Holder","ESP_Folder","ESP"}) do
        local folder=coreGui:FindFirstChild(name);
        if folder then folder:Destroy() end
    end
end


-------------------------------------------------------------------------------
--  5. Funkcja tworzenia wiersza przycisku (createToggleRowFrame)
--     + Zmienne Globalne dla Bindów + Poprawka Hover Koloru
-------------------------------------------------------------------------------
local buttonHoverColor = Color3.fromRGB(40, 40, 50)
local buttonColor = Color3.fromRGB(25, 25, 30)
local buttonStrokeColor = Color3.fromRGB(60, 60, 75)
local buttonTextColor = Color3.fromRGB(210, 210, 210)
local buttonOnColor = Color3.fromRGB(70, 180, 100)
local buttonOffColor = Color3.fromRGB(200, 80, 80)
local bindButtonColor = Color3.fromRGB(45, 45, 55)
local bindButtonHoverColor = Color3.fromRGB(60, 60, 75)

-- === Zmienne globalne do obsługi bindów ===
local activeBinds = {} -- Słownik: [Enum.KeyCode] = { frame, toggleButton, isEnabledFn, onEnable, onDisable, canToggle, updateFn }
local currentRowWaitingForKey = nil
local bindButtonReferences = {}
local keyBindGetters = {}
local keyBindSetters = {}
local toggleButtonTweens = {} -- Dla poprawki hover
local rowFunctionData = {} -- NOWA TABELA: Przechowuje statyczne funkcje dla każdej ramki

-- === Funkcja tworząca wiersz ===
local function createToggleRowFrame(scriptName, canToggle, isEnabledFn, onEnable, onDisable, getKeyBindFn, setKeyBindFn)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, -20, 0, 35)
    frame.BackgroundTransparency = 1
    frame.Name = scriptName:gsub("%s+", "")

    local horizontalLayout = Instance.new("UIListLayout")
    horizontalLayout.FillDirection = Enum.FillDirection.Horizontal
    horizontalLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    horizontalLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    horizontalLayout.SortOrder = Enum.SortOrder.LayoutOrder
    horizontalLayout.Padding = UDim.new(0, 5)
    horizontalLayout.Parent = frame

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.45, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = " " .. scriptName
    label.TextColor3 = buttonTextColor
    label.Font = Enum.Font.GothamSemibold
    label.TextSize = 14
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.LayoutOrder = 1
    label.Parent = frame

    local toggleButton = Instance.new("TextButton")
    toggleButton.Size = UDim2.new(0.25, 0, 0.8, 0)
    toggleButton.Font = Enum.Font.GothamBold
    toggleButton.TextSize = 12
    toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleButton.BackgroundColor3 = buttonColor
    toggleButton.BorderSizePixel = 0
    toggleButton.AutoButtonColor = false
    toggleButton.LayoutOrder = 2
    toggleButton.Parent = frame

    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(0, 6)
    toggleCorner.Parent = toggleButton
    local toggleStroke = Instance.new("UIStroke")
    toggleStroke.Color = buttonStrokeColor
    toggleStroke.Thickness = 1
    toggleStroke.Parent = toggleButton

    local bindButton = nil

    -- Definicja funkcji update MUSI być przed jej użyciem w zapisie do rowFunctionData
    local updateToggleButtonVisuals -- Deklaracja wstępna

    -- Funkcja do określania docelowego koloru przycisku toggle
    local function getTargetToggleColor()
        local enabledState = false
        if type(isEnabledFn) == 'function' then
            local success, result = pcall(isEnabledFn)
            if success then enabledState = result end
        end
        if not canToggle then return Color3.fromRGB(80, 120, 220)
        elseif enabledState then return buttonOnColor
        else return buttonOffColor
        end
    end

    -- Funkcja aktualizująca wygląd (tekst + kolor) - definicja
    updateToggleButtonVisuals = function()
        local enabledState = false
        if type(isEnabledFn) == 'function' then
            local success, result = pcall(isEnabledFn)
            if success then enabledState = result else warn("Error in isEnabledFn for", scriptName, ":", result) end
        else warn("isEnabledFn is not a function for", scriptName) end

        if scriptName == " Invisibility" then end

        local targetColor
        if not canToggle then toggleButton.Text = "RUN"; targetColor = Color3.fromRGB(80, 120, 220);
        elseif enabledState then toggleButton.Text = "ON"; targetColor = buttonOnColor
        else toggleButton.Text = "OFF"; targetColor = buttonOffColor
        end

        if toggleButtonTweens[toggleButton] then toggleButtonTweens[toggleButton]:Cancel(); toggleButtonTweens[toggleButton] = nil end
        toggleButton.BackgroundColor3 = targetColor
    end

    -- Zapisz dane funkcji dla tej ramki (NOWA TABELA)
    rowFunctionData[frame] = {
        isEnabledFn = isEnabledFn,
        onEnable = onEnable,
        onDisable = onDisable,
        canToggle = canToggle,
        updateFn = updateToggleButtonVisuals -- Zapisz referencję do lokalnej funkcji update
    }

    -- Przycisk Bind
    if getKeyBindFn and setKeyBindFn then
        bindButton = Instance.new("TextButton")
        bindButton.Size = UDim2.new(0.25, 0, 0.8, 0)
        bindButton.Font = Enum.Font.GothamMedium
        bindButton.TextSize = 12
        bindButton.TextColor3 = buttonTextColor
        bindButton.BackgroundColor3 = bindButtonColor
        bindButton.BorderSizePixel = 0
        bindButton.AutoButtonColor = false
        bindButton.LayoutOrder = 3
        bindButton.Parent = frame

        local bindCorner = Instance.new("UICorner"); bindCorner.CornerRadius = UDim.new(0, 6); bindCorner.Parent = bindButton
        local bindStroke = Instance.new("UIStroke"); bindStroke.Color = buttonStrokeColor; bindStroke.Thickness = 1; bindStroke.Parent = bindButton

        bindButtonReferences[frame] = bindButton
        keyBindGetters[frame] = getKeyBindFn
        keyBindSetters[frame] = setKeyBindFn

        -- Dodaj początkowy wpis do activeBinds, jeśli klawisz jest już ustawiony
        local initialKey = nil
        local success, result = pcall(getKeyBindFn)
        if success and result and typeof(result)=="EnumItem" then
            initialKey = result
            -- Zapisz PEŁNĄ informację pobraną z rowFunctionData
            if rowFunctionData[frame] then
                activeBinds[initialKey] = {
                    frame = frame,
                    toggleButton = toggleButton,
                    isEnabledFn = rowFunctionData[frame].isEnabledFn,
                    onEnable = rowFunctionData[frame].onEnable,
                    onDisable = rowFunctionData[frame].onDisable,
                    canToggle = rowFunctionData[frame].canToggle,
                    updateFn = rowFunctionData[frame].updateFn
                }
            end
        end
    else
        toggleButton.Size = UDim2.new(0.5, 0, 0.8, 0)
        horizontalLayout.Padding = UDim.new(0, 10)
    end

    -- Funkcja aktualizująca tekst przycisku bind
    local function updateBindButtonText()
        if not bindButton then return end
        local kb = nil
        if type(getKeyBindFn) == 'function' then
            local success, result = pcall(getKeyBindFn)
            if success then kb = result else warn("Error in getKeyBindFn for", scriptName, ":", result) end
        end
        bindButton.Text = kb and typeof(kb)=="EnumItem" and kb.Name~="Unknown" and "["..kb.Name.."]" or "Bind"
    end

    -- Początkowa aktualizacja wyglądu
    updateToggleButtonVisuals()
    updateBindButtonText()

    -- Poprawiona logika hover dla Toggle Button
    toggleButton.MouseEnter:Connect(function()
        if toggleButtonTweens[toggleButton] then toggleButtonTweens[toggleButton]:Cancel() end
        local targetColor = getTargetToggleColor()
        local hoverTargetColor = targetColor:Lerp(Color3.new(1, 1, 1), 0.2)
        local tween = TweenService:Create(toggleButton, TweenInfo.new(0.1), { BackgroundColor3 = hoverTargetColor })
        toggleButtonTweens[toggleButton] = tween
        tween:Play()
    end)
    toggleButton.MouseLeave:Connect(function()
        if toggleButtonTweens[toggleButton] then toggleButtonTweens[toggleButton]:Cancel() end
        local targetColor = getTargetToggleColor()
        local tween = TweenService:Create(toggleButton, TweenInfo.new(0.1), { BackgroundColor3 = targetColor })
        toggleButtonTweens[toggleButton] = tween
        tween:Play()
    end)

    -- Logika hover dla przycisku Bind
    if bindButton then
        bindButton.MouseEnter:Connect(function() TweenService:Create(bindButton, TweenInfo.new(0.1), { BackgroundColor3 = bindButtonHoverColor }):Play() end)
        bindButton.MouseLeave:Connect(function() TweenService:Create(bindButton, TweenInfo.new(0.1), { BackgroundColor3 = bindButtonColor }):Play() end)

        -- Logika kliknięcia przycisku Bind (ustawia flagę globalną)
        local capturingKey = false
        bindButton.MouseButton1Click:Connect(function()
            if currentRowWaitingForKey and currentRowWaitingForKey ~= frame then
                local prevBindButton=bindButtonReferences[currentRowWaitingForKey]
                if prevBindButton then
                    local getter=keyBindGetters[currentRowWaitingForKey]
                    local prevKeyText="Bind"; if getter then local s,r=pcall(getter); if s and r and typeof(r)=="EnumItem" then prevKeyText="["..r.Name.."]" end end
                    prevBindButton.Text=prevKeyText
                end
            end
            if capturingKey then
                capturingKey=false; updateBindButtonText(); currentRowWaitingForKey=nil
            else
                capturingKey=true; bindButton.Text="..."; currentRowWaitingForKey=frame
                task.delay(5, function() if capturingKey and currentRowWaitingForKey==frame then capturingKey=false; updateBindButtonText(); currentRowWaitingForKey=nil end end)
            end
        end)
    end

    -- Logika kliknięcia przycisku Toggle
    toggleButton.MouseButton1Click:Connect(function()
        local enabledState = false; if type(isEnabledFn)=='function' then local s,r=pcall(isEnabledFn); if s then enabledState=r end end
        if not canToggle then if type(onEnable)=='function' then pcall(onEnable) else warn("onEnable is not a function for",scriptName) end; toggleButton.Text="DONE"; toggleButton.BackgroundColor3=buttonOnColor:Lerp(Color3.fromRGB(15,15,20),0.3); toggleButton.Active=false; if bindButton then bindButton.Active=false end; return end
        if enabledState then if type(onDisable)=='function' then pcall(onDisable) else warn("onDisable is not a function for",scriptName) end else if type(onEnable)=='function' then pcall(onEnable) else warn("onEnable is not a function for",scriptName) end end
        updateToggleButtonVisuals()
    end)

    return frame
end


-- Zmodernizowana wersja createTPFarmTargetRow (Oryginalny komentarz)
local function createTPFarmTargetRowFrame()
    local frame = Instance.new("Frame")
    frame.Size=UDim2.new(1,-20,0,35)
    frame.BackgroundTransparency=1
    frame.Name="TPFarmTarget"

    local label = Instance.new("TextLabel")
    label.Size=UDim2.new(0.4,0,1,0)
    label.BackgroundTransparency=1
    label.Text="  TP Target:"
    label.TextColor3=buttonTextColor
    label.Font=Enum.Font.GothamSemibold
    label.TextSize=14
    label.TextXAlignment=Enum.TextXAlignment.Left
    label.Parent=frame

    local inputContainer = Instance.new("Frame")
    inputContainer.Size=UDim2.new(0.6,-5,0.8,0)
    inputContainer.Position=UDim2.new(0.4,5,0.1,0)
    inputContainer.BackgroundColor3=buttonColor
    inputContainer.BorderSizePixel=0
    inputContainer.Parent=frame

    local inputCorner = Instance.new("UICorner")
    inputCorner.CornerRadius=UDim.new(0,6)
    inputCorner.Parent=inputContainer
    local inputStroke = Instance.new("UIStroke")
    inputStroke.Color=buttonStrokeColor
    inputStroke.Thickness=1
    inputStroke.Parent=inputContainer

    local input = Instance.new("TextBox")
    input.Size=UDim2.new(1,-10,1,-4)
    input.Position=UDim2.new(0,5,0,2)
    input.BackgroundTransparency=1
    input.TextColor3=Color3.new(1,1,1)
    input.Font=Enum.Font.Gotham
    input.TextSize=12
    input.Text=TPFarm_TargetName -- Użyj ORYGINALNEJ zmiennej
    input.PlaceholderText="Enter Nickname..."
    input.ClearTextOnFocus=false
    input.Parent=inputContainer

    input.FocusLost:Connect(function(enterPressed)
        TPFarm_TargetName=input.Text -- Aktualizuj ORYGINALNĄ zmienną
    end)

    inputContainer.MouseEnter:Connect(function()
        TweenService:Create(inputContainer,TweenInfo.new(0.1),{BackgroundColor3=buttonHoverColor}):Play()
    end)
    inputContainer.MouseLeave:Connect(function()
        TweenService:Create(inputContainer,TweenInfo.new(0.1),{BackgroundColor3=buttonColor}):Play()
    end)
    return frame
end
-- Funkcja tworząca wiersz dla celu teleportacji przy Flingu
local function createFlingTPTargetRowFrame()
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(1, -20, 0, 35)
	frame.BackgroundTransparency = 1
	frame.Name = "FlingTPTarget"

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(0.4, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = "  TP Target:" -- Możesz zmienić tekst
	label.TextColor3 = buttonTextColor
	label.Font = Enum.Font.GothamSemibold
	label.TextSize = 14
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = frame

	local inputContainer = Instance.new("Frame")
	inputContainer.Size = UDim2.new(0.6, -5, 0.8, 0)
	inputContainer.Position = UDim2.new(0.4, 5, 0.1, 0)
	inputContainer.BackgroundColor3 = buttonColor
	inputContainer.BorderSizePixel = 0
	inputContainer.Parent = frame

	local inputCorner = Instance.new("UICorner")
	inputCorner.CornerRadius = UDim.new(0, 6)
	inputCorner.Parent = inputContainer
	local inputStroke = Instance.new("UIStroke")
	inputStroke.Color = buttonStrokeColor
	inputStroke.Thickness = 1
	inputStroke.Parent = inputContainer

	local input = Instance.new("TextBox")
	input.Size = UDim2.new(1, -10, 1, -4)
	input.Position = UDim2.new(0, 5, 0, 2)
	input.BackgroundTransparency = 1
	input.TextColor3 = Color3.new(1, 1, 1)
	input.Font = Enum.Font.Gotham
	input.TextSize = 12
	input.Text = FlingTP_TargetName -- Użyj nowej zmiennej
	input.PlaceholderText = "Enter target nick..." -- Możesz zmienić tekst
	input.ClearTextOnFocus = false
	input.Parent = inputContainer

	input.FocusLost:Connect(function(enterPressed)
		if input.Text ~= "" then
			FlingTP_TargetName = input.Text -- Aktualizuj nową zmienną
		else
			FlingTP_TargetName = "Enter target nick..." -- Resetuj, jeśli puste
			input.Text = FlingTP_TargetName -- Aktualizuj też pole tekstowe
		end
	end)

	inputContainer.MouseEnter:Connect(function()
		TweenService:Create(inputContainer, TweenInfo.new(0.1), { BackgroundColor3 = buttonHoverColor }):Play()
	end)
	inputContainer.MouseLeave:Connect(function()
		TweenService:Create(inputContainer, TweenInfo.new(0.1), { BackgroundColor3 = buttonColor }):Play()
	end)
	return frame
end
-- Funkcja tworząca wiersz z przyciskiem akcji
local function createActionButtonFrame(labelText, buttonText, actionFunction)
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(1, -20, 0, 35)
	frame.BackgroundTransparency = 1
	frame.Name = labelText:gsub("%s+", "") .. "Action"

	local horizontalLayout = Instance.new("UIListLayout")
	horizontalLayout.FillDirection = Enum.FillDirection.Horizontal
	horizontalLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	horizontalLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	horizontalLayout.SortOrder = Enum.SortOrder.LayoutOrder
	horizontalLayout.Padding = UDim.new(0, 10) -- Dostosuj padding
	horizontalLayout.Parent = frame

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(0.45, 0, 1, 0) -- Dostosuj szerokość labelki
	label.BackgroundTransparency = 1
	label.Text = " " .. labelText
	label.TextColor3 = buttonTextColor
	label.Font = Enum.Font.GothamSemibold
	label.TextSize = 14
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.LayoutOrder = 1
	label.Parent = frame

	local actionButton = Instance.new("TextButton")
	actionButton.Size = UDim2.new(0.5, 0, 0.8, 0) -- Dostosuj szerokość przycisku
	actionButton.Font = Enum.Font.GothamBold
	actionButton.TextSize = 12
	actionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	actionButton.Text = buttonText
	actionButton.BackgroundColor3 = buttonColor -- Kolor jak toggle OFF
	actionButton.BorderSizePixel = 0
	actionButton.AutoButtonColor = false
	actionButton.LayoutOrder = 2
	actionButton.Parent = frame

	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 6)
	btnCorner.Parent = actionButton
	local btnStroke = Instance.new("UIStroke")
	btnStroke.Color = buttonStrokeColor
	btnStroke.Thickness = 1
	btnStroke.Parent = actionButton

	-- Logika hover
	actionButton.MouseEnter:Connect(function()
		TweenService:Create(actionButton, TweenInfo.new(0.1), { BackgroundColor3 = buttonHoverColor }):Play()
	end)
	actionButton.MouseLeave:Connect(function()
		TweenService:Create(actionButton, TweenInfo.new(0.1), { BackgroundColor3 = buttonColor }):Play()
	end)

	-- Logika kliknięcia
	actionButton.MouseButton1Click:Connect(function()
		if actionFunction and typeof(actionFunction) == 'function' then
			local success, err = pcall(actionFunction) -- Bezpieczne wywołanie funkcji akcji
            if not success then
                 warn("Error in action button function for '"..labelText.."':", err)
            end
            -- Opcjonalna zmiana wyglądu po kliknięciu, np. chwilowa zmiana koloru
            local originalColor = actionButton.BackgroundColor3
            actionButton.BackgroundColor3 = buttonOnColor -- Chwilowo zielony
            task.wait(0.2)
            actionButton.BackgroundColor3 = originalColor -- Powrót do normalnego
		end
	end)

	return frame
end


-------------------------------------------------------------------------------
--  6. Definicje Kategorii i Tworzenie Przycisków Kategorii
-------------------------------------------------------------------------------
local categories = { "Combat", "Movement", "Visuals", "Farming", "Misc", "Fling", "Rage" }
local categoryButtons = {}
local categoryFrames = {} -- Tabela przechowująca ramki dla każdej kategorii
local activeCategoryButton = nil
local defaultCategory = "Combat" -- Możesz zmienić domyślną kategorię

local function switchCategory(categoryName)
    local categoryButton = categoryButtons[categoryName]
    if not categoryButton or categoryButton == activeCategoryButton then
        return
    end

    -- Zresetuj poprzedni aktywny przycisk
    if activeCategoryButton then
        TweenService:Create(activeCategoryButton, TweenInfo.new(0.2), { BackgroundColor3 = Color3.fromRGB(20, 20, 25) }):Play()
        activeCategoryButton.TextLabel.TextColor3 = Color3.fromRGB(180, 180, 190)
    end

    -- Ustaw nowy aktywny przycisk
    TweenService:Create(categoryButton, TweenInfo.new(0.2), { BackgroundColor3 = Color3.fromRGB(40, 40, 50) }):Play()
    categoryButton.TextLabel.TextColor3 = Color3.fromRGB(230, 230, 230)
    activeCategoryButton = categoryButton

    -- Wyczyść contentFrame
    for _, child in ipairs(contentFrame:GetChildren()) do
        if child:IsA("Frame") and child.Name ~= "UIListLayout" and child.Name ~= "UICorner" then
            child.Parent = nil -- Usuń z widoku
        end
    end

    -- Dodaj ramki z nowej kategorii
    if categoryFrames[categoryName] then
        for i, frame in ipairs(categoryFrames[categoryName]) do
            frame.Parent = contentFrame -- Dodaj do widoku
            frame.LayoutOrder = i -- Ustaw kolejność dla UIListLayout
        end
        -- Zaktualizuj CanvasSize dla przewijania
        local numItems = #categoryFrames[categoryName]
        local itemHeight = 35 -- Wysokość jednej ramki (z createToggleRowFrame)
        local padding = contentLayout.Padding.Offset
        contentFrame.CanvasSize = UDim2.new(0, 0, 0, numItems * itemHeight + (numItems > 0 and (numItems - 1) * padding or 0) + 10) -- Dodatkowy padding na dole
    else
        contentFrame.CanvasSize = UDim2.new(0, 0, 0, 0) -- Zeruj, jeśli kategoria pusta
    end
end

-- Tworzenie przycisków kategorii w sidebarze
for i, categoryName in ipairs(categories) do
    categoryFrames[categoryName] = {} -- Inicjalizuj pustą listę ramek dla kategorii

    local catButton = Instance.new("TextButton")
    catButton.Name = categoryName .. "Button"
    catButton.Size = UDim2.new(1, -10, 0, 30)
    catButton.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    catButton.BorderSizePixel = 0
    catButton.AutoButtonColor = false
    catButton.LayoutOrder = i
    catButton.Parent = sidebarFrame

    local catCorner = Instance.new("UICorner")
    catCorner.CornerRadius = UDim.new(0, 6)
    catCorner.Parent = catButton

    local catLabel = Instance.new("TextLabel")
    catLabel.Name = "TextLabel"
    catLabel.Size = UDim2.new(1, 0, 1, 0)
    catLabel.BackgroundTransparency = 1
    catLabel.Text = categoryName
    catLabel.Font = Enum.Font.GothamSemibold
    catLabel.TextSize = 14
    catLabel.TextColor3 = Color3.fromRGB(180, 180, 190)
    catLabel.Parent = catButton

    -- Animacje i kliknięcie
    catButton.MouseEnter:Connect(function()
        if catButton ~= activeCategoryButton then
            TweenService:Create(catButton, TweenInfo.new(0.1), { BackgroundColor3 = Color3.fromRGB(30, 30, 35) }):Play()
        end
    end)
    catButton.MouseLeave:Connect(function()
        if catButton ~= activeCategoryButton then
            TweenService:Create(catButton, TweenInfo.new(0.1), { BackgroundColor3 = Color3.fromRGB(20, 20, 25) }):Play()
        end
    end)
    catButton.MouseButton1Click:Connect(function()
        switchCategory(categoryName)
    end)

    categoryButtons[categoryName] = catButton -- Zapisz referencję do przycisku
end


-------------------------------------------------------------------------------
--  7. Создаём кнопки в нужном порядке (Oryginalny komentarz)
--     Tworzenie Ramek dla Funkcji i Dodawanie do Kategorii (Używa ORYGINALNYCH funkcji)
-------------------------------------------------------------------------------

-- Lokalne zmienne do przechowywania wartości bindów (dla getterów/setterów)
local keyBinds = {
    fly = Fly_Bind, -- Inicjalizuj wartością, jeśli jest potrzebna od razu
    flingTp = nil,
    fling = nil,
    autoPickupMoney = nil,
    adminCheck = nil,
    melee = nil,
    tpFarm = nil, -- Zmieniono nazwę z tpBind_local
    saveSewers = nil, -- Zmieniono nazwę z ssBind_local
    saveVibe = nil, -- Zmieniono nazwę z svBind_local
    infiniteStamina = nil,
    noRecoil = nil, -- Zmieniono nazwę z nrBind_local
    esp = nil,
    aimbot = AimBotSettings.Keybind, -- Pobierz aktualną wartość z ustawień aimbota
    invis = nil,
    antiFling = nil,
    antiAFK = nil,
    ragebot = nil,
    noFailLockpick = nil,
    openNearbyDoors = nil,
    unlockNearbyDoors = nil -- Ostatni bind
}

-- === Przypisanie ramek do kategorii (Wieloliniowe) ===

-- Combat Category
table.insert(categoryFrames.Combat,
    createToggleRowFrame("Melee Aura", true, function() return MeleeAura_Enabled end, MeleeAura_Enable, MeleeAura_Disable, function() return keyBinds.melee end, function(k) keyBinds.melee=k end)
)
table.insert(categoryFrames.Combat,
    createToggleRowFrame("Aimbot", true, function() return AimBotSettings.Enabled end, Aimbot_Enable, Aimbot_Disable, function() return keyBinds.aimbot end, function(k) keyBinds.aimbot=k; AimBotSettings.Keybind=k end) -- Nadal aktualizuj AimBotSettings
)
table.insert(categoryFrames.Combat,
    createToggleRowFrame("No Recoil", true, function() return NoRecoil_Enabled end, NoRecoil_Enable, NoRecoil_Disable, function() return keyBinds.noRecoil end, function(k) keyBinds.noRecoil=k end)
)

-- Movement Category
table.insert(categoryFrames.Movement,
    createToggleRowFrame("Fly", true, function() return Fly_Enabled end, Fly_Enable, Fly_Disable, function() return keyBinds.fly end, function(k) keyBinds.fly=k; Fly_Bind=k end) -- Nadal aktualizuj Fly_Bind, jeśli jest używany gdzieś indziej
)
table.insert(categoryFrames.Movement,
    createToggleRowFrame("Infinite Stamina", true, function() return isInfiniteStaminaEnabled end, InfiniteStamina_Enable, InfiniteStamina_Disable, function() return keyBinds.infiniteStamina end, function(k) keyBinds.infiniteStamina=k end)
)

-- Visuals Category
table.insert(categoryFrames.Visuals,
    createToggleRowFrame("Wallhack", true, function() return ESP_Enabled end, ESP_Enable, ESP_Disable, function() return keyBinds.esp end, function(k) keyBinds.esp=k end)
)
table.insert(categoryFrames.Visuals,
    createToggleRowFrame("Invisibility", true, _G.IsInvisEnabled, _G.Invis_Enable, _G.Invis_Disable, function() return keyBinds.invis end, function(k) keyBinds.invis=k end) -- Używa funkcji z _G
)

-- Farming Category (Zmieniono nazwę z Teleport)
table.insert(categoryFrames.Farming,
    createToggleRowFrame("Teleport Farm", true, function() return TPFarm_Enabled end, TPFarm_Enable, TPFarm_Disable, function() return keyBinds.tpFarm end, function(k) keyBinds.tpFarm=k end)
)
table.insert(categoryFrames.Farming,
    createTPFarmTargetRowFrame() -- Dodaj pole tekstowe pod spodem (bez zmian)
)
table.insert(categoryFrames.Farming,
    createToggleRowFrame("Safe Sewers TP", true, function() return SaveSewers_Enabled end, SaveSewers_Enable, SaveSewers_Disable, function() return keyBinds.saveSewers end, function(k) keyBinds.saveSewers=k end)
)
table.insert(categoryFrames.Farming,
    createToggleRowFrame("Safe Vibecheck TP", true, function() return SaveVibe_Enabled end, SaveVibe_Enable, SaveVibe_Disable, function() return keyBinds.saveVibe end, function(k) keyBinds.saveVibe=k end)
)

-- Misc Category
--table.insert(categoryFrames.Misc,
    --createToggleRowFrame(" Anti AFK", true, function() return AntiAFK_Enabled_Dummy end, AntiAFK_Enable, AntiAFK_Disable, function() return keyBinds.antiAFK end, function(k) keyBinds.antiAFK=k end)
--)
table.insert(categoryFrames.Misc,
    createToggleRowFrame("Staff Detector", true, function() return AdminCheck_Enabled end, AdminCheck_Enable, AdminCheck_Disable, function() return keyBinds.adminCheck end, function(k) keyBinds.adminCheck=k end)
)
table.insert(categoryFrames.Misc,
    createToggleRowFrame("Anti-Fling", true, function() return AntiFling_Enabled end, AntiFling_Enable, AntiFling_Disable, function() return keyBinds.antiFling end, function(k) keyBinds.antiFling=k end)
)
table.insert(categoryFrames.Misc,
    createToggleRowFrame("Auto Pickup Money", true, function() return AutoPickupMoney_Enabled end, AutoPickupMoney_Enable, AutoPickupMoney_Disable, function() return keyBinds.autoPickupMoney end, function(k) keyBinds.autoPickupMoney=k end)
)
table.insert(categoryFrames.Misc,
    createToggleRowFrame("No Fail Lockpick", true, function() return NoFailLockpick_Enabled end, NoFailLockpick_Enable, NoFailLockpick_Disable, function() return keyBinds.noFailLockpick end, function(k) keyBinds.noFailLockpick=k end)
)
table.insert(categoryFrames.Misc,
    createToggleRowFrame("Auto Unlock Doors", true, function() return UnlockNearbyDoors_Enabled end, UnlockNearbyDoors_Enable, UnlockNearbyDoors_Disable, function() return keyBinds.unlockNearbyDoors end, function(k) keyBinds.unlockNearbyDoors=k end)
)
table.insert(categoryFrames.Misc,
    createToggleRowFrame("Auto Open Doors", true, function() return OpenNearbyDoors_Enabled end, OpenNearbyDoors_Enable, OpenNearbyDoors_Disable, function() return keyBinds.openNearbyDoors end, function(k) keyBinds.openNearbyDoors=k end)
)

-- Fling Category
table.insert(categoryFrames.Fling,
    createToggleRowFrame("Fling", true, function() return Fling_Enabled end, Fling_Enable, Fling_Disable, function() return keyBinds.fling end, function(k) keyBinds.fling=k end)
)
table.insert(categoryFrames.Fling, createFlingTPTargetRowFrame()) -- Pole tekstowe na nick (bez zmian)
table.insert(categoryFrames.Fling,
    createToggleRowFrame("Fling TP To Target", true, function() return FlingTP_Enabled end, FlingTP_Enable, FlingTP_Disable, function() return keyBinds.flingTp end, function(k) keyBinds.flingTp=k end)
)

-- Rage Category
table.insert(categoryFrames.Rage,
    createToggleRowFrame("Ragebot", true, function() return Ragebot_Enabled end, Ragebot_Enable, Ragebot_Disable, function() return keyBinds.ragebot end, function(k) keyBinds.ragebot=k end)
)

-------------------------------------------------------------------------------
--  8. Globalny Listener InputBegan dla Bindów (Poprawiona aktywacja v4)
-------------------------------------------------------------------------------
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then
        return -- Ignoruj input, jeśli gra go przetworzyła (np. pisanie na czacie)
    end

    local keyCode = input.KeyCode
    if keyCode == Enum.KeyCode.Unknown then
        return -- Ignoruj nieznane klawisze
    end

    -- Obsługa ustawiania nowego binda
    if currentRowWaitingForKey then
        local frame = currentRowWaitingForKey -- Ramka oczekująca
        local bindButton = bindButtonReferences[frame]
        local getKeyFn = keyBindGetters[frame]
        local setKeyFn = keyBindSetters[frame]
        local frameData = rowFunctionData[frame] -- Pobierz zapisane funkcje dla tej ramki

        -- Upewnij się, że mamy wszystkie potrzebne referencje
        if bindButton and getKeyFn and setKeyFn and frameData then
            local oldKey = nil
            local successGet, resultGet = pcall(getKeyFn)
            if successGet then
                oldKey = resultGet
            end

            -- Usuń stary bind z tabeli activeBinds, jeśli istniał DLA TEJ FUNKCJI
            if oldKey and activeBinds[oldKey] and activeBinds[oldKey].frame == frame then
                activeBinds[oldKey] = nil
            end

            -- Sprawdź, czy nowy klawisz jest już przypisany do INNEJ funkcji
            if activeBinds[keyCode] and activeBinds[keyCode].frame ~= frame then
                 local otherFrame = activeBinds[keyCode].frame
                 local otherBindButton = bindButtonReferences[otherFrame]
                 local otherSetKeyFn = keyBindSetters[otherFrame]
                 if otherSetKeyFn then
                     pcall(otherSetKeyFn, nil) -- Wyzeruj stary bind
                 end
                 if otherBindButton then
                     otherBindButton.Text = "Bind" -- Zaktualizuj tekst starego przycisku
                 end
                 activeBinds[keyCode] = nil -- Usuń stary wpis z activeBinds
            end

            -- Ustaw nowy klawisz za pomocą settera
            pcall(setKeyFn, keyCode)

            -- Znajdź przycisk toggle dla tej ramki
            local toggleButton = nil
            for _, child in ipairs(frame:GetChildren()) do if child:IsA("TextButton") and child ~= bindButton then toggleButton = child; break end end

            if toggleButton then
                -- Zapisz pełną informację w activeBinds DLA NOWEGO KLAWISZA, używając danych z rowFunctionData
                activeBinds[keyCode] = {
                    frame = frame,
                    toggleButton = toggleButton,
                    isEnabledFn = frameData.isEnabledFn,
                    onEnable = frameData.onEnable,
                    onDisable = frameData.onDisable,
                    canToggle = frameData.canToggle,
                    updateFn = frameData.updateFn
                }
            else
                 warn("Could not find toggle button for frame", frame.Name, "when binding key", keyCode.Name)
            end

            -- Zaktualizuj tekst przycisku bind
            bindButton.Text = "[" .. input.KeyCode.Name .. "]"
            currentRowWaitingForKey = nil -- Zakończ przechwytywanie
        else
            if bindButton then bindButton.Text = "Bind" end -- Zresetuj tekst na wszelki wypadek
            currentRowWaitingForKey = nil
            warn("Error during key capture - missing functions/references for frame:", frame and frame.Name or "Unknown")
        end

    elseif activeBinds[keyCode] then -- Aktywacja przez bind
        local bindInfo = activeBinds[keyCode]
        -- Sprawdź, czy kluczowe elementy istnieją w pobranych danych bindu
        if bindInfo.frame and bindInfo.isEnabledFn and bindInfo.onEnable and bindInfo.onDisable and bindInfo.updateFn and bindInfo.canToggle ~= nil then

            if bindInfo.canToggle then -- Aktywuj tylko jeśli funkcja jest przełączalna
                local success, currentState = pcall(bindInfo.isEnabledFn)
                if success then
                    if currentState then
                        pcall(bindInfo.onDisable) -- Wywołaj Disable
                    else
                        pcall(bindInfo.onEnable) -- Wywołaj Enable
                    end
                    -- Odśwież przycisk po zmianie stanu
                    task.wait() -- Daj chwilę na przetworzenie zmiany stanu flagi
                    pcall(bindInfo.updateFn) -- Wywołaj funkcję aktualizującą przycisk
                end
            end
        end
    end
end)

PlayerGui.ChildAdded:Connect(function(Item)
    if Item.Name == "LockpickGUI" then
        -- Apply modification when the GUI appears, based on the current enabled state
        ApplyLockpickModification()
    end
end)

-------------------------------------------------------------------------------
--  9. Ustawienie Domyślnej Kategorii i Animacja Otwierania
-------------------------------------------------------------------------------
-- Pokaż domyślną kategorię na starcie
switchCategory(defaultCategory)

-- Animacja otwierania okna
mainFrame.Size=UDim2.new(0,0,0,0)
local openTween=TweenService:Create(mainFrame,TweenInfo.new(0.4,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Size=UDim2.new(0,450,0,350)})
task.wait(0.1)
openTween:Play()
print("EQR Hub (Formatted UI - Original Logic - Final Fixes v5) Loaded.")
