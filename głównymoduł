--[[ Original Anti-Idle & Services ]]--

local VirtualUser = game:GetService('VirtualUser')

if game:GetService('Players').LocalPlayer then
    game:GetService('Players').LocalPlayer.Idled:Connect(function()
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new())
    end)
end


--[[ Services ]]--

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService") -- Potrzebny do animacji UI
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")


--[[ Destroy Existing UI ]]--

-- Usuwamy stare wersje GUI, aby uniknƒÖƒá konflikt√≥w
local oldGui = PlayerGui:FindFirstChild("VenomHubScreenGui")
if oldGui then
    oldGui:Destroy()
end

local oldCategorizedGui = PlayerGui:FindFirstChild("VenomHubScreenGui_Categorized")
if oldCategorizedGui then
    oldCategorizedGui:Destroy()
end

local oldKeyGui = PlayerGui:FindFirstChild("KeyVerificationUI")
if oldKeyGui then
    oldKeyGui:Destroy()
end


-------------------------------------------------------------------------------
--  1. Tworzenie G≈Ç√≥wnego UI (Czytelne, Wieloliniowe)
-------------------------------------------------------------------------------

-- G≈Ç√≥wny kontener GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "VenomHubScreenGui_Categorized"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = PlayerGui

-- Ramka g≈Ç√≥wna
local mainFrame = Instance.new("Frame")
mainFrame.Name = "VenomHubMainFrame"
mainFrame.Size = UDim2.new(0, 450, 0, 350) -- Dostosowany rozmiar
mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 20) -- Ciemne t≈Ço jak w drugim skrypcie
mainFrame.BorderSizePixel = 0
mainFrame.ClipsDescendants = true
mainFrame.Visible = true
mainFrame.Active = true
mainFrame.Draggable = false -- Wy≈ÇƒÖczymy standardowe przeciƒÖganie, bo mamy w≈Çasne
mainFrame.Parent = screenGui

-- ZaokrƒÖglenie rog√≥w ramki g≈Ç√≥wnej
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 12)
corner.Parent = mainFrame

-- Obramowanie ramki g≈Ç√≥wnej
local stroke = Instance.new("UIStroke")
stroke.Color = Color3.fromRGB(60, 60, 75) -- Obramowanie jak w drugim skrypcie
stroke.Thickness = 1
stroke.Transparency = 0.5
stroke.Parent = mainFrame

-- Tytu≈Ç
local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Size = UDim2.new(1, -40, 0, 40) -- Dostosowany rozmiar tytu≈Çu
titleLabel.Position = UDim2.new(0, 20, 0, 5) -- Trochƒô ni≈ºej
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "EQR Hub"
titleLabel.Font = Enum.Font.GothamSemibold -- Font jak w drugim skrypcie
titleLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
titleLabel.TextSize = 20 -- Rozmiar fontu
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = mainFrame

-- Linia pod tytu≈Çem
local line = Instance.new("Frame")
line.Name = "Divider"
line.Size = UDim2.new(1, -40, 0, 1)
line.Position = UDim2.new(0, 20, 0, 40) -- Pod tytu≈Çem
line.BackgroundColor3 = Color3.fromRGB(60, 60, 75)
line.BorderSizePixel = 0
line.Parent = mainFrame

-- Podpis (Footer)
local footerLabel = Instance.new("TextLabel")
footerLabel.Name = "Footer"
footerLabel.Size = UDim2.new(1, -20, 0, 20) -- Rozmiar i pozycja stopki
footerLabel.Position = UDim2.new(0, 10, 1, -25)
footerLabel.BackgroundTransparency = 1
footerLabel.Text = "By helloitsme#4243 | Press K to Toggle" -- Dodano info o K
footerLabel.Font = Enum.Font.Gotham -- Font jak w drugim skrypcie
footerLabel.TextSize = 10
footerLabel.TextColor3 = Color3.fromRGB(100, 100, 120)
footerLabel.TextXAlignment = Enum.TextXAlignment.Right
footerLabel.Parent = mainFrame

-- Sidebar na kategorie
local sidebarFrame = Instance.new("Frame")
sidebarFrame.Name = "SidebarFrame"
sidebarFrame.Size = UDim2.new(0, 120, 1, -70) -- Szeroko≈õƒá paska bocznego, wysoko≈õƒá dopasowana
sidebarFrame.Position = UDim2.new(0, 10, 0, 50) -- Pozycja pod liniƒÖ, z lewej
sidebarFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25) -- Nieco inny odcie≈Ñ t≈Ça
sidebarFrame.BorderSizePixel = 0
sidebarFrame.Parent = mainFrame

local sidebarCorner = Instance.new("UICorner")
sidebarCorner.CornerRadius = UDim.new(0, 8)
sidebarCorner.Parent = sidebarFrame

local sidebarLayout = Instance.new("UIListLayout")
sidebarLayout.Padding = UDim.new(0, 5)
sidebarLayout.SortOrder = Enum.SortOrder.LayoutOrder
sidebarLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
sidebarLayout.Parent = sidebarFrame

-- G≈Ç√≥wny kontener na przyciski (z prawej strony)
local contentFrame = Instance.new("ScrollingFrame")
contentFrame.Name = "ContentFrame"
contentFrame.Size = UDim2.new(1, -150, 1, -70) -- Szeroko≈õƒá (ca≈Ço≈õƒá - sidebar - marginesy), wysoko≈õƒá
contentFrame.Position = UDim2.new(0, 140, 0, 50) -- Pozycja obok sidebara
contentFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25) -- Taki sam jak sidebar dla sp√≥jno≈õci
contentFrame.BorderSizePixel = 0
contentFrame.ScrollingDirection = Enum.ScrollingDirection.Y
contentFrame.ScrollBarThickness = 6
contentFrame.ScrollBarImageColor3 = Color3.fromRGB(60, 60, 75)
contentFrame.CanvasSize = UDim2.new(0, 0, 0, 0) -- PoczƒÖtkowo zero, dynamicznie zmieniane
contentFrame.Parent = mainFrame

local contentCorner = Instance.new("UICorner")
contentCorner.CornerRadius = UDim.new(0, 8)
contentCorner.Parent = contentFrame

local contentLayout = Instance.new("UIListLayout")
contentLayout.Padding = UDim.new(0, 8)
contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
contentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
contentLayout.Parent = contentFrame


-------------------------------------------------------------------------------
--  2. –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –æ–∫–Ω–∞ (mainFrame) –ø—Ä–∏ —É–¥–µ—Ä–∂–∞–Ω–∏–∏ –õ–ö–ú (Oryginalny komentarz)
--     (PrzeciƒÖganie okna - Wersja z ograniczeniem do g√≥rnej belki)
-------------------------------------------------------------------------------
do
    local dragging = false
    local dragInput = nil
    local dragStart = nil
    local startPos = nil

    local function update(input)
        local delta = input.Position - dragStart
        local newX = startPos.X.Offset + delta.X
        local newY = startPos.Y.Offset + delta.Y
        mainFrame.Position = UDim2.new(startPos.X.Scale, newX, startPos.Y.Scale, newY)
    end

    mainFrame.InputBegan:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
            local absPos = mainFrame.AbsolutePosition
            local absSize = mainFrame.AbsoluteSize
            local headerHeight = 45 -- Wysoko≈õƒá obszaru przeciƒÖgania (belka tytu≈Çowa)

            -- Sprawd≈∫, czy klikniƒôcie jest w obszarze nag≈Ç√≥wka
            if input.Position.Y < absPos.Y + headerHeight and input.Position.Y > absPos.Y and input.Position.X > absPos.X and input.Position.X < absPos.X + absSize.X then
                dragging = true
                dragStart = input.Position
                startPos = mainFrame.Position

                -- ≈öled≈∫ zmianƒô stanu inputu (puszczenie przycisku)
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end
    end)

    mainFrame.InputChanged:Connect(function(input)
        -- Aktualizuj referencjƒô do inputu, je≈õli to ruch myszki lub dotyk
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        -- Je≈õli przeciƒÖgamy i zarejestrowany input siƒô zmieni≈Ç, zaktualizuj pozycjƒô
        if input == dragInput and dragging then
            update(input)
        end
    end)
end


-------------------------------------------------------------------------------
--  3. –ö–ª–∞–≤–∏—à–∞ [K] –¥–ª—è –ø–æ–∫–∞–∑–∞/—Å–∫—Ä—ã—Ç–∏—è (Oryginalny komentarz)
--     (Klawisz [K] do Pokazania/Ukrycia)
-------------------------------------------------------------------------------
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    -- Je≈õli gra nie przechwyci≈Ça inputu (np. pisanie na czacie)
    if not gameProcessedEvent then
        -- I je≈õli wci≈õniƒôto klawisz K
        if input.KeyCode == Enum.KeyCode.K then
            -- Prze≈ÇƒÖcz widoczno≈õƒá g≈Ç√≥wnego okna
            mainFrame.Visible = not mainFrame.Visible
        end
    end
end)


-------------------------------------------------------------------------------
--  4. –û–±—ä—è–≤–ª—è–µ–º –≤—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏ —Ñ—É–Ω–∫—Ü–∏–∏ —Å–∫—Ä–∏–ø—Ç–æ–≤ (Oryginalny komentarz)
--     ORYGINALNA LOGIKA FUNKCJI SKRYPT√ìW (Formatowanie Wieloliniowe)
-------------------------------------------------------------------------------

--======================= NO FAIL LOCKPICK (Added) =========================--
local NoFailLockpick_Enabled = false

-- Function to apply lockpick modification (used by Enable/Disable and Listener)
local function ApplyLockpickModification()
    local lockpickGui = PlayerGui:FindFirstChild("LockpickGUI")
    if lockpickGui then
        task.wait(0.1) -- Short delay for safety, GUI elements might need time to load
        local scaleValue = NoFailLockpick_Enabled and 10 or 1 -- Set scale based on the enabled flag
        pcall(function() -- Use pcall for safety in case GUI structure changes
            local lpFrame = lockpickGui:FindFirstChild("MF", true) and lockpickGui.MF:FindFirstChild("LP_Frame", true)
            if lpFrame and lpFrame:FindFirstChild("Frames", true) then
                 local frames = lpFrame.Frames
                 -- Find each bar's UIScale and set its scale
                 if frames:FindFirstChild("B1", true) and frames.B1:FindFirstChild("Bar", true) and frames.B1.Bar:FindFirstChild("UIScale", true) then frames.B1.Bar.UIScale.Scale = scaleValue end
                 if frames:FindFirstChild("B2", true) and frames.B2:FindFirstChild("Bar", true) and frames.B2.Bar:FindFirstChild("UIScale", true) then frames.B2.Bar.UIScale.Scale = scaleValue end
                 if frames:FindFirstChild("B3", true) and frames.B3:FindFirstChild("Bar", true) and frames.B3.Bar:FindFirstChild("UIScale", true) then frames.B3.Bar.UIScale.Scale = scaleValue end
            else
                 -- Optional: warn("NoFailLockpick: Could not find expected structure inside existing LockpickGUI.")
            end
        end)
    end
end

local function NoFailLockpick_Enable()
    if NoFailLockpick_Enabled then return end -- Already enabled
    NoFailLockpick_Enabled = true
    ApplyLockpickModification() -- Apply modification immediately if the GUI is already open
end

local function NoFailLockpick_Disable()
    if not NoFailLockpick_Enabled then return end -- Already disabled
    NoFailLockpick_Enabled = false
    ApplyLockpickModification() -- Revert modification immediately if the GUI is already open
end
-------------------------------------------------------------------------------

--======================= OPEN NEARBY DOORS (Added) =========================--
local OpenNearbyDoors_Enabled = false
local OpenNearbyDoors_Coroutine = nil -- To manage the loop

-- The main loop logic for opening doors
local function OpenNearbyDoors_Loop()
    while OpenNearbyDoors_Enabled and task.wait(0.25) do -- Check every 0.25 seconds
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local hum = char and char:FindFirstChildOfClass("Humanoid")

        -- Stop checking if player is dead or character doesn't exist
        if not hrp or not hum or hum.Health <= 0 then
            continue -- Skip this iteration
        end

        local doorsFolder = Workspace.Map:FindFirstChild("Doors")
        if not doorsFolder then
            warn("OpenNearbyDoors: Cannot find Workspace.Map.Doors folder.")
            OpenNearbyDoors_Disable() -- Disable the feature if the folder is missing
            break -- Exit the loop
        end

        local playerPos = hrp.Position
        for _, doorInstance in ipairs(doorsFolder:GetChildren()) do
             -- Check if the instance looks like a valid door model based on children
            local doorBase = doorInstance:FindFirstChild("DoorBase")
            local valuesFolder = doorInstance:FindFirstChild("Values")
            local eventsFolder = doorInstance:FindFirstChild("Events")

            if doorBase and valuesFolder and eventsFolder then
                local openValue = valuesFolder:FindFirstChild("Open")
                local toggleEvent = eventsFolder:FindFirstChild("Toggle")
                -- Find a part likely used as the second argument, e.g., Knob2 or similar name
                local knobArgument = doorInstance:FindFirstChild("Knob2") or doorInstance:FindFirstChild("Knob") -- Adjust if needed

                -- Proceed only if all required parts/values/events are found
                if openValue and toggleEvent and knobArgument and typeof(openValue.Value) == "boolean" then
                    -- Check distance and if the door is currently closed
                    if (playerPos - doorBase.Position).Magnitude <= 6 then -- Slightly increased range
                        if openValue.Value == false then
                            -- Fire the event safely using pcall
                            local success, err = pcall(function()
                                toggleEvent:FireServer("Open", knobArgument)
                            end)
                            if not success then
                                warn("OpenNearbyDoors: Error firing Toggle event for door", doorInstance.Name, ":", err)
                            end
                            -- No wait here, check all nearby doors in one cycle
                        end
                    end
                end
            end
        end
    end
    OpenNearbyDoors_Coroutine = nil -- Clear coroutine reference when loop finishes
end

-- Enable function starts the loop
local function OpenNearbyDoors_Enable()
    if OpenNearbyDoors_Enabled then return end -- Already enabled
    OpenNearbyDoors_Enabled = true
    -- Start the loop in a new coroutine if it's not already running
    if not OpenNearbyDoors_Coroutine then
        OpenNearbyDoors_Coroutine = task.spawn(OpenNearbyDoors_Loop)
    end
end

-- Disable function sets the flag, the loop will stop itself
local function OpenNearbyDoors_Disable()
    if not OpenNearbyDoors_Enabled then return end -- Already disabled
    OpenNearbyDoors_Enabled = false
    -- The loop checks the 'OpenNearbyDoors_Enabled' flag and will exit automatically.
    -- Coroutine reference is cleared inside the loop itself.
end
-------------------------------------------------------------------------------

--================== NEARBY DOOR INTERACTIONS (Open & Unlock - Combined) ==================--
local OpenNearbyDoors_Enabled = false
local UnlockNearbyDoors_Enabled = false
local NearbyDoorInteraction_Coroutine = nil -- Single coroutine for both features

-- Combined loop function for handling nearby door opening and unlocking
local function NearbyDoorInteraction_Loop()
    while (OpenNearbyDoors_Enabled or UnlockNearbyDoors_Enabled) do -- Run as long as at least one feature is active
        local waitTime = 0.25 -- How often to check nearby doors
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local hum = char and char:FindFirstChildOfClass("Humanoid")

        -- If player is dead or character doesn't exist, wait longer before next check
        if not hrp or not hum or hum.Health <= 0 then
            task.wait(waitTime * 2) -- Wait longer if dead/no char
            continue
        end

        local doorsFolder = Workspace.Map:FindFirstChild("Doors")
        if not doorsFolder then
            warn("NearbyDoorInteraction: Cannot find Workspace.Map.Doors folder. Disabling features.")
            -- Disable both features if the folder is missing
            if OpenNearbyDoors_Enabled then OpenNearbyDoors_Disable() end
            if UnlockNearbyDoors_Enabled then UnlockNearbyDoors_Disable() end
            break -- Exit the loop permanently if structure is wrong
        end

        local playerPos = hrp.Position
        local checkRadius = 6 -- How close the player needs to be

        for _, doorInstance in ipairs(doorsFolder:GetChildren()) do
            -- Basic checks for a valid door structure
            local doorBase = doorInstance:FindFirstChild("DoorBase")
            local valuesFolder = doorInstance:FindFirstChild("Values")
            local eventsFolder = doorInstance:FindFirstChild("Events")

            if doorBase and valuesFolder and eventsFolder then
                -- Check distance first for performance
                if (playerPos - doorBase.Position).Magnitude <= checkRadius then
                    local toggleEvent = eventsFolder:FindFirstChild("Toggle")
                    if not toggleEvent then continue end -- Skip if no Toggle event

                    -- --- Unlock Logic ---
                    if UnlockNearbyDoors_Enabled then
                        local lockedValue = valuesFolder:FindFirstChild("Locked")
                        local lockArgument = doorInstance:FindFirstChild("Lock") -- Instance needed for Unlock event

                        -- Check if door is locked and we have the needed parts/values
                        if lockedValue and lockArgument and typeof(lockedValue.Value) == "boolean" and lockedValue.Value == true then
                            -- Fire the "Unlock" event safely
                            local success, err = pcall(function() toggleEvent:FireServer("Unlock", lockArgument) end)
                            if not success then warn("UnlockNearbyDoors: Error firing event for", doorInstance.Name, ":", err) end
                            -- If unlock succeeds, the door might become openable immediately,
                            -- so we let the Open logic below handle it in the same cycle if needed.
                        end
                    end

                    -- --- Open Logic ---
                    if OpenNearbyDoors_Enabled then
                        local openValue = valuesFolder:FindFirstChild("Open")
                         -- Argument for Open event (usually Knob2 or similar)
                        local knobArgument = doorInstance:FindFirstChild("Knob2") or doorInstance:FindFirstChild("Knob")

                         -- Check if door is closed and we have the needed parts/values
                        if openValue and knobArgument and typeof(openValue.Value) == "boolean" and openValue.Value == false then
                            -- Check if it's *not* locked (or if unlock is off and we don't care)
                            local isLocked = valuesFolder:FindFirstChild("Locked")
                            if not isLocked or isLocked.Value == false or not UnlockNearbyDoors_Enabled then
                                 -- Fire the "Open" event safely
                                local success, err = pcall(function() toggleEvent:FireServer("Open", knobArgument) end)
                                if not success then warn("OpenNearbyDoors: Error firing event for", doorInstance.Name, ":", err) end
                            end
                        end
                    end
                end -- End distance check
            end -- End valid door structure check
        end -- End door loop

        task.wait(waitTime) -- Wait before the next full check cycle
    end -- End while loop
    NearbyDoorInteraction_Coroutine = nil -- Clear reference when loop naturally exits
end

-- Helper function to start/stop the single interaction loop
local function StartStopDoorInteractionLoop()
    -- Check if the loop should be running
    local shouldRun = OpenNearbyDoors_Enabled or UnlockNearbyDoors_Enabled

    if shouldRun and not NearbyDoorInteraction_Coroutine then
        -- Start the loop if it should run but isn't currently
        NearbyDoorInteraction_Coroutine = task.spawn(NearbyDoorInteraction_Loop)
    elseif not shouldRun and NearbyDoorInteraction_Coroutine then
         -- The loop will stop itself because the while condition will be false.
         -- The coroutine reference is cleared inside the loop function.
    end
end

-- --- Enable/Disable Functions ---

-- Open Doors
function OpenNearbyDoors_Enable()
    if OpenNearbyDoors_Enabled then return end
    OpenNearbyDoors_Enabled = true
    StartStopDoorInteractionLoop()
end

function OpenNearbyDoors_Disable()
    if not OpenNearbyDoors_Enabled then return end
    OpenNearbyDoors_Enabled = false
    StartStopDoorInteractionLoop()
end

-- Unlock Doors
function UnlockNearbyDoors_Enable()
    if UnlockNearbyDoors_Enabled then return end
    UnlockNearbyDoors_Enabled = true
    StartStopDoorInteractionLoop()
end

function UnlockNearbyDoors_Disable()
    if not UnlockNearbyDoors_Enabled then return end
    UnlockNearbyDoors_Enabled = false
    StartStopDoorInteractionLoop()
end
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Block for: Auto Pickup Money (Add this with other function definitions)
-------------------------------------------------------------------------------

--[[ NOTE: This feature assumes global 'Settings' and 'CoolDowns' tables exist
     with the required structure (Settings.IsDead, CoolDowns.AutoPickUps.MoneyCooldown)
     Ensure these are defined elsewhere in your main script. ]]

local AutoPickupMoney_Enabled = false
local AutoPickupMoney_Connection = nil
local AutoPickupMoney_Coroutine = nil -- To manage the coroutine itself

-- Placeholder for CoolDowns if not defined globally yet (REMOVE if defined globally)
-- local CoolDowns = { AutoPickUps = { MoneyCooldown = false } }
-- Placeholder for Settings if not defined globally yet (REMOVE if defined globally)
-- local Settings = { IsDead = false } -- Example: Assume the player starts alive

local function AutoPickupMoney_Logic()
    -- Use global services assumed to be defined at the top
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")

    local cashFolder = Workspace.Filter:FindFirstChild("SpawnedBread")
    local remoteEvent = ReplicatedStorage.Events:FindFirstChild("CZDPZUS")

    if not cashFolder then
        warn("AutoPickupMoney: Could not find Workspace.Filter.SpawnedBread folder.")
        AutoPickupMoney_Disable() -- Disable if the folder doesn't exist
        return
    end
    if not remoteEvent then
        warn("AutoPickupMoney: Could not find ReplicatedStorage.Events.CZDPZUS RemoteEvent.")
        AutoPickupMoney_Disable() -- Disable if the remote doesn't exist
        return
    end

    -- Ensure CoolDowns structure exists (or create it safely)
    if not CoolDowns then CoolDowns = {} end
    if not CoolDowns.AutoPickUps then CoolDowns.AutoPickUps = {} end
    if CoolDowns.AutoPickUps.MoneyCooldown == nil then CoolDowns.AutoPickUps.MoneyCooldown = false end
     -- Ensure Settings structure exists (or create it safely)
    if not Settings then Settings = {} end
    if Settings.IsDead == nil then Settings.IsDead = false end -- Default to alive


    AutoPickupMoney_Connection = RunService.RenderStepped:Connect(function()
        -- Primary check: Is the feature enabled?
        if not AutoPickupMoney_Enabled then return end

        -- Check if player is dead (using the assumed Settings table)
        if Settings.IsDead then return end

        local player = Players.LocalPlayer
        local character = player and player.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")

        -- Check if player character and HRP exist
        if not hrp then return end

        -- Check cooldown *before* iterating (minor optimization)
        if CoolDowns.AutoPickUps.MoneyCooldown then return end

        local rootPosition = hrp.Position
        for i, v in ipairs(cashFolder:GetChildren()) do
            -- Check distance
            if (rootPosition - v.Position).Magnitude < 5 then
                -- Check cooldown again (might have changed between iterations, though unlikely here)
                if not CoolDowns.AutoPickUps.MoneyCooldown then
                    CoolDowns.AutoPickUps.MoneyCooldown = true
                    pcall(function() -- Use pcall for safety when firing remote
                        remoteEvent:FireServer(v)
                    end)

                    task.wait(1) -- Use task.wait instead of wait

                    CoolDowns.AutoPickUps.MoneyCooldown = false
                    break -- Exit loop after picking one up to prevent potential spam
                end
            end
        end
    end)
end

local function AutoPickupMoney_Enable()
    if AutoPickupMoney_Enabled then return end
    AutoPickupMoney_Enabled = true

    -- Disconnect old connection if somehow exists
    if AutoPickupMoney_Connection then
        AutoPickupMoney_Connection:Disconnect()
        AutoPickupMoney_Connection = nil
    end
     -- Stop existing coroutine if it exists
    if AutoPickupMoney_Coroutine then
        coroutine.close(AutoPickupMoney_Coroutine)
        AutoPickupMoney_Coroutine = nil
    end

    -- Start the logic in a coroutine
    AutoPickupMoney_Coroutine = coroutine.create(AutoPickupMoney_Logic)
    coroutine.resume(AutoPickupMoney_Coroutine)

    -- Optional: Update button visuals immediately if needed (the framework might handle this already)
    -- findButtonAndUpdateVisuals("Auto pickup money")
end

local function AutoPickupMoney_Disable()
    if not AutoPickupMoney_Enabled then return end
    AutoPickupMoney_Enabled = false

    -- Disconnect the RenderStepped event
    if AutoPickupMoney_Connection then
        AutoPickupMoney_Connection:Disconnect()
        AutoPickupMoney_Connection = nil
    end
    -- Stop the coroutine
    if AutoPickupMoney_Coroutine then
        coroutine.close(AutoPickupMoney_Coroutine)
        AutoPickupMoney_Coroutine = nil
    end

    -- Reset cooldown just in case it was stuck on true
    if CoolDowns and CoolDowns.AutoPickUps then
        CoolDowns.AutoPickUps.MoneyCooldown = false
    end

     -- Optional: Update button visuals immediately if needed
    -- findButtonAndUpdateVisuals("Auto pickup money")
end
--============================ Fly ============================--
local Fly_Enabled = false
local Fly_Bind = nil
local Fly_Connection
local Fly_Speed = 50

local function Fly_Enable()
    if Fly_Enabled then
        return
    end
    Fly_Enabled = true

    Fly_Connection = RunService.RenderStepped:Connect(function(dt)
        if not Fly_Enabled then
            return
        end
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
            local cam = workspace.CurrentCamera
            local moveDir = Vector3.new()
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                moveDir = moveDir + cam.CFrame.LookVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                moveDir = moveDir - cam.CFrame.LookVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                moveDir = moveDir - cam.CFrame.RightVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                moveDir = moveDir + cam.CFrame.RightVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                moveDir = moveDir + Vector3.new(0,1,0)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                moveDir = moveDir - Vector3.new(0,1,0)
            end

            if moveDir.Magnitude > 0 then
                hrp.CFrame = hrp.CFrame + (moveDir.Unit * Fly_Speed * dt)
            end
        end
    end)
end

local function Fly_Disable()
    if not Fly_Enabled then
        return
    end
    Fly_Enabled = false
    if Fly_Connection then
        Fly_Connection:Disconnect()
        Fly_Connection = nil
    end
end


--========================== Admin Check (Nowy - z Twojego kodu) ========================--
local AdminCheck_Enabled = false -- Domy≈õlnie wy≈ÇƒÖczony
local AdminCheck_Connection = nil

-- Us≈Çugi (zak≈Çadamy, ≈ºe Players, ReplicatedStorage, LocalPlayer sƒÖ ju≈º zdefiniowane globalnie)
-- Je≈õli nie, odkomentuj poni≈ºsze lub dostosuj:
-- local Players = game:GetService("Players")
-- local ReplicatedStorage = game:GetService("ReplicatedStorage")
-- local Player = Players.LocalPlayer -- U≈ºyj globalnego LocalPlayer je≈õli istnieje

-- --- Konfiguracja Staff ---
local staffPlayers = {
    groups = {
        [4165692] = { -- crimcorp
            ["Tester"] = true, ["Contributor"] = true, ["Tester+"] = true, ["Developer"] = true,
            ["Developer+"] = true, ["Community Manager"] = true, ["Manager"] = true, ["Owner"] = true
        },
        [32406137] = { -- staff thing
            ["Junior"] = true, ["Moderator"] = true, ["Senior"] = true, ["Administrator"] = true,
            ["Manager"] = true, ["Holder"] = true
        },
        [8024440] = { -- r3shape fanclub
            ["zzzz"] = true, ["reshape enjoyer"] = true, ["i heart reshape"] = true, ["reshape superfan"] = true
        },
        [14927228] = { -- War Room
            ["‚ôû"] = true
        }
        -- Pamiƒôtaj, aby poprawnie zamknƒÖƒá tabelƒô groups, je≈õli dodajesz wiƒôcej
    }, -- Zamkniƒôcie groups
    users = { -- Lista UserID
         3294804378, 93676120, 54087314, 81275825, 140837601, 1229486091, 46567801, 418086275, 29706395,
         3717066084, 1424338327, 5046662686, 5046661126, 5046659439, 418199326, 1024216621, 1810535041,
         63238912, 111250044, 63315426, 730176906, 141193516, 194512073, 193945439, 412741116, 195538733,
         102045519, 955294, 957835150, 25689921, 366613818, 281593651, 455275714, 208929505, 96783330,
         156152502, 93281166, 959606619, 142821118, 632886139, 175931803, 122209625, 278097946, 142989311,
         1517131734, 446849296, 87189764, 67180844, 9212846, 47352513, 48058122, 155413858, 10497435,
         513615792, 55893752, 55476024, 151691292, 136584758, 16983447, 3111449, 94693025, 271400893,
         5005262660, 295331237, 64489098, 244844600, 114332275, 25048901, 69262878, 50801509, 92504899,
         42066711, 50585425, 31365111, 166406495, 2457253857, 29761878, 21831137, 948293345, 439942262,
         38578487, 1163048, 7713309208, 3659305297, 15598614, 34616594, 626833004, 198610386, 153835477,
         3923114296, 3937697838, 102146039, 119861460, 371665775, 1206543842, 93428604, 1863173316, 90814576,
         374665997, 423005063, 140172831, 42662179, 9066859, 438805620, 14855669, 727189337, 1871290386,
         608073286
         -- Pamiƒôtaj, aby poprawnie zamknƒÖƒá tabelƒô users, je≈õli dodajesz wiƒôcej
    } -- Zamkniƒôcie users
} -- Zamkniƒôcie staffPlayers
-- --- Koniec Konfiguracji Staff ---

-- Funkcje pomocnicze z Twojego kodu
local function hasTracker(player)
    if not player or not player:IsA("Player") then return false, nil end
    -- Bezpieczniejsze iterowanie po dzieciach
    local children = player:GetChildren()
    for i = 1, #children do
        local child = children[i]
        -- Sprawd≈∫, czy nazwa jest stringiem i czy zawiera "Tracker" na ko≈Ñcu
        if typeof(child.Name) == "string" and string.sub(child.Name, -8) == "Tracker$" then
            local trackedPlayerName = string.sub(child.Name, 1, -9) -- Usu≈Ñ "Tracker$"
             if Players:FindFirstChild(trackedPlayerName) then
                return true, trackedPlayerName
            end
        end
    end
    return false, nil
end

local function isStaff(player)
    if not player or not player:IsA("Player") then return false end

    -- Sprawdzanie grup
    if staffPlayers.groups then
        for groupID, roles in pairs(staffPlayers.groups) do
            -- Bezpieczne wywo≈Çanie GetRankInGroup
            local successRank, rank = pcall(function() return player:GetRankInGroup(groupID) end)
            if successRank and rank and rank > 0 then
                -- Bezpieczne wywo≈Çanie GetRoleInGroup
                local successRole, roleName = pcall(function() return player:GetRoleInGroup(groupID) end)
                if successRole and roleName and roles[roleName] then
                    return true, roleName, groupID
                end
            end
        end
    end

    -- Sprawdzanie UserID
    if staffPlayers.users then
        for i = 1, #staffPlayers.users do
            if player.UserId == staffPlayers.users[i] then
                return true, "UserID", player.UserId -- Zwr√≥ƒá UserID jako groupID dla sp√≥jno≈õci
            end
        end
    end

    return false
end

local function kickformat(staffInfo)
    if not staffInfo or not staffInfo.Staff then return "Staff detected." end -- Domy≈õlna wiadomo≈õƒá
    local message = "Staff detected:\n"
    for i, staff in ipairs(staffInfo.Staff) do
        local idType = "Role"
        local idValue = staff.Role or "Unknown"
        if staff.Role == "UserID" then
            idType = "UserID"
            idValue = staff.GroupId or "Unknown" -- W funkcji isStaff, UserID jest teraz w GroupId
        elseif staff.Role == "Tracker User" then
             idType = "Tracker"
             idValue = "Active"
        end

        message = message .. string.format(
            "- %s (%s: %s)%s",
            staff.Name or "Unknown",
            idType,
            idValue,
            staff.TrackedPlayer and " - Tracking: " .. staff.TrackedPlayer or ""
        )
        if i < #staffInfo.Staff then
            message = message .. "\n"
        end
    end
    return message
end

local function kickWithStaffInfo(staffInfo)
    local kickMsg = kickformat(staffInfo)
    -- U≈ºyj globalnego LocalPlayer zamiast lokalnego 'Player' z Twojego kodu
    if LocalPlayer then
        LocalPlayer:Kick("Staff joined\n\n" .. kickMsg)
    end
end

local function checkCurrentStaff()
    local staffFound = {}
    local currentPlayers = Players:GetPlayers()
    for i = 1, #currentPlayers do
        local player = currentPlayers[i]
        if player ~= LocalPlayer then -- Nie sprawdzaj siebie
            local isPlayerStaff, role, groupID = isStaff(player)
            local hasTrackers, trackedPlayer = hasTracker(player)

            if isPlayerStaff or hasTrackers then
                table.insert(staffFound, {
                    Name = player.Name,
                    Role = hasTrackers and "Tracker User" or role,
                    GroupId = groupID,
                    TrackedPlayer = trackedPlayer
                })
            end
        end
    end

    if #staffFound > 0 then
        kickWithStaffInfo({Staff = staffFound})
        return true -- Znaleziono staff
    end
    return false -- Nie znaleziono staffu
end

-- Zmieniona nazwa funkcji i dodane sprawdzenie flagi
local function onPlayerJoining(player)
     if not AdminCheck_Enabled then return end -- Sprawd≈∫ czy funkcja jest w≈ÇƒÖczona

     local isPlayerStaff, role, groupID = isStaff(player)
     local hasTrackers, trackedPlayer = hasTracker(player)

     if isPlayerStaff or hasTrackers then
         local staffInfo = {
             Staff = {{
                 Name = player.Name,
                 Role = hasTrackers and "Tracker User" or role,
                 GroupId = groupID,
                 TrackedPlayer = trackedPlayer
             }}
         }
         kickWithStaffInfo(staffInfo)
     end
end

-- --- Funkcje Enable/Disable dla UI ---
local function AdminCheck_Enable()
    if AdminCheck_Enabled then return end
    AdminCheck_Enabled = true -- Natychmiast ustaw flagƒô na true

    -- === Aktualizacja UI powinna nastƒÖpiƒá tutaj ===
    -- Zak≈ÇadajƒÖc, ≈ºe Twoja funkcja createToggleRowFrame aktualizuje przycisk
    -- po zmianie flagi AdminCheck_Enabled (np. przez klikniƒôcie),
    -- przycisk powinien od razu pokazaƒá stan "ON".
    -- Je≈õli nie, musia≈Çby≈õ dodaƒá tutaj kod rƒôcznie aktualizujƒÖcy przycisk.

    print("Admin Check v2.1 Enabling...")

    -- Roz≈ÇƒÖcz stare po≈ÇƒÖczenie je≈õli istnieje
    if AdminCheck_Connection then AdminCheck_Connection:Disconnect() end

    -- Pod≈ÇƒÖcz listener PlayerAdded (to jest szybkie)
    AdminCheck_Connection = Players.PlayerAdded:Connect(onPlayerJoining)
    print("Admin Check 2.1 Monitoring started.")

    -- Wy≈õlij powiadomienie (to te≈º jest szybkie)
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Staff Detection", Text = "Monitoring active", Duration = 5,
            Icon = "rbxassetid://121588751997553" -- << ID Obrazka
        })
    end)

    -- === Uruchom sprawdzanie obecnych graczy W TLE ===
    task.spawn(function()
        print("Admin Check: Running initial check on current players in background...")
        local foundStaff = checkCurrentStaff() -- Ta funkcja mo≈ºe zajƒÖƒá chwilƒô

        if foundStaff then
            -- Je≈õli znaleziono staff, gracz zosta≈Ç ju≈º wyrzucony przez checkCurrentStaff().
            -- Funkcja checkCurrentStaff sama w sobie wywo≈Çuje kick.
            -- Mo≈ºemy opcjonalnie zaktualizowaƒá stan z powrotem, chocia≈º gracz jest ju≈º wyrzucany.
            AdminCheck_Enabled = false
            warn("Admin Check: Staff found by background check. Kicked.")
            -- Mo≈ºna by tu dodaƒá aktualizacjƒô przycisku UI z powrotem na OFF, ale to bezcelowe przy kicku.
            if AdminCheck_Connection then -- Roz≈ÇƒÖcz listener, bo nie jest ju≈º potrzebny
                 AdminCheck_Connection:Disconnect()
                 AdminCheck_Connection = nil
            end
        else
             print("Admin Check: Initial background check complete, no staff found.")
        end
    end)
    -- Funkcja AdminCheck_Enable ko≈Ñczy siƒô tutaj natychmiast, nie czekajƒÖc na checkCurrentStaff.
end

local function AdminCheck_Disable()
    if not AdminCheck_Enabled then return end
    AdminCheck_Enabled = false

    if AdminCheck_Connection then
        AdminCheck_Connection:Disconnect()
        AdminCheck_Connection = nil
    end
    print("Admin Check 2.1 Disabled.")
end

-- Opcjonalne uruchomienie domy≈õlne (je≈õli chcesz, aby startowa≈Ç w≈ÇƒÖczony)
-- if true then -- Zmie≈Ñ na true, je≈õli ma byƒá domy≈õlnie w≈ÇƒÖczony
--    AdminCheck_Enable()
-- end


-- AntiAFK - teraz z mo≈ºliwo≈õciƒÖ bindowania stanu przycisku
local AntiAFK_Enabled_Dummy = true
local AntiAFK_Bind = nil -- Dodajemy zmiennƒÖ na bind
local function AntiAFK_Enable()
    AntiAFK_Enabled_Dummy = true
end
local function AntiAFK_Disable()
    AntiAFK_Enabled_Dummy = false
end


--=================== Melee Aura 4 Alt MAX! (Poprawiona Logika Zgodnie z B≈Çƒôdem) =====================--
local MeleeAura_Enabled = false
local MeleeAura_Connection

local runAttackLoop do
    local plrs = game:GetService("Players")
    local me = plrs.LocalPlayer
    local run = game:GetService("RunService")
    local replicatedStorage = game:GetService("ReplicatedStorage")
    local eventsFolder = replicatedStorage:WaitForChild("Events")

    -- === POPRAWKA ===
    -- Zak≈Çadamy, ≈ºe remote1 odnosi siƒô do RemoteFunction (np. "XMHH.2" jak w komentarzu)
    -- a remote2 odnosi siƒô do RemoteEvent ("XMHH2.2").
    -- Je≈õli nazwy sƒÖ inne w Twojej grze, zaktualizuj je poni≈ºej.
    local remoteFunctionPath = "XMHH.2" -- Nazwa RemoteFunction (do InvokeServer)
    local remoteEventPath = "XMHH2.2" -- Nazwa RemoteEvent (do FireServer)

    local remote1 = eventsFolder:WaitForChild(remoteFunctionPath) -- Powinien byƒá RemoteFunction
    local remote2 = eventsFolder:WaitForChild(remoteEventPath)    -- Powinien byƒá RemoteEvent
    -- === KONIEC POPRAWKI ===

    local maxdist = 5

    local function Attack(target)
        -- Sprawdzenie celu jak w oryginale
        if not (target and target:FindFirstChild("Head")) then return end

        local char = me.Character
        local tool = char and char:FindFirstChildOfClass("Tool")
        local hrp = char and char:FindFirstChild("HumanoidRootPart")

        -- Sprawdzenie, czy oba remotes istniejƒÖ i sƒÖ poprawnego typu
        if not remote1 or not remote1:IsA("RemoteFunction") then
            warn("MeleeAura Error: Cannot find required RemoteFunction at: ReplicatedStorage.Events." .. remoteFunctionPath .. " or it's not a RemoteFunction.")
            MeleeAura_Disable() -- Wy≈ÇƒÖcz, bo nie zadzia≈Ça
            return
        end
        if not remote2 or not remote2:IsA("RemoteEvent") then
            warn("MeleeAura Error: Cannot find required RemoteEvent at: ReplicatedStorage.Events." .. remoteEventPath .. " or it's not a RemoteEvent.")
            MeleeAura_Disable() -- Wy≈ÇƒÖcz, bo nie zadzia≈Ça
            return
        end

        -- === POPRAWKA: U≈ºycie pcall dla bezpiecze≈Ñstwa wywo≈Ça≈Ñ zdalnych ===
        -- Wywo≈Çanie InvokeServer na RemoteFunction (remote1)
        local arg1 = {
            [1] = "üçû",
            [2] = tick(),
            [3] = tool,
            [4] = "43TRFWX",
            [5] = "Normal",
            [6] = tick(),
            [7] = true
        }
        local success1, result = pcall(function()
            return remote1:InvokeServer(unpack(arg1))
        end)

        if not success1 then
            warn("MeleeAura Error: InvokeServer on " .. remoteFunctionPath .. " failed:", result)
            -- Mo≈ºna rozwa≈ºyƒá MeleeAura_Disable() tutaj, je≈õli b≈ÇƒÖd jest krytyczny
            return -- Przerwij atak, je≈õli pierwsze wywo≈Çanie siƒô nie powiod≈Ço
        end
        -- Je≈õli sukces, 'result' zawiera zwr√≥conƒÖ warto≈õƒá

        task.wait(0.1) -- Op√≥≈∫nienie z orygina≈Çu

        -- Sprawdzenie Handle i Head jak w oryginale
        local Handle = tool and (tool:FindFirstChild("WeaponHandle") or tool:FindFirstChild("Handle")) or (char and char:FindFirstChild("Right Arm"))
        local head = target:FindFirstChild("Head")

        if Handle and head and hrp then -- Dodano sprawdzenie hrp dla pozycji
            -- Wywo≈Çanie FireServer na RemoteEvent (remote2), u≈ºywajƒÖc 'result' z InvokeServer
            local arg2 = {
                [1] = "üçû",
                [2] = tick(),
                [3] = tool,
                [4] = "2389ZFX34",
                [5] = result, -- U≈ºycie wyniku z InvokeServer
                [6] = false,
                [7] = Handle,
                [8] = head,
                [9] = target,
                [10] = hrp.Position, -- U≈ºyj pozycji hrp
                [11] = head.Position
            }
            local success2, errorMsg2 = pcall(function()
                remote2:FireServer(unpack(arg2))
            end)
            if not success2 then
                warn("MeleeAura Error: FireServer on " .. remoteEventPath .. " failed:", errorMsg2)
            end
            -- === KONIEC POPRAWKI pcall ===
        end
    end

    runAttackLoop = function()
        return run.RenderStepped:Connect(function()
            if not MeleeAura_Enabled then return end -- Sprawd≈∫ flagƒô
            local char = me.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if hrp then -- Upewnij siƒô, ≈ºe gracz ma HRP
                for _, plr in ipairs(plrs:GetPlayers()) do
                    if plr ~= me then
                        local c = plr.Character
                        local hrp2 = c and c:FindFirstChild("HumanoidRootPart")
                        local hum = c and c:FindFirstChildOfClass("Humanoid")
                        -- Nie potrzebujemy sprawdzaƒá g≈Çowy tutaj, bo Attack() to robi
                        if hrp2 and hum then
                            local dist = (hrp.Position - hrp2.Position).Magnitude
                            -- Sprawdzenia z orygina≈Çu
                            if dist < maxdist and hum.Health > 15 and not c:FindFirstChildOfClass("ForceField") then
                                Attack(c)
                            end
                        end
                    end
                end
            end
        end)
    end
end

local function MeleeAura_Enable()
    if MeleeAura_Enabled then return end
    MeleeAura_Enabled = true
    -- Roz≈ÇƒÖcz stare po≈ÇƒÖczenie, je≈õli istnieje, aby uniknƒÖƒá wyciek√≥w
    if MeleeAura_Connection and MeleeAura_Connection.Connected then
        MeleeAura_Connection:Disconnect()
    end
    MeleeAura_Connection = runAttackLoop()
end

local function MeleeAura_Disable()
    if not MeleeAura_Enabled then return end
    MeleeAura_Enabled = false
    if MeleeAura_Connection and MeleeAura_Connection.Connected then -- Roz≈ÇƒÖcz, je≈õli istnieje i jest po≈ÇƒÖczone
        MeleeAura_Connection:Disconnect()
        MeleeAura_Connection = nil
    end
    -- Dodatkowo, zaktualizuj przycisk UI, je≈õli jest powiƒÖzany
    -- (zak≈ÇadajƒÖc, ≈ºe masz mechanizm aktualizacji przycisk√≥w)
    for key, bindData in pairs(activeBinds) do
        if bindData.onEnable == MeleeAura_Enable then
             if bindData.updateFn then
                 pcall(bindData.updateFn) -- Wywo≈Çaj funkcjƒô aktualizacji przycisku
             end
             break -- Znaleziono, mo≈ºna przerwaƒá
        end
    end
end
--======================= Teleport Farm =========================--
local TPFarm_Enabled = false
local TPFarm_TargetName = "Type ALT account name.."
local TPFarm_SteppedConnection = nil
local TPFarm_RenderConnection = nil
local TPFarm_CharConnection = nil
local DeathRespawn_Event = game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("DeathRespawn")

-- –õ–æ–∫–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è, –≤—ã–∑—ã–≤–∞–µ–º–∞—è –ø—Ä–∏ —Å–ø–∞–≤–Ω–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ (CharacterAdded) (Oryginalny komentarz)
local function TPFarm_OnCharacterAdded(char)
    if TPFarm_SteppedConnection then
        TPFarm_SteppedConnection:Disconnect()
        TPFarm_SteppedConnection=nil
    end
    task.wait(0.4)
    local hrp=char:FindFirstChild("HumanoidRootPart")
    local hum=char:FindFirstChildOfClass("Humanoid")
    if not (hrp and hum) then
        return
    end
    TPFarm_SteppedConnection=RunService.Stepped:Connect(function()
        if not TPFarm_Enabled then
            return
        end
        local mainPlayer=Players:FindFirstChild(TPFarm_TargetName)
        local mainChar=mainPlayer and mainPlayer.Character
        local mainHRP=mainChar and mainChar:FindFirstChild("HumanoidRootPart")
        if mainHRP then
            hrp.CFrame=mainHRP.CFrame+(mainHRP.CFrame.LookVector*3)
            -- Oryginalna logika resetu HP (potencjalny memory leak)
            hum:GetPropertyChangedSignal("Health"):Connect(function()
                hum.Health=0
            end)
        end
    end)
end

local function TPFarm_Enable()
    if TPFarm_Enabled then
        return
    end
    TPFarm_Enabled=true
    local killpart=workspace.Filter.Parts:FindFirstChild("Kill_Brick")
    if killpart then
        killpart:Destroy()
    end
    local me=LocalPlayer
    if me.Character then
        TPFarm_OnCharacterAdded(me.Character)
    end
    TPFarm_CharConnection=me.CharacterAdded:Connect(function(newChar)
        if not TPFarm_Enabled then
            return
        end
        TPFarm_OnCharacterAdded(newChar)
        local tool=me.Backpack:FindFirstChildOfClass("Tool")
        if tool and newChar then
            tool.Parent=newChar
        end
    end)
    TPFarm_RenderConnection=RunService.RenderStepped:Connect(function()
        if not TPFarm_Enabled then
            return
        end
        local char=me.Character
        if char then
            local humanoid=char:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health<=0 then
                DeathRespawn_Event:InvokeServer("KMG4R904")
            end
        end
    end)
end

local function TPFarm_Disable()
    if not TPFarm_Enabled then
        return
    end
    TPFarm_Enabled=false
    if TPFarm_SteppedConnection then
        TPFarm_SteppedConnection:Disconnect()
        TPFarm_SteppedConnection=nil
    end
    if TPFarm_RenderConnection then
        TPFarm_RenderConnection:Disconnect()
        TPFarm_RenderConnection=nil
    end
    if TPFarm_CharConnection then
        TPFarm_CharConnection:Disconnect()
        TPFarm_CharConnection=nil
    end
end

-------------------------------------------------------------------------------
--======================= AIMBOT (Logika Oryginalna + Poprawka B≈Çƒôdu Nil) =========================--
local players_aim = Players
local localPlayer_aim = LocalPlayer
local CurrentCamera_aim = workspace.CurrentCamera
local TweenService_aim = TweenService
local UserInputService_aim = UserInputService
local mouseLocation_aim = UserInputService_aim.GetMouseLocation
local RunService_aim = RunService

-- WA≈ªNE: Definicja AimBotSettings MUSI byƒá PRZED funkcjami, kt√≥re jej u≈ºywajƒÖ.
local AimBotSettings = {
    Enabled = false; TeamCheck = false; WallCheck = true; StickyAim = false;
    UseMouse = true; MouseBind = "MouseButton2"; Keybind = nil; -- Usuniƒôto domy≈õlny bind 'E'
    ShowFov = false; Fov = 100;
    Smoothing = 0.02; AimPart = "HumanoidRootPart";
    IsAimKeyDown = false; Target = nil; CameraTween = nil;
}

-- Definicje funkcji pomocniczych (zgodne z logikƒÖ orygina≈Çu i poprawkami)
local function IsAlive_aim(Player)
    -- Dodano sprawdzenie czy Player.Character istnieje przed dostƒôpem do Humanoid
    return Player and Player.Character and Player.Character:FindFirstChildOfClass("Humanoid") and Player.Character.Humanoid.Health > 0
end

local function GetTeam_aim(Player)
    -- Dodano sprawdzenie Player.Team przed dostƒôpem do Name
    if not localPlayer_aim.Neutral and Player and Player.Team and game:GetService("Teams"):FindFirstChild(Player.Team.Name) then
        return game:GetService("Teams")[Player.Team.Name];
    end
    return nil;
end

-- Poprawiona funkcja isVisible_aim (przyjmuje pozycjƒô, nie instancjƒô)
local function isVisible_aim(targetPosition, character)
    -- Sprawdzenie czy WallCheck jest w≈ÇƒÖczony musi odwo≈Çywaƒá siƒô do tabeli AimBotSettings
    if not AimBotSettings.WallCheck then
        return true;
    end

    -- Upewnij siƒô, ≈ºe localPlayer_aim.Character istnieje
    local ignoreList = {CurrentCamera_aim}
    if localPlayer_aim.Character then
         table.insert(ignoreList, localPlayer_aim.Character)
    end
    -- Upewnij siƒô, ≈ºe character i jego Head istniejƒÖ
    if character and character:FindFirstChild("Head") and character.Head.Parent then
        table.insert(ignoreList, character.Head.Parent)
    end

    -- U≈ºyj pcall dla bezpiecze≈Ñstwa przy GetPartsObscuringTarget
    local success, obscured = pcall(function()
        return CurrentCamera_aim:GetPartsObscuringTarget({targetPosition}, ignoreList)
    end)

    -- Je≈õli pcall siƒô nie powi√≥d≈Ç lub zwr√≥ci≈Ç nil, za≈Ç√≥≈º, ≈ºe jest zas≈Çoniƒôty (bezpieczniej)
    if not success or obscured == nil then
        return false
    end
    return #obscured == 0;
end

-- Poprawiona funkcja CameraGetClosestToMouse_aim (przekazuje pozycjƒô do isVisible_aim)
local function CameraGetClosestToMouse_aim()
    -- Odwo≈Çanie do Fov musi u≈ºywaƒá tabeli AimBotSettings
    local AimFov = AimBotSettings.Fov;
    local targetPlayer = nil;

    for i, v in pairs(players_aim:GetPlayers()) do
        if v ~= localPlayer_aim then
            -- Odwo≈Çanie do TeamCheck musi u≈ºywaƒá tabeli AimBotSettings
            if AimBotSettings.TeamCheck ~= true or GetTeam_aim(v) ~= GetTeam_aim(localPlayer_aim) then
                if IsAlive_aim(v) then
                    local char = v.Character
                    -- Odwo≈Çanie do AimPart musi u≈ºywaƒá tabeli AimBotSettings
                    local aimPartInstance = char and char:FindFirstChild(AimBotSettings.AimPart)
                    if aimPartInstance then
                        local aimPartPosition = aimPartInstance.Position
                        -- Bezpieczne wywo≈Çanie WorldToViewportPoint
                        local successWTV, screen_pos, on_screen = pcall(function() return CurrentCamera_aim:WorldToViewportPoint(aimPartPosition) end)
                        if successWTV and on_screen then
                             local screen_pos_2D = Vector2.new(screen_pos.X, screen_pos.Y)
                             local successMouseLoc, mousePos = pcall(mouseLocation_aim, UserInputService_aim)
                             if not successMouseLoc then mousePos = Vector2.new() end -- Domy≈õlna pozycja myszy w razie b≈Çƒôdu
                             local new_magnitude = (screen_pos_2D - mousePos).Magnitude
                             -- Przeka≈º pozycjƒô i postaƒá do isVisible_aim
                             if new_magnitude < AimFov and isVisible_aim(aimPartPosition, char) then
                                AimFov = new_magnitude;
                                targetPlayer = v;
                             end
                        end
                    end
                end
            end
        end
    end
    return targetPlayer;
end

-- Listener InputBegan (zgodny z logikƒÖ orygina≈Çu + sprawdzenie AimBotSettings)
UserInputService_aim.InputBegan:Connect(function(input, gameProcessedEvent)
    -- Sprawd≈∫ czy AimBotSettings istnieje PRZED pr√≥bƒÖ dostƒôpu do Enabled
    if not AimBotSettings then return end
    if gameProcessedEvent or not AimBotSettings.Enabled then return end

    if not AimBotSettings.UseMouse and AimBotSettings.Keybind and input.KeyCode == AimBotSettings.Keybind then
        AimBotSettings.Target = CameraGetClosestToMouse_aim();
        AimBotSettings.IsAimKeyDown = true;
    elseif AimBotSettings.UseMouse then
        local bind = ""
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            bind = "MouseButton1"
        elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
            bind = "MouseButton2"
        end

        if bind == AimBotSettings.MouseBind then
            AimBotSettings.Target = CameraGetClosestToMouse_aim();
            AimBotSettings.IsAimKeyDown = true;
        end
    end
end)

-- Listener InputEnded (zgodny z logikƒÖ orygina≈Çu + sprawdzenie AimBotSettings)
UserInputService_aim.InputEnded:Connect(function(input, gameProcessedEvent)
     -- Sprawd≈∫ czy AimBotSettings istnieje PRZED pr√≥bƒÖ dostƒôpu do Enabled
    if not AimBotSettings then return end
    if gameProcessedEvent or not AimBotSettings.Enabled then return end

    if not AimBotSettings.UseMouse and AimBotSettings.Keybind and input.KeyCode == AimBotSettings.Keybind then
        AimBotSettings.IsAimKeyDown = false;
        AimBotSettings.Target = nil;
        if AimBotSettings.CameraTween then
            AimBotSettings.CameraTween:Cancel();
            AimBotSettings.CameraTween = nil;
        end
    elseif AimBotSettings.UseMouse then
        local bind = ""
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            bind = "MouseButton1"
        elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
            bind = "MouseButton2"
        end

        if bind == AimBotSettings.MouseBind then
            AimBotSettings.IsAimKeyDown = false;
            AimBotSettings.Target = nil;
            if AimBotSettings.CameraTween then
                AimBotSettings.CameraTween:Cancel();
                AimBotSettings.CameraTween = nil;
            end
        end
    end
end)

-- Listener Heartbeat (zgodny z logikƒÖ orygina≈Çu + sprawdzenie AimBotSettings)
RunService_aim.Heartbeat:Connect(function(deltaTime)
    -- === TUTAJ JEST LINIA POWODUJƒÑCA B≈ÅƒÑD ===
    -- Sprawd≈∫ czy AimBotSettings istnieje PRZED pr√≥bƒÖ dostƒôpu do Enabled
    if AimBotSettings and AimBotSettings.Enabled then
        if AimBotSettings.IsAimKeyDown then
            local currentTarget = AimBotSettings.Target

            if AimBotSettings.StickyAim then
                 if currentTarget ~= nil and IsAlive_aim(currentTarget) then
                    local targetChar = currentTarget.Character
                    local aimPart = targetChar and targetChar:FindFirstChild(AimBotSettings.AimPart)
                    if aimPart then
                        if AimBotSettings.CameraTween then AimBotSettings.CameraTween:Cancel(); AimBotSettings.CameraTween = nil; end
                        -- Bezpieczniejsza predykcja pinga
                        local networkPing = 0
                        local successPing, resultPing = pcall(function() return localPlayer_aim:GetNetworkPing() end)
                        if successPing then networkPing = resultPing end
                        local predictionOffset = aimPart.Velocity and aimPart.Velocity * (networkPing * 0.1) or Vector3.new() -- U≈ºyj 0.1 jako mno≈ºnik zamiast Vector3.zero
                        local targetCFrame = CFrame.new(CurrentCamera_aim.CFrame.Position, aimPart.Position + predictionOffset)

                        -- U≈ºyj pcall dla bezpiecze≈Ñstwa tworzenia tweena
                        local successTween, tweenResult = pcall(function()
                            AimBotSettings.CameraTween = TweenService_aim:Create(CurrentCamera_aim, TweenInfo.new(AimBotSettings.Smoothing, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = targetCFrame});
                            AimBotSettings.CameraTween:Play();
                        end)
                        if not successTween then warn("Aimbot Tween creation failed:", tweenResult) end

                    else
                        AimBotSettings.Target = nil
                        if AimBotSettings.CameraTween then AimBotSettings.CameraTween:Cancel(); AimBotSettings.CameraTween = nil; end
                    end
                 else
                    local newTarget = CameraGetClosestToMouse_aim()
                    AimBotSettings.Target = newTarget
                    currentTarget = newTarget

                    if currentTarget and IsAlive_aim(currentTarget) then
                        local targetChar = currentTarget.Character
                        local aimPart = targetChar and targetChar:FindFirstChild(AimBotSettings.AimPart)
                        if aimPart then
                            if AimBotSettings.CameraTween then AimBotSettings.CameraTween:Cancel(); AimBotSettings.CameraTween = nil; end
                             local networkPing = 0; local sP, rP=pcall(function() return localPlayer_aim:GetNetworkPing() end); if sP then networkPing=rP end
                             local predictionOffset = aimPart.Velocity and aimPart.Velocity * (networkPing * 0.1) or Vector3.new()
                             local targetCFrame = CFrame.new(CurrentCamera_aim.CFrame.Position, aimPart.Position + predictionOffset)

                             local sT, tR = pcall(function()
                                AimBotSettings.CameraTween = TweenService_aim:Create(CurrentCamera_aim, TweenInfo.new(AimBotSettings.Smoothing, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = targetCFrame});
                                AimBotSettings.CameraTween:Play();
                             end)
                             if not sT then warn("Aimbot Tween creation failed (new target):", tR) end
                        end
                    elseif AimBotSettings.CameraTween then
                         AimBotSettings.CameraTween:Cancel(); AimBotSettings.CameraTween = nil;
                    end
                 end

            else -- Nie StickyAim
                local target = CameraGetClosestToMouse_aim();
                if target ~= nil and IsAlive_aim(target) then
                    local targetChar = target.Character
                    local aimPart = targetChar and targetChar:FindFirstChild(AimBotSettings.AimPart)
                    if aimPart then
                        if AimBotSettings.CameraTween then AimBotSettings.CameraTween:Cancel(); AimBotSettings.CameraTween = nil; end
                        local networkPing = 0; local sP, rP=pcall(function() return localPlayer_aim:GetNetworkPing() end); if sP then networkPing=rP end
                        local predictionOffset = aimPart.Velocity and aimPart.Velocity * (networkPing * 0.1) or Vector3.new()
                        local targetCFrame = CFrame.new(CurrentCamera_aim.CFrame.Position, aimPart.Position + predictionOffset)

                        local sT, tR = pcall(function()
                            AimBotSettings.CameraTween = TweenService_aim:Create(CurrentCamera_aim, TweenInfo.new(AimBotSettings.Smoothing, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = targetCFrame});
                            AimBotSettings.CameraTween:Play();
                        end)
                         if not sT then warn("Aimbot Tween creation failed (non-sticky):", tR) end

                    else
                         if AimBotSettings.CameraTween then AimBotSettings.CameraTween:Cancel(); AimBotSettings.CameraTween = nil; end
                    end
                elseif AimBotSettings.CameraTween ~= nil then
                    AimBotSettings.CameraTween:Cancel();
                    AimBotSettings.CameraTween = nil;
                end
            end
        end
    -- Dodano 'else' na wypadek gdyby AimBotSettings by≈Ço nil - nic nie r√≥b
    -- elseif not AimBotSettings then
       -- Mo≈ºna dodaƒá warn("AimBotSettings jest nil w Heartbeat!") dla debugowania
    end
end)

-- Funkcje Enable/Disable (pozostajƒÖ takie same jak w nowym skrypcie)
local function Aimbot_Enable()
    if AimBotSettings then AimBotSettings.Enabled=true else warn("Cannot enable Aimbot: AimBotSettings is nil") end
end
local function Aimbot_Disable()
    if AimBotSettings then
        AimBotSettings.Enabled=false; AimBotSettings.IsAimKeyDown=false; AimBotSettings.Target=nil;
        if AimBotSettings.CameraTween then AimBotSettings.CameraTween:Cancel(); AimBotSettings.CameraTween=nil end
    else
         warn("Cannot disable Aimbot: AimBotSettings is nil")
    end
end

--======================= INF STAMINA (Logika Oryginalna) =========================--
-- WA≈ªNE: Poni≈ºszy blok kodu (od `local UserInputService_stam...` do `end)`)
--        musi zostaƒá umieszczony w G≈Å√ìWNYM zakresie skryptu (nie wewnƒÖtrz innej funkcji),
--        aby hook zosta≈Ç wykonany raz podczas ≈Çadowania skryptu.

local UserInputService_stam = UserInputService -- U≈ºyj UserInputService zdefiniowanego na g√≥rze skryptu
local isInfiniteStaminaEnabled = false -- Zmienna stanu
local oldStaminaFunction = nil -- Przechowuje oryginalnƒÖ funkcjƒô
local targetFunction = nil -- Funkcja docelowa z upvalue

do -- U≈ºywamy 'do...end' aby ograniczyƒá zasiƒôg zmiennych lokalnych dla hooka
    local success_hook, result_hook = pcall(function()
        -- Spr√≥buj znale≈∫ƒá funkcjƒô docelowƒÖ (zak≈ÇadajƒÖc, ≈ºe ≈õcie≈ºka jest poprawna)
        local env = nil
        local success_env1, env1 = pcall(getrenv)
        if success_env1 then env = env1 else local success_env2, env2 = pcall(getfenv); if success_env2 then env = env2 end end

        if env and env._G and env._G.S_Take then
             local success_upval, upval = pcall(getupvalue, env._G.S_Take, 2)
             if success_upval and type(upval) == 'function' then
                 targetFunction = upval
             else
                 warn("Inf Stamina: Nie mo≈ºna pobraƒá upvalue 2 lub nie jest to funkcja.")
             end
        else
             warn("Inf Stamina: Nie znaleziono _G.S_Take.")
        end

        -- Zahacz funkcjƒô, je≈õli zosta≈Ça znaleziona
        if targetFunction then
             local hookSuccess, hookResult = pcall(function()
                 oldStaminaFunction = hookfunction(
                     targetFunction,
                     function(v1, ...) -- Nowa funkcja zastƒôpujƒÖca oryginalnƒÖ
                         local args = {...} -- Zbieranie pozosta≈Çych argument√≥w
                         if isInfiniteStaminaEnabled then
                             -- Je≈õli niesko≈Ñczona stamina jest W≈ÅƒÑCZONA, zmie≈Ñ ilo≈õƒá zabieranej staminy na 0
                             -- Wywo≈Çaj oryginalnƒÖ funkcjƒô z v1 = 0 i resztƒÖ argument√≥w
                             return oldStaminaFunction(0, unpack(args))
                         else
                             -- Je≈õli niesko≈Ñczona stamina jest WY≈ÅƒÑCZONA, wywo≈Çaj oryginalnƒÖ funkcjƒô bez zmian
                             return oldStaminaFunction(v1, unpack(args))
                         end
                     end
                 )
             end)
             if not hookSuccess then
                  warn("Inf Stamina: hookfunction nie powi√≥d≈Ç siƒô: ", hookResult)
                  oldStaminaFunction = nil -- Upewnij siƒô, ≈ºe nie pr√≥bujemy u≈ºyƒá nieudanej funkcji hooka
             end
        end
    end)
    if not success_hook then
        warn("Inf Stamina: WystƒÖpi≈Ç b≈ÇƒÖd podczas pr√≥by hookowania: ", result_hook)
    end
end -- Koniec bloku 'do' dla hooka

-- Funkcje Enable/Disable (tylko prze≈ÇƒÖczajƒÖ flagƒô, jak w oryginale)
local function InfiniteStamina_Enable()
    if not oldStaminaFunction then
        warn("Inf Stamina: Funkcja staminy nie zosta≈Ça zahaczona. Infinite Stamina nie dzia≈Ça.")
        -- Mo≈ºna dodaƒá pr√≥bƒô ponownego hookowania tutaj, je≈õli chcesz zachowaƒá czƒô≈õƒá logiki z nowego skryptu
        return
    end
    isInfiniteStaminaEnabled = true
end

local function InfiniteStamina_Disable()
    -- Nie trzeba sprawdzaƒá oldStaminaFunction, bo wy≈ÇƒÖczenie jest bezpieczne nawet bez hooka
    isInfiniteStaminaEnabled = false
end

--======================= INVISIBILITY (Corrected for Reset Errors) =========================--
local Invis_Fixed = true -- Flag to indicate the corrected version is used

do -- Use a 'do' block to scope variables specific to invisibility
    repeat task.wait() until game:IsLoaded();

    local cloneref = cloneref or function(...) return ... end;

    local Service = setmetatable({}, {
        __index = function(_, k)
            return cloneref(game:GetService(k));
        end
    });

    local Player: Player = Service.Players.LocalPlayer; -- Use Service table
    local Character: Model = Player.Character or Player.CharacterAdded:Wait();
    local Humanoid: Humanoid
    local HumanoidRootPart: BasePart

    local function UpdateCharacterReferences()
        Character = Player.Character
        if Character then
            HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
            Humanoid = Character:FindFirstChildOfClass("Humanoid")
        else
            HumanoidRootPart = nil
            Humanoid = nil
        end
    end

    UpdateCharacterReferences() -- Initial call

    local InvisEnabled = false; -- Invisibility is disabled by default
    local Track = nil -- Variable to hold the AnimationTrack
    local Animation = Instance.new("Animation"); -- Create Animation instance once
    Animation.AnimationId = "rbxassetid://215384594"; -- Set AnimationId once

    local RunService: RunService = Service.RunService;
    local Heartbeat = RunService.Heartbeat;
    local RenderStepped = RunService.RenderStepped;

    local UserInputService: UserInputService = Service.UserInputService;
    local CoreGui: CoreGui = Service.CoreGui; -- Use Service table
    local StarterGui: StarterGui = Service.StarterGui; -- Use Service table

    -- Check for R6 (do this once after initial character load)
    if Character and not Character:FindFirstChild("Torso") then
        pcall(function() -- Use pcall for safety
            StarterGui:SetCore("SendNotification", {
                Title = "Invisibility FAILED",
                Text = "Feature requires R6 Avatar.",
                Duration = 5,
            });
        end)
        -- We don't 'return' here in the global scope, just prevent the feature from enabling later if needed.
        -- Or, set a flag to prevent enable/disable functions from working.
        Invis_Fixed = false -- Mark as incompatible
    end

    -- GUI for warning message
    local GUI = Instance.new("ScreenGui");
    GUI.Name = "InvisWarningGUI";
    GUI.Parent = CoreGui; -- Parent to CoreGui
    GUI.ResetOnSpawn = false;
    GUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling;

    local WarnLabel = Instance.new("TextLabel", GUI);
    WarnLabel.Text = "‚ö†Ô∏èYou are visible‚ö†Ô∏è";
    WarnLabel.Visible = false;
    WarnLabel.Size = UDim2.new(0, 200, 0, 30); -- Fixed size
    WarnLabel.Position = UDim2.new(0.5, -100, 0.85, 0); -- Centered, slightly higher
    WarnLabel.BackgroundTransparency = 1;
    WarnLabel.Font = Enum.Font.GothamSemibold;
    WarnLabel.TextSize = 24; -- Adjusted size
    WarnLabel.TextColor3 = Color3.fromRGB(255, 255, 0); -- Yellow warning color
    WarnLabel.TextStrokeTransparency = 0.5;
    WarnLabel.ZIndex = 10; -- Ensure it's visible


    local function Grounded()
        -- Check if Humanoid exists and is part of the workspace before checking FloorMaterial
        return Humanoid and Humanoid:IsDescendantOf(workspace) and Humanoid.FloorMaterial ~= Enum.Material.Air;
    end

    local function LoadAndPrepareTrack()
        if Track then -- Stop existing track if it exists
             pcall(function() Track:Stop() end)
             Track = nil
        end
        if Humanoid then -- Ensure Humanoid is valid
            local success, result = pcall(function()
                return Humanoid:LoadAnimation(Animation)
            end)
            if success then
                Track = result
                Track.Priority = Enum.AnimationPriority.Action4;
            else
                Track = nil -- Ensure track is nil if loading failed
            end
        else
             Track = nil
        end
    end

    local function Invis_Disable()
        if not InvisEnabled then return end -- Already disabled
        InvisEnabled = false;

        if Track then -- Stop the animation if it exists and is playing
             pcall(function() Track:Stop() end)
             -- Track = nil -- Keep track loaded unless character changes
        end

        -- Restore camera subject only if Humanoid is valid
        if Humanoid then
            workspace.CurrentCamera.CameraSubject = Humanoid;
        end

        -- Reset transparency (check if Character is valid)
        if Character then
            for _, v in pairs(Character:GetDescendants()) do
                if v:IsA("BasePart") and v.Transparency == 0.5 then
                    v.Transparency = 0;
                end
            end
        end

        WarnLabel.Visible = false; -- Hide warning label
    end

    local function Invis_Enable()
        if InvisEnabled or not Invis_Fixed then return end -- Already enabled or incompatible (R15)

        -- Ensure character references are up-to-date and valid
        UpdateCharacterReferences()
        if not Character or not Humanoid or not HumanoidRootPart then
             return
        end
        if not Character:FindFirstChild("Torso") then -- Double check for R6
            pcall(function() StarterGui:SetCore("SendNotification", {Title = "Invisibility FAILED", Text = "Feature requires R6 Avatar.", Duration = 5}) end)
            return
        end


        InvisEnabled = true;
        workspace.CurrentCamera.CameraSubject = HumanoidRootPart; -- Change camera subject

        LoadAndPrepareTrack() -- Load/Reload the animation track

    end

    -- Handle character changes
    Player.CharacterAdded:Connect(function(NewCharacter)
        -- Stop old track if necessary
        if Track then
            pcall(function() Track:Stop() end)
            Track = nil
        end

        -- Poczekaj bardzo kr√≥tko, aby daƒá czas na za≈Çadowanie podstawowych element√≥w
        task.wait() -- Daje silnikowi jeden cykl na aktualizacjƒô

        UpdateCharacterReferences() -- Update refs to the new character

        -- SPRAWDZENIE R6/R15 - Najpierw upewnij siƒô, ≈ºe Humanoid istnieje
        if not Humanoid then
             -- Mo≈ºna dodaƒá d≈Çu≈ºsze oczekiwanie, je≈õli Humanoid pojawia siƒô z op√≥≈∫nieniem
             task.wait(0.5) -- Dodatkowe oczekiwanie
             UpdateCharacterReferences() -- Spr√≥buj ponownie
             if not Humanoid then
                  -- Zdecyduj co robiƒá - na razie zablokujemy, aby uniknƒÖƒá b≈Çƒôd√≥w
                  Invis_Fixed = false
                  if InvisEnabled then Invis_Disable() end
                  pcall(function() StarterGui:SetCore("SendNotification", {Title = "Invisibility Error", Text = "Could not verify character type.", Duration = 5}) end)
                  return
             end
        end

        -- Teraz sprawd≈∫ RigType
        if Humanoid.RigType ~= Enum.HumanoidRigType.R6 then
            Invis_Fixed = false
            if InvisEnabled then Invis_Disable() end -- Disable if it was active
            pcall(function() StarterGui:SetCore("SendNotification", {Title = "Invisibility Warning", Text = "Non-R6 Avatar detected (".. tostring(Humanoid.RigType) .."). Invisibility disabled.", Duration = 5}) end)
            return
        else
            -- WyglƒÖda na to, ≈ºe jest R6
            Invis_Fixed = true -- Mark as compatible again
        end

        -- Je≈õli niewidzialno≈õƒá ma przetrwaƒá respawn, w≈ÇƒÖcz jƒÖ ponownie
        if InvisEnabled then
            if HumanoidRootPart then -- Upewnij siƒô, ≈ºe HRP istnieje przed zmianƒÖ kamery
                 workspace.CurrentCamera.CameraSubject = HumanoidRootPart -- Ensure camera subject is correct
            else
                 -- Mo≈ºna spr√≥bowaƒá poczekaƒá na HRP lub zrezygnowaƒá z ustawiania kamery
            end
            LoadAndPrepareTrack() -- Za≈Çaduj animacjƒô na nowy humanoid
            -- Pƒôtla Heartbeat zajmie siƒô resztƒÖ
        end
    end)

    Player.CharacterRemoving:Connect(function(OldCharacter)
         if Track then
             pcall(function() Track:Stop() end)
             Track = nil
         end
         -- Don't disable InvisEnabled here, let CharacterAdded handle re-enabling if needed
         WarnLabel.Visible = false -- Hide warning as character is gone
    end)


    -- Main loop
    Heartbeat:Connect(function(_)
        -- Early exit conditions
        if not InvisEnabled or not Invis_Fixed then
            -- Ensure transparency is reset if script disabled unexpectedly while parts were transparent
            if not InvisEnabled and Character then
                 for _, v in pairs(Character:GetDescendants()) do
                      if v:IsA("BasePart") and v.Transparency == 0.5 then v.Transparency = 0 end
                 end
            end
            WarnLabel.Visible = false -- Keep label hidden if not active
            return;
        end

        -- Check character validity *inside* the loop - CRITICAL for reset safety
        if not Character or not Humanoid or not HumanoidRootPart or not Humanoid:IsDescendantOf(workspace) or Humanoid.Health <= 0 then
            WarnLabel.Visible = false; -- Hide warning if character is invalid/dead
            -- Don't disable InvisEnabled here, CharacterAdded/Removing handles state persistence
            return
        end

        -- Grounded check and warning label
        WarnLabel.Visible = not Grounded();

        -- Store originals
        local OldCFrame = HumanoidRootPart.CFrame;
        local OldCameraOffset = Humanoid.CameraOffset;

        -- Apply transformations
        local _, y = workspace.CurrentCamera.CFrame:ToOrientation();
        HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.CFrame.Position) * CFrame.fromOrientation(0, y, 0);
        HumanoidRootPart.CFrame = HumanoidRootPart.CFrame * CFrame.Angles(math.rad(90), 0, 0);
        Humanoid.CameraOffset = Vector3.new(0, 1.44, 0);

        -- Play/Adjust Animation Track (Check if Track is valid!)
        if Track then
            local successPlay, errPlay = pcall(function()
                if not Track.IsPlaying then
                     Track:Play();
                end
                 Track:AdjustSpeed(0);
                 Track.TimePosition = 0.3;
            end)
             if not successPlay then
                 -- Attempt to reload track if it seems broken
                 LoadAndPrepareTrack()
             end
        elseif Humanoid and Humanoid.Health > 0 then -- Attempt to load if missing and alive
             LoadAndPrepareTrack()
        end

        -- Wait for render
        RenderStepped:Wait();

        -- Revert transformations (check validity again just in case)
        if Humanoid and Humanoid:IsDescendantOf(workspace) then
             Humanoid.CameraOffset = OldCameraOffset;
        end
        if HumanoidRootPart and HumanoidRootPart:IsDescendantOf(workspace) then
             HumanoidRootPart.CFrame = OldCFrame;
        end

        -- Stop animation track (Check if Track is valid!)
        if Track then
            local successStop, errStop = pcall(function() Track:Stop() end)
             if not successStop then
             end
        end

        -- Re-orient character to camera
        if HumanoidRootPart and HumanoidRootPart:IsDescendantOf(workspace) then
             local LookVector = workspace.CurrentCamera.CFrame.LookVector;
             local Horizontal = Vector3.new(LookVector.X, 0, LookVector.Z).Unit;
             if Horizontal.Magnitude > 0.1 then -- Avoid setting to NaN if looking straight up/down
                 local TargetCFrame = CFrame.new(HumanoidRootPart.Position, HumanoidRootPart.Position + Horizontal);
                 HumanoidRootPart.CFrame = TargetCFrame;
             end
        end

        -- Apply transparency (Check Character validity)
        if Character then
             for _, v in pairs(Character:GetDescendants()) do
                 if (v:IsA("BasePart") and v.Transparency ~= 1) then
                     v.Transparency = 0.5;
                 end
             end
        end
    end)

    -- Expose Enable/Disable functions globally if needed by the UI
    -- These need to be defined *after* the internal functions they call
    _G.Invis_Enable = Invis_Enable -- Or use the method your UI framework expects
    _G.Invis_Disable = Invis_Disable
    _G.IsInvisEnabled = function() return InvisEnabled end -- Function for UI state checking

end -- End of invisibility 'do' block
-------------------------------------------------------------------------------

--[[
Remember to replace the Invisibility entry in your UI creation section (categoryFrames.Visuals)
to use these corrected functions, for example:

table.insert(categoryFrames.Visuals,
    createToggleRowFrame(" Invisibility", true, _G.IsInvisEnabled, _G.Invis_Enable, _G.Invis_Disable, function() return invisBind_local end, function(k) invisBind_local=k end)
)
]]


--================= 3 Save-Places =================--
local event_save=DeathRespawn_Event
local SaveCube_Enabled=false; local SaveCube_Connection; local SaveCube_Position=Vector3.new(-4597,-152,-1326);
local function SaveCube_Enable()
    if SaveCube_Enabled then return end; SaveCube_Enabled=true
    local killpart=workspace.Filter.Parts:FindFirstChild("Kill_Brick"); if killpart then killpart:Destroy() end
    SaveCube_Connection=RunService.RenderStepped:Connect(function()
        if not SaveCube_Enabled then return end; local char=LocalPlayer.Character; if not char then return end
        local hrp=char:FindFirstChild("HumanoidRootPart"); local hum=char:FindFirstChildOfClass("Humanoid")
        if hrp then hrp.CFrame=CFrame.new(SaveCube_Position) end
        local tool=LocalPlayer.Backpack:FindFirstChildOfClass("Tool"); if tool and tool.Parent~=char then wait(1); tool.Parent=char end
        if hum and hum.Health<=0 then event_save:InvokeServer("KMG4R904") end
    end)
end
local function SaveCube_Disable()
    if not SaveCube_Enabled then return end; SaveCube_Enabled=false
    if SaveCube_Connection then SaveCube_Connection:Disconnect(); SaveCube_Connection=nil end
end

local SaveSewers_Enabled=false; local SaveSewers_Connection; local SaveSewers_Position=Vector3.new(-4162,-84,-498);
local function SaveSewers_Enable()
    if SaveSewers_Enabled then return end; SaveSewers_Enabled=true
    local killpart=workspace.Filter.Parts:FindFirstChild("Kill_Brick"); if killpart then killpart:Destroy() end
    SaveSewers_Connection=RunService.RenderStepped:Connect(function()
        if not SaveSewers_Enabled then return end; local char=LocalPlayer.Character; if not char then return end
        local hrp=char:FindFirstChild("HumanoidRootPart"); local hum=char:FindFirstChildOfClass("Humanoid")
        if hrp then hrp.CFrame=CFrame.new(SaveSewers_Position) end
        local tool=LocalPlayer.Backpack:FindFirstChildOfClass("Tool"); if tool and tool.Parent~=char then wait(1); tool.Parent=char end
        if hum and hum.Health<=0 then event_save:InvokeServer("KMG4R904") end
    end)
end
local function SaveSewers_Disable()
    if not SaveSewers_Enabled then return end; SaveSewers_Enabled=false
    if SaveSewers_Connection then SaveSewers_Connection:Disconnect(); SaveSewers_Connection=nil end
end

local SaveVibe_Enabled=false; local SaveVibe_Connection; local SaveVibe_Position=Vector3.new(-4805,-201,-855);
local function SaveVibe_Enable()
    if SaveVibe_Enabled then return end; SaveVibe_Enabled=true
    local killpart=workspace.Filter.Parts:FindFirstChild("Kill_Brick"); if killpart then killpart:Destroy() end
    SaveVibe_Connection=RunService.RenderStepped:Connect(function()
        if not SaveVibe_Enabled then return end; local char=LocalPlayer.Character; if not char then return end
        local hrp=char:FindFirstChild("HumanoidRootPart"); local hum=char:FindFirstChildOfClass("Humanoid")
        if hrp then hrp.CFrame=CFrame.new(SaveVibe_Position) end
        local tool=LocalPlayer.Backpack:FindFirstChildOfClass("Tool"); if tool and tool.Parent~=char then wait(1); tool.Parent=char end
        if hum and hum.Health<=0 then event_save:InvokeServer("KMG4R904") end
    end)
end
local function SaveVibe_Disable()
    if not SaveVibe_Enabled then return end; SaveVibe_Enabled=false
    if SaveVibe_Connection then SaveVibe_Connection:Disconnect(); SaveVibe_Connection=nil end
end


--======================= NO RECOIL =========================--
local NoRecoil_Enabled=false
local NoRecoil_Connections={}
local GlobalOriginalValues={}
local WeaponCache={}
local Settings={GunMods={NoRecoil=true,Spread=true,SpreadAmount=0}}
local Player_nr=LocalPlayer

local function cacheWeapons()
    WeaponCache={};
    for _, v in pairs(getgc(true)) do
        if type(v)=='table' and rawget(v,'EquipTime') then
            table.insert(WeaponCache, v);
            if not GlobalOriginalValues[v] then
                GlobalOriginalValues[v]={
                    Recoil=v.Recoil,CameraRecoilingEnabled=v.CameraRecoilingEnabled,
                    AngleX_Min=v.AngleX_Min,AngleX_Max=v.AngleX_Max,
                    AngleY_Min=v.AngleY_Min,AngleY_Max=v.AngleY_Max,
                    AngleZ_Min=v.AngleZ_Min,AngleZ_Max=v.AngleZ_Max,
                    Spread=v.Spread
                }
            end
        end
    end
end

local function applyGunMods()
    for _, weapon in ipairs(WeaponCache) do
        if Settings.GunMods.NoRecoil then
            weapon.Recoil=0; weapon.CameraRecoilingEnabled=false;
            weapon.AngleX_Min=0; weapon.AngleX_Max=0;
            weapon.AngleY_Min=0; weapon.AngleY_Max=0;
            weapon.AngleZ_Min=0; weapon.AngleZ_Max=0;
        end;
        if Settings.GunMods.Spread then
            weapon.Spread=Settings.GunMods.SpreadAmount
        end
    end
end

local function resetGunMods()
    for weapon, values in pairs(GlobalOriginalValues) do
        weapon.Recoil=values.Recoil; weapon.CameraRecoilingEnabled=values.CameraRecoilingEnabled;
        weapon.AngleX_Min=values.AngleX_Min; weapon.AngleX_Max=values.AngleX_Max;
        weapon.AngleY_Min=values.AngleY_Min; weapon.AngleY_Max=values.AngleY_Max;
        weapon.AngleZ_Min=values.AngleZ_Min; weapon.AngleZ_Max=values.AngleZ_Max;
        weapon.Spread=values.Spread;
    end
end

local function handleWeapon(weapon)
    if NoRecoil_Enabled then
        task.wait(0.1);
        cacheWeapons();
        applyGunMods()
    end
end

local function onCharacterAdded_nr(character)
    for _, child in ipairs(character:GetChildren()) do if child:IsA("Tool") then handleWeapon(child) end end;
    table.insert(NoRecoil_Connections, character.ChildAdded:Connect(function(child) if child:IsA("Tool") then handleWeapon(child) end end));
    local humanoid=character:WaitForChild("Humanoid",2);
    if humanoid then
        table.insert(NoRecoil_Connections, humanoid.Died:Connect(function() if NoRecoil_Enabled then task.wait(1.5); cacheWeapons(); applyGunMods() end end))
    end
end

function NoRecoil_Enable()
    if NoRecoil_Enabled then return end;
    NoRecoil_Enabled=true;
    cacheWeapons();
    applyGunMods();
    table.insert(NoRecoil_Connections, Player_nr.CharacterAdded:Connect(onCharacterAdded_nr));
    if Player_nr.Character then onCharacterAdded_nr(Player_nr.Character) end
end

function NoRecoil_Disable()
    if not NoRecoil_Enabled then return end;
    NoRecoil_Enabled=false;
    resetGunMods();
    for _, conn in ipairs(NoRecoil_Connections) do conn:Disconnect() end;
    NoRecoil_Connections={};
end


--======================= WALLHACK (ESP) =========================--
local ESP_Enabled=false
local ESP_Loading=false
local LastToggleTime=0
local DEBOUNCE_TIME=0.5

function ESP_Enable()
    if os.clock()-LastToggleTime<DEBOUNCE_TIME then return end; LastToggleTime=os.clock();
    if ESP_Loading or ESP_Enabled then return end;
    ESP_Loading=true;
    local success, err=pcall(function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/milokoxdxd/testest/refs/heads/main/widoczno≈õƒáprzez≈õciany", true))();
        ESP_Enabled=true;
        ESP_Loading=false
    end);
    if not success then
        warn("B≈ÇƒÖd ≈Çadowania ESP: "..tostring(err));
        ESP_Loading=false;
        ESP_Enabled=false;
    end
end

function ESP_Disable()
    if os.clock()-LastToggleTime<DEBOUNCE_TIME then return end; LastToggleTime=os.clock();
    if not ESP_Enabled then return end;
    ESP_Enabled=false;
    local coreGui=game:GetService("CoreGui");
    for _, name in pairs({"Folder","ESP_Holder","ESP_Folder","ESP"}) do
        local folder=coreGui:FindFirstChild(name);
        if folder then folder:Destroy() end
    end
end


-------------------------------------------------------------------------------
--  5. Funkcja tworzenia wiersza przycisku (createToggleRowFrame)
--     + Zmienne Globalne dla Bind√≥w + Poprawka Hover Koloru
-------------------------------------------------------------------------------
local buttonHoverColor = Color3.fromRGB(40, 40, 50)
local buttonColor = Color3.fromRGB(25, 25, 30)
local buttonStrokeColor = Color3.fromRGB(60, 60, 75)
local buttonTextColor = Color3.fromRGB(210, 210, 210)
local buttonOnColor = Color3.fromRGB(70, 180, 100)
local buttonOffColor = Color3.fromRGB(200, 80, 80)
local bindButtonColor = Color3.fromRGB(45, 45, 55)
local bindButtonHoverColor = Color3.fromRGB(60, 60, 75)

-- === Zmienne globalne do obs≈Çugi bind√≥w ===
local activeBinds = {} -- S≈Çownik: [Enum.KeyCode] = { frame, toggleButton, isEnabledFn, onEnable, onDisable, canToggle, updateFn }
local currentRowWaitingForKey = nil
local bindButtonReferences = {}
local keyBindGetters = {}
local keyBindSetters = {}
local toggleButtonTweens = {} -- Dla poprawki hover
local rowFunctionData = {} -- NOWA TABELA: Przechowuje statyczne funkcje dla ka≈ºdej ramki

-- === Funkcja tworzƒÖca wiersz ===
local function createToggleRowFrame(scriptName, canToggle, isEnabledFn, onEnable, onDisable, getKeyBindFn, setKeyBindFn)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, -20, 0, 35)
    frame.BackgroundTransparency = 1
    frame.Name = scriptName:gsub("%s+", "")

    local horizontalLayout = Instance.new("UIListLayout")
    horizontalLayout.FillDirection = Enum.FillDirection.Horizontal
    horizontalLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    horizontalLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    horizontalLayout.SortOrder = Enum.SortOrder.LayoutOrder
    horizontalLayout.Padding = UDim.new(0, 5)
    horizontalLayout.Parent = frame

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0.45, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = " " .. scriptName
    label.TextColor3 = buttonTextColor
    label.Font = Enum.Font.GothamSemibold
    label.TextSize = 14
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.LayoutOrder = 1
    label.Parent = frame

    local toggleButton = Instance.new("TextButton")
    toggleButton.Size = UDim2.new(0.25, 0, 0.8, 0)
    toggleButton.Font = Enum.Font.GothamBold
    toggleButton.TextSize = 12
    toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleButton.BackgroundColor3 = buttonColor
    toggleButton.BorderSizePixel = 0
    toggleButton.AutoButtonColor = false
    toggleButton.LayoutOrder = 2
    toggleButton.Parent = frame

    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(0, 6)
    toggleCorner.Parent = toggleButton
    local toggleStroke = Instance.new("UIStroke")
    toggleStroke.Color = buttonStrokeColor
    toggleStroke.Thickness = 1
    toggleStroke.Parent = toggleButton

    local bindButton = nil

    -- Definicja funkcji update MUSI byƒá przed jej u≈ºyciem w zapisie do rowFunctionData
    local updateToggleButtonVisuals -- Deklaracja wstƒôpna

    -- Funkcja do okre≈õlania docelowego koloru przycisku toggle
    local function getTargetToggleColor()
        local enabledState = false
        if type(isEnabledFn) == 'function' then
            local success, result = pcall(isEnabledFn)
            if success then enabledState = result end
        end
        if not canToggle then return Color3.fromRGB(80, 120, 220)
        elseif enabledState then return buttonOnColor
        else return buttonOffColor
        end
    end

    -- Funkcja aktualizujƒÖca wyglƒÖd (tekst + kolor) - definicja
    updateToggleButtonVisuals = function()
        local enabledState = false
        if type(isEnabledFn) == 'function' then
            local success, result = pcall(isEnabledFn)
            if success then enabledState = result else warn("Error in isEnabledFn for", scriptName, ":", result) end
        else warn("isEnabledFn is not a function for", scriptName) end

        if scriptName == " Invisibility" then end

        local targetColor
        if not canToggle then toggleButton.Text = "RUN"; targetColor = Color3.fromRGB(80, 120, 220);
        elseif enabledState then toggleButton.Text = "ON"; targetColor = buttonOnColor
        else toggleButton.Text = "OFF"; targetColor = buttonOffColor
        end

        if toggleButtonTweens[toggleButton] then toggleButtonTweens[toggleButton]:Cancel(); toggleButtonTweens[toggleButton] = nil end
        toggleButton.BackgroundColor3 = targetColor
    end

    -- Zapisz dane funkcji dla tej ramki (NOWA TABELA)
    rowFunctionData[frame] = {
        isEnabledFn = isEnabledFn,
        onEnable = onEnable,
        onDisable = onDisable,
        canToggle = canToggle,
        updateFn = updateToggleButtonVisuals -- Zapisz referencjƒô do lokalnej funkcji update
    }

    -- Przycisk Bind
    if getKeyBindFn and setKeyBindFn then
        bindButton = Instance.new("TextButton")
        bindButton.Size = UDim2.new(0.25, 0, 0.8, 0)
        bindButton.Font = Enum.Font.GothamMedium
        bindButton.TextSize = 12
        bindButton.TextColor3 = buttonTextColor
        bindButton.BackgroundColor3 = bindButtonColor
        bindButton.BorderSizePixel = 0
        bindButton.AutoButtonColor = false
        bindButton.LayoutOrder = 3
        bindButton.Parent = frame

        local bindCorner = Instance.new("UICorner"); bindCorner.CornerRadius = UDim.new(0, 6); bindCorner.Parent = bindButton
        local bindStroke = Instance.new("UIStroke"); bindStroke.Color = buttonStrokeColor; bindStroke.Thickness = 1; bindStroke.Parent = bindButton

        bindButtonReferences[frame] = bindButton
        keyBindGetters[frame] = getKeyBindFn
        keyBindSetters[frame] = setKeyBindFn

        -- Dodaj poczƒÖtkowy wpis do activeBinds, je≈õli klawisz jest ju≈º ustawiony
        local initialKey = nil
        local success, result = pcall(getKeyBindFn)
        if success and result and typeof(result)=="EnumItem" then
            initialKey = result
            -- Zapisz PE≈ÅNƒÑ informacjƒô pobranƒÖ z rowFunctionData
            if rowFunctionData[frame] then
                activeBinds[initialKey] = {
                    frame = frame,
                    toggleButton = toggleButton,
                    isEnabledFn = rowFunctionData[frame].isEnabledFn,
                    onEnable = rowFunctionData[frame].onEnable,
                    onDisable = rowFunctionData[frame].onDisable,
                    canToggle = rowFunctionData[frame].canToggle,
                    updateFn = rowFunctionData[frame].updateFn
                }
            end
        end
    else
        toggleButton.Size = UDim2.new(0.5, 0, 0.8, 0)
        horizontalLayout.Padding = UDim.new(0, 10)
    end

    -- Funkcja aktualizujƒÖca tekst przycisku bind
    local function updateBindButtonText()
        if not bindButton then return end
        local kb = nil
        if type(getKeyBindFn) == 'function' then
            local success, result = pcall(getKeyBindFn)
            if success then kb = result else warn("Error in getKeyBindFn for", scriptName, ":", result) end
        end
        bindButton.Text = kb and typeof(kb)=="EnumItem" and kb.Name~="Unknown" and "["..kb.Name.."]" or "Bind"
    end

    -- PoczƒÖtkowa aktualizacja wyglƒÖdu
    updateToggleButtonVisuals()
    updateBindButtonText()

    -- Poprawiona logika hover dla Toggle Button
    toggleButton.MouseEnter:Connect(function()
        if toggleButtonTweens[toggleButton] then toggleButtonTweens[toggleButton]:Cancel() end
        local targetColor = getTargetToggleColor()
        local hoverTargetColor = targetColor:Lerp(Color3.new(1, 1, 1), 0.2)
        local tween = TweenService:Create(toggleButton, TweenInfo.new(0.1), { BackgroundColor3 = hoverTargetColor })
        toggleButtonTweens[toggleButton] = tween
        tween:Play()
    end)
    toggleButton.MouseLeave:Connect(function()
        if toggleButtonTweens[toggleButton] then toggleButtonTweens[toggleButton]:Cancel() end
        local targetColor = getTargetToggleColor()
        local tween = TweenService:Create(toggleButton, TweenInfo.new(0.1), { BackgroundColor3 = targetColor })
        toggleButtonTweens[toggleButton] = tween
        tween:Play()
    end)

    -- Logika hover dla przycisku Bind
    if bindButton then
        bindButton.MouseEnter:Connect(function() TweenService:Create(bindButton, TweenInfo.new(0.1), { BackgroundColor3 = bindButtonHoverColor }):Play() end)
        bindButton.MouseLeave:Connect(function() TweenService:Create(bindButton, TweenInfo.new(0.1), { BackgroundColor3 = bindButtonColor }):Play() end)

        -- Logika klikniƒôcia przycisku Bind (ustawia flagƒô globalnƒÖ)
        local capturingKey = false
        bindButton.MouseButton1Click:Connect(function()
            if currentRowWaitingForKey and currentRowWaitingForKey ~= frame then
                local prevBindButton=bindButtonReferences[currentRowWaitingForKey]
                if prevBindButton then
                    local getter=keyBindGetters[currentRowWaitingForKey]
                    local prevKeyText="Bind"; if getter then local s,r=pcall(getter); if s and r and typeof(r)=="EnumItem" then prevKeyText="["..r.Name.."]" end end
                    prevBindButton.Text=prevKeyText
                end
            end
            if capturingKey then
                capturingKey=false; updateBindButtonText(); currentRowWaitingForKey=nil
            else
                capturingKey=true; bindButton.Text="..."; currentRowWaitingForKey=frame
                task.delay(5, function() if capturingKey and currentRowWaitingForKey==frame then capturingKey=false; updateBindButtonText(); currentRowWaitingForKey=nil end end)
            end
        end)
    end

    -- Logika klikniƒôcia przycisku Toggle
    toggleButton.MouseButton1Click:Connect(function()
        local enabledState = false; if type(isEnabledFn)=='function' then local s,r=pcall(isEnabledFn); if s then enabledState=r end end
        if not canToggle then if type(onEnable)=='function' then pcall(onEnable) else warn("onEnable is not a function for",scriptName) end; toggleButton.Text="DONE"; toggleButton.BackgroundColor3=buttonOnColor:Lerp(Color3.fromRGB(15,15,20),0.3); toggleButton.Active=false; if bindButton then bindButton.Active=false end; return end
        if enabledState then if type(onDisable)=='function' then pcall(onDisable) else warn("onDisable is not a function for",scriptName) end else if type(onEnable)=='function' then pcall(onEnable) else warn("onEnable is not a function for",scriptName) end end
        updateToggleButtonVisuals()
    end)

    return frame
end


-- Zmodernizowana wersja createTPFarmTargetRow (Oryginalny komentarz)
local function createTPFarmTargetRowFrame()
    local frame = Instance.new("Frame")
    frame.Size=UDim2.new(1,-20,0,35)
    frame.BackgroundTransparency=1
    frame.Name="TPFarmTarget"

    local label = Instance.new("TextLabel")
    label.Size=UDim2.new(0.4,0,1,0)
    label.BackgroundTransparency=1
    label.Text="  TP Target:"
    label.TextColor3=buttonTextColor
    label.Font=Enum.Font.GothamSemibold
    label.TextSize=14
    label.TextXAlignment=Enum.TextXAlignment.Left
    label.Parent=frame

    local inputContainer = Instance.new("Frame")
    inputContainer.Size=UDim2.new(0.6,-5,0.8,0)
    inputContainer.Position=UDim2.new(0.4,5,0.1,0)
    inputContainer.BackgroundColor3=buttonColor
    inputContainer.BorderSizePixel=0
    inputContainer.Parent=frame

    local inputCorner = Instance.new("UICorner")
    inputCorner.CornerRadius=UDim.new(0,6)
    inputCorner.Parent=inputContainer
    local inputStroke = Instance.new("UIStroke")
    inputStroke.Color=buttonStrokeColor
    inputStroke.Thickness=1
    inputStroke.Parent=inputContainer

    local input = Instance.new("TextBox")
    input.Size=UDim2.new(1,-10,1,-4)
    input.Position=UDim2.new(0,5,0,2)
    input.BackgroundTransparency=1
    input.TextColor3=Color3.new(1,1,1)
    input.Font=Enum.Font.Gotham
    input.TextSize=12
    input.Text=TPFarm_TargetName -- U≈ºyj ORYGINALNEJ zmiennej
    input.PlaceholderText="Enter Nickname..."
    input.ClearTextOnFocus=false
    input.Parent=inputContainer

    input.FocusLost:Connect(function(enterPressed)
        TPFarm_TargetName=input.Text -- Aktualizuj ORYGINALNƒÑ zmiennƒÖ
    end)

    inputContainer.MouseEnter:Connect(function()
        TweenService:Create(inputContainer,TweenInfo.new(0.1),{BackgroundColor3=buttonHoverColor}):Play()
    end)
    inputContainer.MouseLeave:Connect(function()
        TweenService:Create(inputContainer,TweenInfo.new(0.1),{BackgroundColor3=buttonColor}):Play()
    end)
    return frame
end
-- Funkcja tworzƒÖca wiersz z przyciskiem akcji
local function createActionButtonFrame(labelText, buttonText, actionFunction)
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(1, -20, 0, 35)
	frame.BackgroundTransparency = 1
	frame.Name = labelText:gsub("%s+", "") .. "Action"

	local horizontalLayout = Instance.new("UIListLayout")
	horizontalLayout.FillDirection = Enum.FillDirection.Horizontal
	horizontalLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	horizontalLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	horizontalLayout.SortOrder = Enum.SortOrder.LayoutOrder
	horizontalLayout.Padding = UDim.new(0, 10) -- Dostosuj padding
	horizontalLayout.Parent = frame

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(0.45, 0, 1, 0) -- Dostosuj szeroko≈õƒá labelki
	label.BackgroundTransparency = 1
	label.Text = " " .. labelText
	label.TextColor3 = buttonTextColor
	label.Font = Enum.Font.GothamSemibold
	label.TextSize = 14
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.LayoutOrder = 1
	label.Parent = frame

	local actionButton = Instance.new("TextButton")
	actionButton.Size = UDim2.new(0.5, 0, 0.8, 0) -- Dostosuj szeroko≈õƒá przycisku
	actionButton.Font = Enum.Font.GothamBold
	actionButton.TextSize = 12
	actionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	actionButton.Text = buttonText
	actionButton.BackgroundColor3 = buttonColor -- Kolor jak toggle OFF
	actionButton.BorderSizePixel = 0
	actionButton.AutoButtonColor = false
	actionButton.LayoutOrder = 2
	actionButton.Parent = frame

	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 6)
	btnCorner.Parent = actionButton
	local btnStroke = Instance.new("UIStroke")
	btnStroke.Color = buttonStrokeColor
	btnStroke.Thickness = 1
	btnStroke.Parent = actionButton

	-- Logika hover
	actionButton.MouseEnter:Connect(function()
		TweenService:Create(actionButton, TweenInfo.new(0.1), { BackgroundColor3 = buttonHoverColor }):Play()
	end)
	actionButton.MouseLeave:Connect(function()
		TweenService:Create(actionButton, TweenInfo.new(0.1), { BackgroundColor3 = buttonColor }):Play()
	end)

	-- Logika klikniƒôcia
	actionButton.MouseButton1Click:Connect(function()
		if actionFunction and typeof(actionFunction) == 'function' then
			local success, err = pcall(actionFunction) -- Bezpieczne wywo≈Çanie funkcji akcji
            if not success then
                 warn("Error in action button function for '"..labelText.."':", err)
            end
            -- Opcjonalna zmiana wyglƒÖdu po klikniƒôciu, np. chwilowa zmiana koloru
            local originalColor = actionButton.BackgroundColor3
            actionButton.BackgroundColor3 = buttonOnColor -- Chwilowo zielony
            task.wait(0.2)
            actionButton.BackgroundColor3 = originalColor -- Powr√≥t do normalnego
		end
	end)

	return frame
end


-------------------------------------------------------------------------------
--  6. Definicje Kategorii i Tworzenie Przycisk√≥w Kategorii
-------------------------------------------------------------------------------
local categories = { "Combat", "Movement", "Visuals", "Farming", "Misc", "Rage" }
local categoryButtons = {}
local categoryFrames = {} -- Tabela przechowujƒÖca ramki dla ka≈ºdej kategorii
local activeCategoryButton = nil
local defaultCategory = "Combat" -- Mo≈ºesz zmieniƒá domy≈õlnƒÖ kategoriƒô

local function switchCategory(categoryName)
    local categoryButton = categoryButtons[categoryName]
    if not categoryButton or categoryButton == activeCategoryButton then
        return
    end

    -- Zresetuj poprzedni aktywny przycisk
    if activeCategoryButton then
        TweenService:Create(activeCategoryButton, TweenInfo.new(0.2), { BackgroundColor3 = Color3.fromRGB(20, 20, 25) }):Play()
        activeCategoryButton.TextLabel.TextColor3 = Color3.fromRGB(180, 180, 190)
    end

    -- Ustaw nowy aktywny przycisk
    TweenService:Create(categoryButton, TweenInfo.new(0.2), { BackgroundColor3 = Color3.fromRGB(40, 40, 50) }):Play()
    categoryButton.TextLabel.TextColor3 = Color3.fromRGB(230, 230, 230)
    activeCategoryButton = categoryButton

    -- Wyczy≈õƒá contentFrame
    for _, child in ipairs(contentFrame:GetChildren()) do
        if child:IsA("Frame") and child.Name ~= "UIListLayout" and child.Name ~= "UICorner" then
            child.Parent = nil -- Usu≈Ñ z widoku
        end
    end

    -- Dodaj ramki z nowej kategorii
    if categoryFrames[categoryName] then
        for i, frame in ipairs(categoryFrames[categoryName]) do
            frame.Parent = contentFrame -- Dodaj do widoku
            frame.LayoutOrder = i -- Ustaw kolejno≈õƒá dla UIListLayout
        end
        -- Zaktualizuj CanvasSize dla przewijania
        local numItems = #categoryFrames[categoryName]
        local itemHeight = 35 -- Wysoko≈õƒá jednej ramki (z createToggleRowFrame)
        local padding = contentLayout.Padding.Offset
        contentFrame.CanvasSize = UDim2.new(0, 0, 0, numItems * itemHeight + (numItems > 0 and (numItems - 1) * padding or 0) + 10) -- Dodatkowy padding na dole
    else
        contentFrame.CanvasSize = UDim2.new(0, 0, 0, 0) -- Zeruj, je≈õli kategoria pusta
    end
end

-- Tworzenie przycisk√≥w kategorii w sidebarze
for i, categoryName in ipairs(categories) do
    categoryFrames[categoryName] = {} -- Inicjalizuj pustƒÖ listƒô ramek dla kategorii

    local catButton = Instance.new("TextButton")
    catButton.Name = categoryName .. "Button"
    catButton.Size = UDim2.new(1, -10, 0, 30)
    catButton.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    catButton.BorderSizePixel = 0
    catButton.AutoButtonColor = false
    catButton.LayoutOrder = i
    catButton.Parent = sidebarFrame

    local catCorner = Instance.new("UICorner")
    catCorner.CornerRadius = UDim.new(0, 6)
    catCorner.Parent = catButton

    local catLabel = Instance.new("TextLabel")
    catLabel.Name = "TextLabel"
    catLabel.Size = UDim2.new(1, 0, 1, 0)
    catLabel.BackgroundTransparency = 1
    catLabel.Text = categoryName
    catLabel.Font = Enum.Font.GothamSemibold
    catLabel.TextSize = 14
    catLabel.TextColor3 = Color3.fromRGB(180, 180, 190)
    catLabel.Parent = catButton

    -- Animacje i klikniƒôcie
    catButton.MouseEnter:Connect(function()
        if catButton ~= activeCategoryButton then
            TweenService:Create(catButton, TweenInfo.new(0.1), { BackgroundColor3 = Color3.fromRGB(30, 30, 35) }):Play()
        end
    end)
    catButton.MouseLeave:Connect(function()
        if catButton ~= activeCategoryButton then
            TweenService:Create(catButton, TweenInfo.new(0.1), { BackgroundColor3 = Color3.fromRGB(20, 20, 25) }):Play()
        end
    end)
    catButton.MouseButton1Click:Connect(function()
        switchCategory(categoryName)
    end)

    categoryButtons[categoryName] = catButton -- Zapisz referencjƒô do przycisku
end


-------------------------------------------------------------------------------
--  7. –°–æ–∑–¥–∞—ë–º –∫–Ω–æ–ø–∫–∏ –≤ –Ω—É–∂–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ (Oryginalny komentarz)
--     Tworzenie Ramek dla Funkcji i Dodawanie do Kategorii (U≈ºywa ORYGINALNYCH funkcji)
-------------------------------------------------------------------------------

-- Lokalne zmienne do przechowywania warto≈õci bind√≥w (dla getter√≥w/setter√≥w)
local keyBinds = {
    fly = Fly_Bind, -- Inicjalizuj warto≈õciƒÖ, je≈õli jest potrzebna od razu
    autoPickupMoney = nil,
    adminCheck = nil,
    melee = nil,
    tpFarm = nil, -- Zmieniono nazwƒô z tpBind_local
    saveSewers = nil, -- Zmieniono nazwƒô z ssBind_local
    saveVibe = nil, -- Zmieniono nazwƒô z svBind_local
    infiniteStamina = nil,
    noRecoil = nil, -- Zmieniono nazwƒô z nrBind_local
    esp = nil,
    aimbot = AimBotSettings.Keybind, -- Pobierz aktualnƒÖ warto≈õƒá z ustawie≈Ñ aimbota
    invis = nil,
    antiAFK = nil,
    noFailLockpick = nil,
    openNearbyDoors = nil,
    unlockNearbyDoors = nil -- Ostatni bind
}

-- === Przypisanie ramek do kategorii (Wieloliniowe) ===

-- Combat Category
table.insert(categoryFrames.Combat,
    createToggleRowFrame("Melee Aura", true, function() return MeleeAura_Enabled end, MeleeAura_Enable, MeleeAura_Disable, function() return keyBinds.melee end, function(k) keyBinds.melee=k end)
)
table.insert(categoryFrames.Combat,
    createToggleRowFrame("Aimbot", true, function() return AimBotSettings.Enabled end, Aimbot_Enable, Aimbot_Disable, function() return keyBinds.aimbot end, function(k) keyBinds.aimbot=k; AimBotSettings.Keybind=k end) -- Nadal aktualizuj AimBotSettings
)
table.insert(categoryFrames.Combat,
    createToggleRowFrame("No Recoil", true, function() return NoRecoil_Enabled end, NoRecoil_Enable, NoRecoil_Disable, function() return keyBinds.noRecoil end, function(k) keyBinds.noRecoil=k end)
)

-- Movement Category
table.insert(categoryFrames.Movement,
    createToggleRowFrame("Fly", true, function() return Fly_Enabled end, Fly_Enable, Fly_Disable, function() return keyBinds.fly end, function(k) keyBinds.fly=k; Fly_Bind=k end) -- Nadal aktualizuj Fly_Bind, je≈õli jest u≈ºywany gdzie≈õ indziej
)
table.insert(categoryFrames.Movement,
    createToggleRowFrame("Infinite Stamina", true, function() return isInfiniteStaminaEnabled end, InfiniteStamina_Enable, InfiniteStamina_Disable, function() return keyBinds.infiniteStamina end, function(k) keyBinds.infiniteStamina=k end)
)

-- Visuals Category
table.insert(categoryFrames.Visuals,
    createToggleRowFrame("Wallhack", true, function() return ESP_Enabled end, ESP_Enable, ESP_Disable, function() return keyBinds.esp end, function(k) keyBinds.esp=k end)
)
table.insert(categoryFrames.Visuals,
    createToggleRowFrame("Invisibility", true, _G.IsInvisEnabled, _G.Invis_Enable, _G.Invis_Disable, function() return keyBinds.invis end, function(k) keyBinds.invis=k end) -- U≈ºywa funkcji z _G
)

-- Farming Category (Zmieniono nazwƒô z Teleport)
table.insert(categoryFrames.Farming,
    createToggleRowFrame("Teleport Farm", true, function() return TPFarm_Enabled end, TPFarm_Enable, TPFarm_Disable, function() return keyBinds.tpFarm end, function(k) keyBinds.tpFarm=k end)
)
table.insert(categoryFrames.Farming,
    createTPFarmTargetRowFrame() -- Dodaj pole tekstowe pod spodem (bez zmian)
)
table.insert(categoryFrames.Farming,
    createToggleRowFrame("Safe Sewers TP", true, function() return SaveSewers_Enabled end, SaveSewers_Enable, SaveSewers_Disable, function() return keyBinds.saveSewers end, function(k) keyBinds.saveSewers=k end)
)
table.insert(categoryFrames.Farming,
    createToggleRowFrame("Safe Vibecheck TP", true, function() return SaveVibe_Enabled end, SaveVibe_Enable, SaveVibe_Disable, function() return keyBinds.saveVibe end, function(k) keyBinds.saveVibe=k end)
)

-- Misc Category
--table.insert(categoryFrames.Misc,
    --createToggleRowFrame(" Anti AFK", true, function() return AntiAFK_Enabled_Dummy end, AntiAFK_Enable, AntiAFK_Disable, function() return keyBinds.antiAFK end, function(k) keyBinds.antiAFK=k end)
--)
table.insert(categoryFrames.Misc,
    createToggleRowFrame("Staff Detector", true, function() return AdminCheck_Enabled end, AdminCheck_Enable, AdminCheck_Disable, function() return keyBinds.adminCheck end, function(k) keyBinds.adminCheck=k end)
)
table.insert(categoryFrames.Misc,
    createToggleRowFrame("Auto Pickup Money", true, function() return AutoPickupMoney_Enabled end, AutoPickupMoney_Enable, AutoPickupMoney_Disable, function() return keyBinds.autoPickupMoney end, function(k) keyBinds.autoPickupMoney=k end)
)
table.insert(categoryFrames.Misc,
    createToggleRowFrame("No Fail Lockpick", true, function() return NoFailLockpick_Enabled end, NoFailLockpick_Enable, NoFailLockpick_Disable, function() return keyBinds.noFailLockpick end, function(k) keyBinds.noFailLockpick=k end)
)
table.insert(categoryFrames.Misc,
    createToggleRowFrame("Auto Unlock Doors", true, function() return UnlockNearbyDoors_Enabled end, UnlockNearbyDoors_Enable, UnlockNearbyDoors_Disable, function() return keyBinds.unlockNearbyDoors end, function(k) keyBinds.unlockNearbyDoors=k end)
)
table.insert(categoryFrames.Misc,
    createToggleRowFrame("Auto Open Doors", true, function() return OpenNearbyDoors_Enabled end, OpenNearbyDoors_Enable, OpenNearbyDoors_Disable, function() return keyBinds.openNearbyDoors end, function(k) keyBinds.openNearbyDoors=k end)
)

-------------------------------------------------------------------------------
--  8. Globalny Listener InputBegan dla Bind√≥w (Poprawiona aktywacja v4)
-------------------------------------------------------------------------------
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then
        return -- Ignoruj input, je≈õli gra go przetworzy≈Ça (np. pisanie na czacie)
    end

    local keyCode = input.KeyCode
    if keyCode == Enum.KeyCode.Unknown then
        return -- Ignoruj nieznane klawisze
    end

    -- Obs≈Çuga ustawiania nowego binda
    if currentRowWaitingForKey then
        local frame = currentRowWaitingForKey -- Ramka oczekujƒÖca
        local bindButton = bindButtonReferences[frame]
        local getKeyFn = keyBindGetters[frame]
        local setKeyFn = keyBindSetters[frame]
        local frameData = rowFunctionData[frame] -- Pobierz zapisane funkcje dla tej ramki

        -- Upewnij siƒô, ≈ºe mamy wszystkie potrzebne referencje
        if bindButton and getKeyFn and setKeyFn and frameData then
            local oldKey = nil
            local successGet, resultGet = pcall(getKeyFn)
            if successGet then
                oldKey = resultGet
            end

            -- Usu≈Ñ stary bind z tabeli activeBinds, je≈õli istnia≈Ç DLA TEJ FUNKCJI
            if oldKey and activeBinds[oldKey] and activeBinds[oldKey].frame == frame then
                activeBinds[oldKey] = nil
            end

            -- Sprawd≈∫, czy nowy klawisz jest ju≈º przypisany do INNEJ funkcji
            if activeBinds[keyCode] and activeBinds[keyCode].frame ~= frame then
                 local otherFrame = activeBinds[keyCode].frame
                 local otherBindButton = bindButtonReferences[otherFrame]
                 local otherSetKeyFn = keyBindSetters[otherFrame]
                 if otherSetKeyFn then
                     pcall(otherSetKeyFn, nil) -- Wyzeruj stary bind
                 end
                 if otherBindButton then
                     otherBindButton.Text = "Bind" -- Zaktualizuj tekst starego przycisku
                 end
                 activeBinds[keyCode] = nil -- Usu≈Ñ stary wpis z activeBinds
            end

            -- Ustaw nowy klawisz za pomocƒÖ settera
            pcall(setKeyFn, keyCode)

            -- Znajd≈∫ przycisk toggle dla tej ramki
            local toggleButton = nil
            for _, child in ipairs(frame:GetChildren()) do if child:IsA("TextButton") and child ~= bindButton then toggleButton = child; break end end

            if toggleButton then
                -- Zapisz pe≈ÇnƒÖ informacjƒô w activeBinds DLA NOWEGO KLAWISZA, u≈ºywajƒÖc danych z rowFunctionData
                activeBinds[keyCode] = {
                    frame = frame,
                    toggleButton = toggleButton,
                    isEnabledFn = frameData.isEnabledFn,
                    onEnable = frameData.onEnable,
                    onDisable = frameData.onDisable,
                    canToggle = frameData.canToggle,
                    updateFn = frameData.updateFn
                }
            else
                 warn("Could not find toggle button for frame", frame.Name, "when binding key", keyCode.Name)
            end

            -- Zaktualizuj tekst przycisku bind
            bindButton.Text = "[" .. input.KeyCode.Name .. "]"
            currentRowWaitingForKey = nil -- Zako≈Ñcz przechwytywanie
        else
            if bindButton then bindButton.Text = "Bind" end -- Zresetuj tekst na wszelki wypadek
            currentRowWaitingForKey = nil
            warn("Error during key capture - missing functions/references for frame:", frame and frame.Name or "Unknown")
        end

    elseif activeBinds[keyCode] then -- Aktywacja przez bind
        local bindInfo = activeBinds[keyCode]
        -- Sprawd≈∫, czy kluczowe elementy istniejƒÖ w pobranych danych bindu
        if bindInfo.frame and bindInfo.isEnabledFn and bindInfo.onEnable and bindInfo.onDisable and bindInfo.updateFn and bindInfo.canToggle ~= nil then

            if bindInfo.canToggle then -- Aktywuj tylko je≈õli funkcja jest prze≈ÇƒÖczalna
                local success, currentState = pcall(bindInfo.isEnabledFn)
                if success then
                    if currentState then
                        pcall(bindInfo.onDisable) -- Wywo≈Çaj Disable
                    else
                        pcall(bindInfo.onEnable) -- Wywo≈Çaj Enable
                    end
                    -- Od≈õwie≈º przycisk po zmianie stanu
                    task.wait() -- Daj chwilƒô na przetworzenie zmiany stanu flagi
                    pcall(bindInfo.updateFn) -- Wywo≈Çaj funkcjƒô aktualizujƒÖcƒÖ przycisk
                end
            end
        end
    end
end)

PlayerGui.ChildAdded:Connect(function(Item)
    if Item.Name == "LockpickGUI" then
        -- Apply modification when the GUI appears, based on the current enabled state
        ApplyLockpickModification()
    end
end)

-------------------------------------------------------------------------------
--  9. Ustawienie Domy≈õlnej Kategorii i Animacja Otwierania
-------------------------------------------------------------------------------
-- Poka≈º domy≈õlnƒÖ kategoriƒô na starcie
switchCategory(defaultCategory)

-- Animacja otwierania okna
mainFrame.Size=UDim2.new(0,0,0,0)
local openTween=TweenService:Create(mainFrame,TweenInfo.new(0.4,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Size=UDim2.new(0,450,0,350)})
task.wait(0.1)
openTween:Play()
print("EQR Hub (Formatted UI - Original Logic - Final Fixes v5) Loaded.")
