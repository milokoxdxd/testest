
			wait(0.5)
			local VirtualUser = game:service('VirtualUser')

			game:service('Players').LocalPlayer.Idled:Connect(function()
				VirtualUser:CaptureController()
				VirtualUser:ClickButton2(Vector2.new())
			end)

			local Players = game:GetService("Players")
			local RunService = game:GetService("RunService")
			local UserInputService = game:GetService("UserInputService")
			local VirtualUser = game:GetService("VirtualUser")

			local LocalPlayer = Players.LocalPlayer

			-------------------------------------------------------------------------------
			--    1. Создаём ScreenGui и основное окно (mainFrame)
			-------------------------------------------------------------------------------
			local screenGui = Instance.new("ScreenGui")
			screenGui.Name = "VenomHubScreenGui"
			screenGui.ResetOnSpawn = false
			screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

			local mainFrame = Instance.new("Frame")
			mainFrame.Name = "VenomHubMainFrame"
			mainFrame.Size = UDim2.new(0, 340, 0, 420)
			mainFrame.Position = UDim2.new(0.05, 0.1, 0.1, 0) -- Centrujemy
			mainFrame.BackgroundColor3 = Color3.fromRGB(33, 33, 33) -- Ciemniejsze tło
			mainFrame.BorderSizePixel = 0
			mainFrame.Visible = true
			mainFrame.Active = true
			mainFrame.Selectable = true
			mainFrame.Parent = screenGui

			-- Zaokrąglenia i cień
			local mainCorner = Instance.new("UICorner")
			mainCorner.CornerRadius = UDim.new(0, 12)
			mainCorner.Parent = mainFrame

			-- Cień (użyjemy Frame dla lepszego efektu)
			local shadowFrame = Instance.new("Frame")
			shadowFrame.Size = mainFrame.Size + UDim2.new(0, 6, 0, 6)
			shadowFrame.Position = UDim2.new(0, -3, 0, -3)
			shadowFrame.BackgroundColor3 = Color3.new(0, 0, 0)
			shadowFrame.BackgroundTransparency = 0.6
			shadowFrame.BorderSizePixel = 0
			shadowFrame.Parent = mainFrame
			shadowFrame.ZIndex = 0

			local shadowCorner = Instance.new("UICorner")
			shadowCorner.CornerRadius = UDim.new(0, 12)
			shadowCorner.Parent = shadowFrame

			-- Tytuł
			local titleBar = Instance.new("Frame")
			titleBar.Name = "TitleBar"
			titleBar.Size = UDim2.new(1, 0, 0, 40)
			titleBar.Position = UDim2.new(0, 0, 0, 0)
			titleBar.BackgroundColor3 = Color3.fromRGB(45, 45, 45) -- Jeszcze ciemniejszy
			titleBar.Parent = mainFrame

			local titleCorner = Instance.new("UICorner")
			titleCorner.CornerRadius = UDim.new(0, 12)
			titleCorner.Parent = titleBar

			local titleLabel = Instance.new("TextLabel")
			titleLabel.Size = UDim2.new(1, 1, 1, 1)
			titleLabel.BackgroundTransparency = 1
			titleLabel.TextColor3 = Color3.fromRGB(230, 230, 230)
			titleLabel.Font = Enum.Font.GothamBold
			titleLabel.TextSize = 20
			titleLabel.Text = "EQR Hub"
			titleLabel.Parent = titleBar

			-- Podpis
			local footerFrame = Instance.new("Frame")
			footerFrame.Size = UDim2.new(1, 0, 0, 25)
			footerFrame.Position = UDim2.new(0, 0, 1, -25)
			footerFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
			footerFrame.Parent = mainFrame

			local footerCorner = Instance.new("UICorner")
			footerCorner.CornerRadius = UDim.new(0, 12)
			footerCorner.Parent = footerFrame

			local footerLabel = Instance.new("TextLabel")
			footerLabel.Size = UDim2.new(1, 1, 1, 1)
			footerLabel.BackgroundTransparency = 1
			footerLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
			footerLabel.Font = Enum.Font.Gotham
			footerLabel.TextSize = 14
			footerLabel.Text = "By helloitsme#4243"
			footerLabel.Parent = footerFrame

			-- Przewijana zawartość
			local contentFrame = Instance.new("ScrollingFrame")
			contentFrame.Name = "ContentFrame"
			contentFrame.Size = UDim2.new(1, -20, 1, -80)
			contentFrame.Position = UDim2.new(0, 10, 0, 50)
			contentFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
			contentFrame.BorderSizePixel = 0
			contentFrame.ScrollingDirection = Enum.ScrollingDirection.Y
			contentFrame.ScrollBarThickness = 6
			contentFrame.CanvasSize = UDim2.new(0, 0, 2, 0) -- Zapas na scroll
			contentFrame.Parent = mainFrame

			local contentCorner = Instance.new("UICorner")
			contentCorner.CornerRadius = UDim.new(0, 12)
			contentCorner.Parent = contentFrame

			local UIListLayout = Instance.new("UIListLayout")
			UIListLayout.Padding = UDim.new(0, 8)
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
			UIListLayout.Parent = contentFrame

			-------------------------------------------------------------------------------
			--    2. Перетаскивание окна (mainFrame) при удержании ЛКМ
			-------------------------------------------------------------------------------
			do
				local dragging = false
				local dragOffset = Vector2.new()
				local tween = nil -- Dodajemy zmienną na tween

				mainFrame.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 then
						dragging = true
						dragOffset = Vector2.new(input.Position.X, input.Position.Y) - mainFrame.AbsolutePosition

						-- Przerywamy poprzedni tween, jeśli istnieje
						if tween then
							tween:Cancel()
						end
					end
				end)

				mainFrame.InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 then
						dragging = false
					end
				end)

				UserInputService.InputChanged:Connect(function(input)
					if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
						local newPosition = Vector2.new(input.Position.X, input.Position.Y) - dragOffset
						local targetPosition = UDim2.fromOffset(newPosition.X, newPosition.Y)

						-- Tworzymy nowy tween
						local tweenInfo = TweenInfo.new(
							0.1, -- Czas trwania animacji (możesz dostosować)
							Enum.EasingStyle.Quad, -- Styl animacji (możesz dostosować)
							Enum.EasingDirection.Out -- Kierunek animacji (możesz dostosować)
						)

						tween = game:GetService("TweenService"):Create(mainFrame, tweenInfo, {Position = targetPosition})
						tween:Play()
					end
				end)
			end

			-------------------------------------------------------------------------------
			--    3. Клавиша [K] для показа/скрытия
			-------------------------------------------------------------------------------
			UserInputService.InputBegan:Connect(function(input, gp)
				if not gp and input.KeyCode == Enum.KeyCode.K then
					mainFrame.Visible = not mainFrame.Visible
				end
			end)

			-------------------------------------------------------------------------------
			--    4. Объявляем все переменные и функции скриптов
			-------------------------------------------------------------------------------

			--============================ Fly ============================--
			local Fly_Enabled = false
			local Fly_Bind = nil
			local Fly_Connection
			local Fly_Speed = 50

			local function Fly_Enable()
				if Fly_Enabled then return end
				Fly_Enabled = true

				Fly_Connection = RunService.RenderStepped:Connect(function(dt)
					if not Fly_Enabled then return end
					local char = LocalPlayer.Character
					local hrp = char and char:FindFirstChild("HumanoidRootPart")
					if hrp then
						local cam = workspace.CurrentCamera
						local moveDir = Vector3.new()
						if UserInputService:IsKeyDown(Enum.KeyCode.W) then
							moveDir += cam.CFrame.LookVector
						end
						if UserInputService:IsKeyDown(Enum.KeyCode.S) then
							moveDir -= cam.CFrame.LookVector
						end
						if UserInputService:IsKeyDown(Enum.KeyCode.A) then
							moveDir -= cam.CFrame.RightVector
						end
						if UserInputService:IsKeyDown(Enum.KeyCode.D) then
							moveDir += cam.CFrame.RightVector
						end
						if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
							moveDir += Vector3.new(0,1,0)
						end
						if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
							moveDir -= Vector3.new(0,1,0)
						end

						if moveDir.Magnitude > 0 then
							hrp.CFrame = hrp.CFrame + (moveDir.Unit * Fly_Speed * dt)
						end
					end
				end)
			end

			local function Fly_Disable()
				if not Fly_Enabled then return end
				Fly_Enabled = false
				if Fly_Connection then
					Fly_Connection:Disconnect()
					Fly_Connection = nil
				end
			end

			--========================== Admin Check ========================--
			local AdminCheck_Enabled = true
			local AdminCheck_Connection
			local AdminCheck_Coroutine

			local AdminList = {
				-- Имена возможных админов
				["tabootvcat"] = true,
				["Revenantic"] = true,
				["Saabor"] = true,
				["MoIitor"] = true,
				["IAmUnderAMask"] = true,
				["SheriffGorji"] = true,
				["xXFireyScorpionXx"] = true,
				["LoChips"] = true,
				["DeliverCreations"] = true,
				["TDXiswinning"] = true,
				["TZZV"] = true,
				["FelixVenue"] = true,
				["SIEGFRlED"] = true,
				["ARRYvvv"] = true,
				["z_papermoon"] = true,
				["Malpheasance"] = true,
				["ModHandIer"] = true,
				["valphex"] = true,
				["J_anday"] = true,
				["tvdisko"] = true,
				["yIlehs"] = true,
				["COLOSSUSBUILTOFSTEEL"] = true,
				["SeizedHolder"] = true,
				["r3shape"] = true,
				["RVVZ"] = true,
				["adurize"] = true,
				["codedcosmetics"] = true,
				["QuantumCaterpillar"] = true,
				["FractalHarmonics"] = true,
				["GalacticSculptor"] = true,
				["oTheSilver"] = true,
				["Kretacaous"] = true,
				["icarus_xs1goliath"] = true,
				["GlamorousDradon"] = true,
				["rainjeremy"] = true,
				["parachuter2000"] = true,
				["faintermercury"] = true,
				["harht"] = true,
				["Sansek1252"] = true,
				["Snorpuwu"] = true,
				["BenAzoten"] = true,
				["Cand1ebox"] = true,
				["KeenlyAware"] = true,
				["mrzued"] = true,
				["BruhmanVIII"] = true,
				["Nystesia"] = true,
				["fausties"] = true,
				["zateopp"] = true,
				["Iordnabi"] = true,
				["ReviveTheDevil"] = true,
				["jake_jpeg"] = true,
				["UncrossedMeat3888"] = true,
				["realpenyy"] = true,
				["karateeeh"] = true,
				["JayyMlg"] = true,
				["Lo_Chips"] = true,
				["Avelosky"] = true,
				["king_ab09"] = true,
				["TigerLe123"] = true,
				["Dalvanuis"] = true,
				["iSonMillions"] = true,

				-- Новые имена:
				["DieYouOder"] = true,
				["whosframed"] = true
			}

			local function CheckAdmins()
				for _, plr in ipairs(Players:GetPlayers()) do
					if AdminList[plr.Name] then
						LocalPlayer:Kick("Admin")
						task.wait(2)
						game:Shutdown()
						return
					end
				end
			end

			local function AdminCheck_Enable()
				if AdminCheck_Enabled then return end
				AdminCheck_Enabled = true

				-- Сразу проверяем текущих игроков
				CheckAdmins()

				AdminCheck_Connection = Players.PlayerAdded:Connect(function(plr)
					if not AdminCheck_Enabled then return end
					if AdminList[plr.Name] then
						LocalPlayer:Kick("Detected Nigger") -- Исходная формулировка автора
						task.wait(2)
						game:Shutdown()
					end
				end)

				AdminCheck_Coroutine = coroutine.create(function()
					while AdminCheck_Enabled do
						CheckAdmins()
						task.wait(4)
					end
				end)
				coroutine.resume(AdminCheck_Coroutine)
			end

			local function AdminCheck_Disable()
				if not AdminCheck_Enabled then return end
				AdminCheck_Enabled = false

				if AdminCheck_Connection then
					AdminCheck_Connection:Disconnect()
					AdminCheck_Connection = nil
				end
				AdminCheck_Coroutine = nil
			end

			--=================== Melee Aura 4 Alt MAX! =====================--
			local MeleeAura_Enabled = false
			local MeleeAura_Connection

			local runAttackLoop do
				local plrs = game:GetService("Players")
				local me = plrs.LocalPlayer
				local run = game:GetService("RunService")

				local remote1 = game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("XMHH.2")
				local remote2 = game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("XMHH2.2")

				local maxdist = 20

				local function Attack(target)
					if not (target and target:FindFirstChild("Head")) then return end
					local arg1 = {
						[1] = "🍞",
						[2] = tick(),
						[3] = me.Character and me.Character:FindFirstChildOfClass("Tool"),
						[4] = "43TRFWX",
						[5] = "Normal",
						[6] = tick(),
						[7] = true
					}
					local result = remote1:InvokeServer(unpack(arg1))
					task.wait(0.1)

					local tool = me.Character and me.Character:FindFirstChildOfClass("Tool")
					if tool then
						local Handle = tool:FindFirstChild("WeaponHandle") or tool:FindFirstChild("Handle")
									  or me.Character:FindFirstChild("Right Arm")
						if Handle and target:FindFirstChild("Head") then
							local arg2 = {
								[1] = "🍞",
								[2] = tick(),
								[3] = tool,
								[4] = "2389ZFX34",
								[5] = result,
								[6] = false,
								[7] = Handle,
								[8] = target:FindFirstChild("Head"),
								[9] = target,
								[10] = me.Character:FindFirstChild("HumanoidRootPart").Position,
								[11] = target:FindFirstChild("Head").Position
							}
							remote2:FireServer(unpack(arg2))
						end
					end
				end

				runAttackLoop = function()
					return run.RenderStepped:Connect(function()
						if not MeleeAura_Enabled then return end
						local char = me.Character
						local hrp = char and char:FindFirstChild("HumanoidRootPart")
						if hrp then
							for _, plr in ipairs(plrs:GetPlayers()) do
								if plr ~= me then
									local c = plr.Character
									local hrp2 = c and c:FindFirstChild("HumanoidRootPart")
									local hum = c and c:FindFirstChildOfClass("Humanoid")
									if hrp2 and hum then
										local dist = (hrp.Position - hrp2.Position).Magnitude
										if dist < maxdist and hum.Health > 15 and not c:FindFirstChildOfClass("ForceField") then
											Attack(c)
										end
									end
								end
							end
						end
					end)
				end
			end

			local function MeleeAura_Enable()
				if MeleeAura_Enabled then return end
				MeleeAura_Enabled = true
				MeleeAura_Connection = runAttackLoop()
			end

			local function MeleeAura_Disable()
				if not MeleeAura_Enabled then return end
				MeleeAura_Enabled = false

				if MeleeAura_Connection then
					MeleeAura_Connection:Disconnect()
					MeleeAura_Connection = nil
				end
			end

			--======================= Teleport Farm =========================--
			local TPFarm_Enabled = false
			local TPFarm_TargetName = "PixelDancerPrism"

			-- Сохраняем все подключения, чтобы отключать при Disable
			local TPFarm_SteppedConnection = nil
			local TPFarm_RenderConnection = nil
			local TPFarm_CharConnection = nil
			local DeathRespawn_Event = game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("DeathRespawn")

			-- Локальная функция, вызываемая при спавне персонажа (CharacterAdded)
			local function TPFarm_OnCharacterAdded(char)
				-- На всякий случай отключим старый SteppedConnection, если ещё не отключён
				if TPFarm_SteppedConnection then
					TPFarm_SteppedConnection:Disconnect()
					TPFarm_SteppedConnection = nil
				end

				-- Немного ждём, чтобы HumanoidRootPart успел загрузиться
				task.wait(0.4)
				local hrp = char:FindFirstChild("HumanoidRootPart")
				local hum = char:FindFirstChildOfClass("Humanoid")
				if not (hrp and hum) then return end

				-- Подключаемся к RunService.Stepped для телепорта к главному игроку
				TPFarm_SteppedConnection = RunService.Stepped:Connect(function()
					if not TPFarm_Enabled then return end
					local mainPlayer = Players:FindFirstChild(TPFarm_TargetName)
					local mainChar = mainPlayer and mainPlayer.Character
					local mainHRP = mainChar and mainChar:FindFirstChild("HumanoidRootPart")
					if mainHRP then
						-- Держим персонажа на расстоянии 3 единиц перед таргетом
						hrp.CFrame = mainHRP.CFrame + (mainHRP.CFrame.LookVector * 3)

						-- Разово подключимся к HealthChanged, чтобы обнулять здоровье
						-- (Если это делать при каждом рендере, будет утечка)
						hum:GetPropertyChangedSignal("Health"):Connect(function()
							hum.Health = 0
						end)
					end
				end)
			end

			local function TPFarm_Enable()
				if TPFarm_Enabled then return end
				TPFarm_Enabled = true
				local killpart = game.Workspace.Filter.Parts:FindFirstChild("Kill_Brick")
				if killpart then
					killpart:Destroy()
				end

				local me = LocalPlayer

				-- Если персонаж уже есть
				if me.Character then
					TPFarm_OnCharacterAdded(me.Character)
				end

				-- Отслеживаем респавны
				TPFarm_CharConnection = me.CharacterAdded:Connect(function(newChar)
					if not TPFarm_Enabled then return end
					TPFarm_OnCharacterAdded(newChar)

					-- Переносим оружие из рюкзака в руки
					local tool = me.Backpack:FindFirstChildOfClass("Tool")
					if tool and newChar then
						tool.Parent = newChar
					end
				end)

				-- Подключаемся к RenderStepped, чтобы авто-возрождаться при смерти
				TPFarm_RenderConnection = RunService.RenderStepped:Connect(function()
					if not TPFarm_Enabled then return end
					local char = me.Character
					if char then
						local humanoid = char:FindFirstChildOfClass("Humanoid")
						if humanoid and humanoid.Health <= 0 then
							DeathRespawn_Event:InvokeServer("KMG4R904")
						end
					end
				end)
			end

			local function TPFarm_Disable()
				if not TPFarm_Enabled then return end
				TPFarm_Enabled = false

				if TPFarm_SteppedConnection then
					TPFarm_SteppedConnection:Disconnect()
					TPFarm_SteppedConnection = nil
				end
				if TPFarm_RenderConnection then
					TPFarm_RenderConnection:Disconnect()
					TPFarm_RenderConnection = nil
				end
				if TPFarm_CharConnection then
					TPFarm_CharConnection:Disconnect()
					TPFarm_CharConnection = nil
				end
			end

			--================= 3 Save-Places (Cube/Vibecheck/Mountain) =======
			local event = DeathRespawn_Event

			-- 1) Save EQR
			local SaveCube_Enabled = false
			local SaveCube_Connection
			local SaveCube_Position = Vector3.new(-4597, -152, -1326)

			local function SaveCube_Enable()
				if SaveCube_Enabled then return end
				SaveCube_Enabled = true
				local killpart = game.Workspace.Filter.Parts:FindFirstChild("Kill_Brick")
				if killpart then
					killpart:Destroy()
				end

				SaveCube_Connection = RunService.RenderStepped:Connect(function()
					if not SaveCube_Enabled then return end
					local char = LocalPlayer.Character
					if char then
						local hrp = char:FindFirstChild("HumanoidRootPart")
						local hum = char:FindFirstChildOfClass("Humanoid")
						if hrp then
							hrp.CFrame = CFrame.new(SaveCube_Position)
						end
						local tool = LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
						if tool and tool.Parent ~= char then
							wait(1)
							tool.Parent = char
						end
						if hum and hum.Health <= 0 then
							event:InvokeServer("KMG4R904") -- авто возрождение
						end
					end
				end)
			end

			local function SaveCube_Disable()
				if not SaveCube_Enabled then return end
				SaveCube_Enabled = false
				if SaveCube_Connection then
					SaveCube_Connection:Disconnect()
					SaveCube_Connection = nil
				end
			end
            -- 2) Save Sewers
			local SaveSewers_Enabled = false
			local SaveSewers_Connection
			local SaveSewers_Position = Vector3.new(-4162, -84, -498)

			local function SaveSewers_Enable()
				if SaveSewers_Enabled then return end
				SaveSewers_Enabled = true
				local killpart = game.Workspace.Filter.Parts:FindFirstChild("Kill_Brick")
				if killpart then
					killpart:Destroy()
				end

				SaveSewers_Connection = RunService.RenderStepped:Connect(function()
					if not SaveSewers_Enabled then return end
					local char = LocalPlayer.Character
					if char then
						local hrp = char:FindFirstChild("HumanoidRootPart")
						local hum = char:FindFirstChildOfClass("Humanoid")
						if hrp then
							hrp.CFrame = CFrame.new(SaveSewers_Position)
						end
						local tool = LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
						if tool and tool.Parent ~= char then
							wait(1)
							tool.Parent = char
						end
						if hum and hum.Health <= 0 then
							event:InvokeServer("KMG4R904") -- авто возрождение
						end
					end
				end)
			end

			local function SaveSewers_Disable()
				if not SaveSewers_Enabled then return end
				SaveSewers_Enabled = false
				if SaveSewers_Connection then
					SaveSewers_Connection:Disconnect()
					SaveSewers_Connection = nil
				end
			end           

            -- NoRecoil Function
            local NoRecoil_Enabled = false
            local NoRecoil_Connections = {}
            local GlobalOriginalValues = {} -- Globalne przechowywanie oryginalnych wartości
            local WeaponCache = {} -- Cache dla szybszego dostępu

            local Settings = { 
                GunMods = { 
                    NoRecoil = true, 
                    Spread = true, 
                    SpreadAmount = 0 
                } 
            }

            local Player = game:GetService("Players").LocalPlayer

            -- Szybkie zapisywanie oryginalnych wartości
            local function cacheWeapons()
                WeaponCache = {}
                for _, v in pairs(getgc(true)) do
                    if type(v) == 'table' and rawget(v, 'EquipTime') then
                        table.insert(WeaponCache, v)
                        if not GlobalOriginalValues[v] then
                            GlobalOriginalValues[v] = {
                                Recoil = v.Recoil,
                                CameraRecoilingEnabled = v.CameraRecoilingEnabled,
                                AngleX_Min = v.AngleX_Min,
                                AngleX_Max = v.AngleX_Max,
                                AngleY_Min = v.AngleY_Min,
                                AngleY_Max = v.AngleY_Max,
                                AngleZ_Min = v.AngleZ_Min,
                                AngleZ_Max = v.AngleZ_Max,
                                Spread = v.Spread
                            }
                        end
                    end
                end
            end

            -- Ultra szybka aplikacja modyfikacji
            local function applyGunMods()
                for _, weapon in ipairs(WeaponCache) do
                    if Settings.GunMods.NoRecoil then
                        weapon.Recoil = 0
                        weapon.CameraRecoilingEnabled = false
                        weapon.AngleX_Min = 0
                        weapon.AngleX_Max = 0
                        weapon.AngleY_Min = 0
                        weapon.AngleY_Max = 0
                        weapon.AngleZ_Min = 0
                        weapon.AngleZ_Max = 0
                    end
                    
                    if Settings.GunMods.Spread then
                        weapon.Spread = Settings.GunMods.SpreadAmount
                    end
                end
            end

            -- Szybki reset
            local function resetGunMods()
                for weapon, values in pairs(GlobalOriginalValues) do
                    weapon.Recoil = values.Recoil
                    weapon.CameraRecoilingEnabled = values.CameraRecoilingEnabled
                    weapon.AngleX_Min = values.AngleX_Min
                    weapon.AngleX_Max = values.AngleX_Max
                    weapon.AngleY_Min = values.AngleY_Min
                    weapon.AngleY_Max = values.AngleY_Max
                    weapon.AngleZ_Min = values.AngleZ_Min
                    weapon.AngleZ_Max = values.AngleZ_Max
                    weapon.Spread = values.Spread
                end
            end

            -- Optymalizowana obsługa broni
            local function handleWeapon(weapon)
                if NoRecoil_Enabled then
                    task.wait(0.1) -- Minimalne opóźnienie
                    cacheWeapons()
                    applyGunMods()
                end
            end

            -- Optymalizowana obsługa postaci
            local function onCharacterAdded(character)
                -- Szybkie sprawdzenie istniejących broni
                for _, child in ipairs(character:GetChildren()) do
                    if child:IsA("Tool") then
                        handleWeapon(child)
                    end
                end
                
                -- Połączenie dla nowych broni
                table.insert(NoRecoil_Connections, character.ChildAdded:Connect(function(child)
                    if child:IsA("Tool") then
                        handleWeapon(child)
                    end
                end))
                
                -- Obsługa śmierci
                table.insert(NoRecoil_Connections, character:WaitForChild("Humanoid").Died:Connect(function()
                    if NoRecoil_Enabled then
                        task.wait(1.5) -- Optymalne opóźnienie respawnu
                        cacheWeapons()
                        applyGunMods()
                    end
                end))
            end

            -- Błyskawiczne włączanie
            function NoRecoil_Enable()
                if NoRecoil_Enabled then return end
                NoRecoil_Enabled = true
                
                cacheWeapons()
                applyGunMods()
                
                -- Podpięcie zdarzeń
                table.insert(NoRecoil_Connections, Player.CharacterAdded:Connect(onCharacterAdded))
                if Player.Character then
                    onCharacterAdded(Player.Character)
                end
            end

            -- Natychmiastowe wyłączanie
            function NoRecoil_Disable()
                if not NoRecoil_Enabled then return end
                NoRecoil_Enabled = false
                
                resetGunMods()
                
                -- Czyszczenie połączeń
                for _, conn in ipairs(NoRecoil_Connections) do
                    conn:Disconnect()
                end
                NoRecoil_Connections = {}
            end
            -- WALLHACK
            local ESP_Enabled = false
            local ESP_Loading = false
            local LastToggleTime = 0
            local DEBOUNCE_TIME = 0.5 -- czas w sekundach między możliwością przełączenia

            function ESP_Enable()
                -- Zabezpieczenie przed spamem
                if os.clock() - LastToggleTime < DEBOUNCE_TIME then return end
                LastToggleTime = os.clock()
                
                if ESP_Loading then return end
                if ESP_Enabled then return end
                
                ESP_Loading = true
                
                local success, err = pcall(function()
                    loadstring(game:HttpGet("https://raw.githubusercontent.com/milokoxdxd/testest/refs/heads/main/EQResp", true))()
                    ESP_Enabled = true
                    ESP_Loading = false
                end)
                
                if not success then
                    warn("Błąd ładowania ESP: "..tostring(err))
                    ESP_Loading = false
                end
            end

            function ESP_Disable()
                -- Zabezpieczenie przed spamem
                if os.clock() - LastToggleTime < DEBOUNCE_TIME then return end
                LastToggleTime = os.clock()
                
                if not ESP_Enabled then return end
                
                ESP_Enabled = false
                
                -- Usuwanie wszystkich potencjalnych folderów ESP
                local coreGui = game:GetService("CoreGui")
                for _, name in pairs({"Folder", "ESP_Holder", "ESP_Folder", "ESP"}) do
                    local folder = coreGui:FindFirstChild(name)
                    if folder then
                        folder:Destroy()
                    end
                end
            end
            --============================ Invisibility ============================--
            local cloneref = cloneref or function(...) return ... end;

            local Service = setmetatable({}, {
                __index = function(_, k)
                    return cloneref(game:GetService(k));
                end
            });

            local Player: Player = game.Players.LocalPlayer;
            local Character: Model = Player.Character or Player.CharacterAdded:Wait();
            local HumanoidRootPart: BasePart = Character:WaitForChild("HumanoidRootPart");
            local Humanoid: Humanoid = Character:FindFirstChildOfClass("Humanoid") or Character:WaitForChild("Humanoid");

            Player.CharacterAdded:Connect(function(NewCharacter)
                Character = NewCharacter;
                HumanoidRootPart = Character:WaitForChild("HumanoidRootPart");
                Humanoid = Character:FindFirstChildOfClass("Humanoid") or Character:WaitForChild("Humanoid");
            end)

            if not Character:FindFirstChild("Torso") then
                return game.StarterGui:SetCore("SendNotification", {
                    Title = "FAILED",
                    Text = "Must be R6",
                    Duration = 5,
                });
            end

            local function Grounded()
                return Humanoid and Humanoid.Parent and Humanoid.FloorMaterial ~= Enum.Material.Air;
            end

            local InvisEnabled = false;
            local InvisConnections = {};

            local RunService: RunService = Service.RunService;
            local Heartbeat = RunService.Heartbeat;
            local RenderStepped = RunService.RenderStepped;

            local GUI = Instance.new("ScreenGui");
            GUI.Name = "WarningGUI";
            GUI.Parent = Service.CoreGui;

            local WarnLabel = Instance.new("TextLabel", GUI);
            WarnLabel.Text = "⚠️You are visible⚠️";
            WarnLabel.Visible = false;
            WarnLabel.Position = UDim2.new(0.5, 0, 0.75, 0);
            WarnLabel.AnchorPoint = Vector2.new(0.5, 0.5);
            WarnLabel.TextSize = 32;
            WarnLabel.TextColor3 = Color3.fromRGB(190, 190, 190);
            WarnLabel.BackgroundTransparency = 1;
            WarnLabel.TextStrokeTransparency = 0;
            WarnLabel.Font = Enum.Font.SourceSansBold;

            local function ApplyInvisibility()
                if not Character then return end;
                for _, v in pairs(Character:GetDescendants()) do
                    if v:IsA("BasePart") and v.Transparency ~= 1 then
                        v.Transparency = 0.5;
                    end
                end
                workspace.CurrentCamera.CameraSubject = HumanoidRootPart;
            end

            local function RevertVisibility()
                if not Character then return end;
                for _, v in pairs(Character:GetDescendants()) do
                    if v:IsA("BasePart") then
                        v.Transparency = 0;
                    end
                end
                if Humanoid and Humanoid.Parent then -- Sprawdzamy, czy Humanoid nadal istnieje
                    workspace.CurrentCamera.CameraSubject = Humanoid; -- Przywrócenie Subjectu kamery
                else
                    workspace.CurrentCamera.CameraSubject = workspace.CurrentCamera.Focus; -- Alternatywne ustawienie kamery
                end
                WarnLabel.Visible = false;
            end

            local function InvisLoop()
                if InvisEnabled and Character and Humanoid and HumanoidRootPart and Humanoid:IsDescendantOf(workspace) then -- Dodatkowe sprawdzenie, czy Humanoid nadal istnieje w workspace
                    WarnLabel.Visible = not Grounded();

                    local CF = CFrame;
                    local _, y = workspace.CurrentCamera.CFrame:ToOrientation();
                    HumanoidRootPart.CFrame = CF.new(HumanoidRootPart.CFrame.Position) * CF.fromOrientation(0, y, 0);

                    local OldCFrame = HumanoidRootPart.CFrame;
                    local OldCameraOffset = Humanoid.CameraOffset;

                    HumanoidRootPart.CFrame = HumanoidRootPart.CFrame * CF.Angles(math.rad(90), 0, 0);
                    Humanoid.CameraOffset = Vector3.new(0, 1.44, 0);

                    local Animation = Instance.new("Animation");
                    Animation.AnimationId = "rbxassetid://215384594";

                    local Track = Humanoid:LoadAnimation(Animation);
                    if Track then -- Sprawdzamy, czy animacja została załadowana pomyślnie
                        Track.Priority = Enum.AnimationPriority.Action4;
                        Track:Play();
                        Track:AdjustSpeed(0);
                        Track.TimePosition = 0.3;

                        RenderStepped:Wait();

                        Humanoid.CameraOffset = OldCameraOffset;
                        HumanoidRootPart.CFrame = OldCFrame;

                        Track:Stop();

                        local LookVector = workspace.CurrentCamera.CFrame.LookVector;
                        local Horizontal = Vector3.new(LookVector.X, 0, LookVector.Z).Unit;
                        local TargetCFrame = CFrame.new(HumanoidRootPart.Position, HumanoidRootPart.Position + Horizontal);
                        HumanoidRootPart.CFrame = TargetCFrame;

                        ApplyInvisibility();
                    else
                        warn("Nie udało się załadować animacji dla niewidzialności.");
                        RevertVisibility();
                        Invis_Disable();
                    end
                elseif Character then
                    RevertVisibility(); -- Upewniamy się, że widoczność jest przywracana, gdy warunki niewidzialności nie są spełnione
                end
            end

            function Invis_Enable()
                if InvisEnabled then return end;
                InvisEnabled = true;
                if #InvisConnections == 0 then
                    table.insert(InvisConnections, Heartbeat:Connect(InvisLoop));
                end
                ApplyInvisibility(); -- Natychmiastowo zastosuj niewidzialność po włączeniu
            end

            function Invis_Disable()
                if not InvisEnabled then return end;
                InvisEnabled = false;
                RevertVisibility(); -- Przywróć widoczność po wyłączeniu
                -- Rozłącz wszystkie połączenia Heartbeat
                for _, connection in ipairs(InvisConnections) do
                    connection:Disconnect();
                end
                table.clear(InvisConnections);
            end

            -- Teraz możesz wywoływać Invis_Enable() i Invis_Disable() z innego skryptu.
			-------------------------------------------------------------------------------
			--    5. Функция создания строки (createToggleRow) для кнопок
			-------------------------------------------------------------------------------
			local function createToggleRow(parent, scriptName, canToggle, isEnabledFn, onEnable, onDisable, getKeyBindFn, setKeyBindFn)
				local frame = Instance.new("Frame")
				frame.Size = UDim2.new(1, 0, 0, 40)
				frame.BackgroundTransparency = 1
				frame.Parent = parent

				-- Etykieta
				local label = Instance.new("TextLabel")
				label.Size = UDim2.new(0.5, -10, 1, 0)
				label.Position = UDim2.new(0, 10, 0, 0)
				label.BackgroundTransparency = 1
				label.Text = scriptName
				label.TextColor3 = Color3.fromRGB(220, 220, 220)
				label.Font = Enum.Font.GothamSemibold
				label.TextSize = 16
				label.TextXAlignment = Enum.TextXAlignment.Left
				label.Parent = frame

				-- Kontener przycisków
				local buttonsContainer = Instance.new("Frame")
				buttonsContainer.Size = UDim2.new(0.5, -10, 1, 0)
				buttonsContainer.Position = UDim2.new(0.5, 0, 0, 0)
				buttonsContainer.BackgroundColor3 = Color3.fromRGB(40, 40, 40) -- Ustawiamy szare tło
				buttonsContainer.Parent = frame

				-- Przycisk toggle
				local toggleButton = Instance.new("TextButton")
				toggleButton.Size = UDim2.new(0.5, -5, 0.7, 0)
				toggleButton.Position = UDim2.new(0, 0, 0.15, 0)
				toggleButton.Font = Enum.Font.GothamBold
				toggleButton.TextSize = 14
				toggleButton.TextColor3 = Color3.fromRGB(240, 240, 240)
				toggleButton.BorderSizePixel = 0
				toggleButton.Parent = buttonsContainer

				local toggleCorner = Instance.new("UICorner")
				toggleCorner.CornerRadius = UDim.new(0, 4)
				toggleCorner.Parent = toggleButton

				-- Przycisk bind (jeśli potrzebny)
				local bindButton = Instance.new("TextButton")
				bindButton.Size = UDim2.new(0.5, -5, 0.7, 0)
				bindButton.Position = UDim2.new(0.5, 0, 0.15, 0)
				bindButton.Font = Enum.Font.GothamMedium
				bindButton.TextSize = 14
				bindButton.Text = "Bind"
				bindButton.TextColor3 = Color3.fromRGB(240, 240, 240)
				bindButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60) -- Szary jako domyślny
				bindButton.BorderSizePixel = 0
				bindButton.Parent = buttonsContainer

				local bindCorner = Instance.new("UICorner")
				bindCorner.CornerRadius = UDim.new(0, 4)
				bindCorner.Parent = bindButton

				-- Funkcja aktualizująca wygląd przycisku
				local function updateToggleButton()
					if not canToggle then
						toggleButton.Text = "RUN"
						toggleButton.BackgroundColor3 = Color3.fromRGB(100, 100, 255) -- Niebieski dla jednorazowych akcji
						return
					end

					if isEnabledFn() then
						toggleButton.Text = "ON"
						toggleButton.BackgroundColor3 = Color3.fromRGB(50, 200, 50) -- Zielony
					else
						toggleButton.Text = "OFF"
						toggleButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50) -- Czerwony
					end
				end
				updateToggleButton()

				-- Animacje
				local function animateButton(btn, hover, isToggle)
					local currentColor = btn.BackgroundColor3
					local targetColor

					if isToggle then
						-- Dla przycisku toggle zachowujemy podstawowy kolor, tylko przyciemniamy
						targetColor = hover and Color3.new(
							math.max(currentColor.r * 0.8, 0.2),
							math.max(currentColor.g * 0.8, 0.2),
							math.max(currentColor.b * 0.8, 0.2)
						) or (isEnabledFn() and Color3.fromRGB(50, 200, 50) or Color3.fromRGB(200, 50, 50)) -- Przywróć oryginalny kolor
					else
						-- Dla innych przycisków standardowa animacja
						targetColor = hover and Color3.fromRGB(80, 80, 80) or Color3.fromRGB(60, 60, 60)
					end

					game:GetService("TweenService"):Create(
						btn,
						TweenInfo.new(0.1),
						{ BackgroundColor3 = targetColor }
					):Play()
				end

				toggleButton.MouseEnter:Connect(function() animateButton(toggleButton, true, true) end)
				toggleButton.MouseLeave:Connect(function() animateButton(toggleButton, false, true) end)
				bindButton.MouseEnter:Connect(function() animateButton(bindButton, true, false) end)
				bindButton.MouseLeave:Connect(function() animateButton(bindButton, false, false) end)

				-- Obsługa kliknięcia
				toggleButton.MouseButton1Click:Connect(function()
					if not canToggle then
						onEnable()
						toggleButton.Text = "DONE"
						toggleButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50) -- Ciemniejszy zielony
						toggleButton.Active = false
						if getKeyBindFn then
							bindButton.Active = false
						end
						return
					end

					if isEnabledFn() then
						onDisable()
					else
						onEnable()
					end
					updateToggleButton()
				end)

				-- Obsługa przypisania klawisza
				if getKeyBindFn and setKeyBindFn then
					local capturingKey = false

					local function updateBindButtonText()
						local kb = getKeyBindFn()
						if kb then
							bindButton.Text = "[" .. kb.Name .. "]"
						else
							bindButton.Text = "Bind"
						end
					end
					updateBindButtonText()

					bindButton.MouseButton1Click:Connect(function()
						if capturingKey then
							capturingKey = false
							updateBindButtonText() -- Usunięto: bindButton.Text = "Bind"
						else
							capturingKey = true
							bindButton.Text = "Press Key..."
						end
					end)

					UserInputService.InputBegan:Connect(function(input, gp)
						if gp then return end
						if capturingKey then
							if input.KeyCode ~= Enum.KeyCode.Unknown then
								setKeyBindFn(input.KeyCode)
								capturingKey = false
								updateBindButtonText()
							end
						elseif getKeyBindFn() and input.KeyCode == getKeyBindFn() then
							if canToggle then
								if isEnabledFn() then
									onDisable()
								else
									onEnable()
								end
								updateToggleButton()
							else
								-- jednorazowy
								if not DeletedMob_Ran then
									onEnable()
									toggleButton.Text = "DONE"
									toggleButton.BackgroundColor3 = Color3.fromRGB(0, 130, 0)
									toggleButton.Active = false
									bindButton.Active = false
								end
							end
						end
					end)
				else
					-- Dostosowanie rozmiaru przycisku, gdy nie ma bindu
					toggleButton.Size = UDim2.new(1, -10, 0.7, 0)
					toggleButton.Position = UDim2.new(0, 5, 0.15, 0)
					bindButton.Visible = false -- Ukryj przycisk bind, bo go nie potrzebujemy.
				end

				return frame
			end

			-- Zmodernizowana wersja createTPFarmTargetRow
			local function createTPFarmTargetRow(parent)
				local row = Instance.new("Frame")
				row.Size = UDim2.new(1, 0, 0, 40)
				row.BackgroundTransparency = 1
				row.Parent = parent

				local label = Instance.new("TextLabel")
				label.Size = UDim2.new(0.4, 0, 1, 0)
				label.BackgroundTransparency = 1
				label.Text = "    TP Target:"
				label.TextColor3 = Color3.fromRGB(220, 220, 220)
				label.Font = Enum.Font.GothamSemibold
				label.TextSize = 16
				label.TextXAlignment = Enum.TextXAlignment.Left
				label.Parent = row

				local inputContainer = Instance.new("Frame")
				inputContainer.Size = UDim2.new(0.6, -10, 0.7, 0)
				inputContainer.Position = UDim2.new(0.4, 0, 0.15, 0)
				inputContainer.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
				inputContainer.BorderSizePixel = 0
				inputContainer.Parent = row

				local inputCorner = Instance.new("UICorner")
				inputCorner.CornerRadius = UDim.new(0, 4)
				inputCorner.Parent = inputContainer

				local input = Instance.new("TextBox")
				input.Size = UDim2.new(1, -10, 1, -4)
				input.Position = UDim2.new(0, 5, 0, 2)
				input.BackgroundTransparency = 1
				input.TextColor3 = Color3.new(1, 1, 1)
				input.Font = Enum.Font.Gotham
				input.TextSize = 14
				input.Text = TPFarm_TargetName
				input.ClearTextOnFocus = false
				input.Parent = inputContainer

				input.FocusLost:Connect(function()
					TPFarm_TargetName = input.Text
				end)

				-- Animacja najechania
				inputContainer.MouseEnter:Connect(function()
					game:GetService("TweenService"):Create(
						inputContainer,
						TweenInfo.new(0.1),
						{BackgroundColor3 = Color3.fromRGB(70, 70, 70)}
					):Play()
				end)

				inputContainer.MouseLeave:Connect(function()
					game:GetService("TweenService"):Create(
						inputContainer,
						TweenInfo.new(0.1),
						{BackgroundColor3 = Color3.fromRGB(50, 50, 50)}
					):Play()
				end)

				return row
			end

			-------------------------------------------------------------------------------
			--   6. Создаём кнопки в нужном порядке
			-------------------------------------------------------------------------------

			-- 1) Fly
			createToggleRow(
				contentFrame,
				" Fly",
				true,
				function() return Fly_Enabled end,
				Fly_Enable,
				Fly_Disable,
				function() return Fly_Bind end,
				function(k) Fly_Bind = k end
			)
			-- 2) Anti AFK
			do
				local adminCheckBind = nil
				createToggleRow(
					contentFrame,
					" Anti AFK",
					true,
					function() return AdminCheck_Enabled end,
					AntiAFK_Enable,
					function() return adminCheckBind end,
					function(k) adminCheckBind = k end
				)
			end
			-- 3) Admin Check
			do
				local adminCheckBind = nil
				createToggleRow(
					contentFrame,
					" Admin Check",
					true,
					function() return AdminCheck_Enabled end,
					AdminCheck_Enable,
					--AdminCheck_Disable,
					function() return adminCheckBind end,
					function(k) adminCheckBind = k end
				)
			end

			-- 4) Melee Aura 4 Alt MAX!
			do
				local meleeBind = nil
				createToggleRow(
					contentFrame,
					" Melee Aura",
					true,
					function() return MeleeAura_Enabled end,
					MeleeAura_Enable,
					MeleeAura_Disable,
					function() return meleeBind end,
					function(k) meleeBind = k end
				)
			end

			-- 5) Teleport Farm
			do
				local tpBind = nil
				createToggleRow(
					contentFrame,
					" Teleport Farm",
					true,
					function() return TPFarm_Enabled end,
					TPFarm_Enable,
					TPFarm_Disable,
					function() return tpBind end,
					function(k) tpBind = k end
				)
				createTPFarmTargetRow(contentFrame)
			end

			-- 6) Save EvilQueRo
			--do
			--	local scBind = nil
			--	createToggleRow(
			--		contentFrame,
			--		" Save EQR PLACE",
			--		true,
			--		function() return SaveCube_Enabled end,
			--		SaveCube_Enable,
			--		SaveCube_Disable,
			--		function() return scBind end,
			--		function(k) scBind = k end
			--	)
			--end
            -- 6) Save Sewers
			do
				local ssBind = nil
				createToggleRow(
					contentFrame,
					" Save Sewers",
					true,
					function() return SaveSewers_Enabled end,
					SaveSewers_Enable,
					SaveSewers_Disable,
					function() return ssBind end,
					function(k) ssBind = k end
				)
			end
            -- 7) NoRecoil
			do
				local nrBind = nil
				createToggleRow(
					contentFrame,
					" No Recoil",
					true,
					function() return NoRecoil_Enabled end,
					NoRecoil_Enable,
					NoRecoil_Disable,
					function() return nrBind end,
					function(k) nrBind = k end
				)
			end
            -- 7) ESP
 			do
				local espBind = nil
				createToggleRow(
					contentFrame,
					" Wallhack",
					true,
					function() return ESP_Enabled end,
					ESP_Enable,
					ESP_Disable,
					function() return espBind end,
					function(k) espBind = k end
				)
			end           
            -- 8) Invisibility
            do
                local invisBind = nil
                createToggleRow(
                    contentFrame,
                    " Invisibility",
                    true,
                    function() return InvisEnabled end,
                    Invis_Enable,
                    Invis_Disable,
                    function() return invisBind end,
                    function(k) invisBind = k end
                )
            end
